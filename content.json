{"meta":{"title":"Asteroid","subtitle":"","description":"学而思，思而行","author":"Komorebi","url":"https://asteroidcs.github.io","root":"/"},"pages":[{"title":"about","date":"2020-11-25T10:24:48.000Z","updated":"2020-11-26T04:33:22.397Z","comments":false,"path":"about/index.html","permalink":"https://asteroidcs.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-25T10:14:53.000Z","updated":"2020-12-01T02:09:11.467Z","comments":true,"path":"categories/index.html","permalink":"https://asteroidcs.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-25T11:24:28.000Z","updated":"2020-12-01T02:11:25.713Z","comments":true,"path":"link/index.html","permalink":"https://asteroidcs.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-25T10:21:58.000Z","updated":"2020-12-01T02:10:23.419Z","comments":true,"path":"tags/index.html","permalink":"https://asteroidcs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第十四章 网络编程","slug":"第十四章 网络编程","date":"2020-11-30T04:25:18.289Z","updated":"2020-12-01T01:41:42.240Z","comments":true,"path":"undefined/ce7e.html","link":"","permalink":"https://asteroidcs.github.io/undefined/ce7e.html","excerpt":"","text":"网络基础计算机网络​ 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。 网络编程的目的​ 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有两个主要的问题 如何准确地定位网络上一台或多台主机;定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信要素概述如何实现网络中的主机互相通信 通信双方地址 IP 端口号 一定的规则(即:网络通信协议。有两套参考模型) OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广 ==TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。== 数据传输视图 ==通信要素1: IP和端口号==IP 地址:InetAddress 唯一的标识 Internet 上的计算机(通信实体) 本地回环地址(hostAddress):127.0.0.1 主机名(hostName):localhost IP地址分类方式1:IPV4 和 IPV6 PV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1 IPV6:128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984 IP地址分类方式2:==公网地址(万维网使用)==和==私有地址(局域网使用)==。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用 特点:不易记忆 ==端口号==：标识正在计算机上运行的进程(程序) ==不同的进程有不同的端口号== 被规定为一个 16 位的整数 0~65535 端口分类: 公认端口:0~1023。被预先定义的服务通信占用(如:HTTP占用端口 80，FTP占用端口21，Telnet占用端口23) 注册端口:1024~49151。分配给用户进程或应用程序。(如:Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等) 动态/私有端口:49152~65535 ==端口号与IP地址的组合得出一个网络套接字：Socket。== InetAddress类 Internet上的主机有两种方式表示地址: 域名(hostName): www.atguigu.com P 地址(hostAddress): 202.108.35.210 123456789101112public class InternetAddressTest&#123; public static void main(String[] args) &#123; try &#123; InetAddress address = InetAddress.getByName(&quot;www.atguigu.com&quot;); System.out.println(address); // www.atguigu.com/58.215.145.106 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; InetAddress类主要表示IP地址，两个子类:Inet4Address、Inet6Address InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: www.atguigu.com 和 202.108.35.210 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS) 负责将域名转化成IP地址，这样才能和主机建立连接。———==域名解析== InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) InetAddress提供了如下几个常用的方法 public String getHostAddress(): 返回 IP 地址字符串(以文本表现形式) public String getHostName(): 获取此 IP 地址的主机名 public boolean isReachable(int timeout): 测试是否可以达到该地址 ==通信要素2：网络协议== 网络通信协议 ​ 计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代 码结构、传输控制步骤、出错控制等制定标准。 问题:网络协议太复杂 ​ 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩，解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢? 通信协议分层的思想 ​ 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。 TCP/IP协议簇 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol) ==TCP/IP 以其两个主要协议==：==传输控制协议(TCP)==和==网络互联协议(IP)==而得 名，实际上是一组协议，包括多个具有不同功能且互为关联的协议 ==IP(Internet Protocol)协议==是网络层的主要协议，支持网间互连的数据通信 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理链路层==、==IP层==、==传输层==和==应用层==。 TCP 和 UDP TCP协议: 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用==“三次握手”==方式，点对点通信，==是可靠的== TCP协议进行通信的两个应用进程:客户端、服务端。 在连接中可==进行大数据量的传输== 传输完毕，==需释放已建立的连接，效率低== UDP协议: 将数据、源、目的封装成数据包，==不需要建立连接== 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的  可以广播发送 发送数据结束时==无需释放资源，开销小，速度快== Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。 ==网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字== 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。  一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类: 流套接字(stream socket):使用TCP提供可依赖的字节流服务 数据报套接字(datagram socket):使用UDP提供“尽力而为”的数据报服务 TCP网络编程基于Socket的TCP编程 Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模 型如图所示 ==客户端Socket的工作过程包含以下四个基本的步骤:== 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到 Socket 的输入/出流:：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输 按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 (但不能读取自己放入线路的信息)，通过输出流将信息写入线程。 关闭 Socket:：断开客户端到服务器的连接，释放线路 ==服务器程序的工作过程包含以下四个基本的步骤:== 调用 ServerSocket(int port) :创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept():监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。 调用 该Socket类对象的 getOutputStream() 和 getInputStream ():获取输出 流和输入流，开始网络数据的发送和接收。 关闭ServerSocket和Socket对象:客户端访问结束，关闭通信套接字 客户端创建Socket对象 客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是: Socket(String host,int port)throws UnknownHostException,IOException:向服务器(域名是 host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。 Socket(InetAddress address,int port)throws IOException:根据InetAddress对象所表示的 IP地址以及端口号port发起连接。 客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求 服务器建立 ServerSocket 对象 erverSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。 所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象 例题1：客户端发送内容给服务端，服务端将内容打印到控制台上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package lesson1;import org.junit.jupiter.api.Test;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * @author Justry * @Description 实现TCP的网络编程：客户端发送信息给服务器，服务端将数据显示在控制台上 * @date 2020-11-30 1:38 下午 */public class TCPTest1 &#123; //客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; InetAddress localHost = InetAddress.getLocalHost(); socket = new Socket(localHost, 8899); os = socket.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //服务端 @Test public void server() &#123; ServerSocket serverSocket = null; InputStream is = null; ByteArrayOutputStream baos = null; Socket socket = null; try &#123; serverSocket = new ServerSocket(8899); socket = serverSocket.accept(); is = socket.getInputStream(); baos = new ByteArrayOutputStream(); byte[] bytes = new byte[20]; int len; while ((len = is.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); &#125; System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (serverSocket != null) &#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 例题2：客户端发送文件给服务端，服务端将文件保存在本地例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给 客户端。并关闭相应的连接。 练习1：服务端读取图片并发送给客户端，客户端保存图片到本地练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端客户端—服务端 客户端: 自定义 浏览器 服务端: 自定义 Tomcat服务器 UDP网络编程 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，==系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达==。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。 ==UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样==。 常用方法 UDP网络通信 流程 DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送、接收方法 5. 关闭Socket 发送端与接收端是两个独立的运行程序 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package lesson1;import org.junit.jupiter.api.Test;import java.io.IOException;import java.net.*;/** * @author Justry * @Description * @date 2020-11-30 2:46 下午 */public class UDPTest &#123; @Test public void sender() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress localHost = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, localHost, 9090); socket.send(packet); socket.close(); &#125; @Test public void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] bytes = new byte[100]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); socket.receive(packet); System.out.println(new String(packet.getData(), 0, packet.getLength())); socket.close(); &#125;&#125; URL编程URL类 URL(Uniform Resource Locator):统一资源定位符，它表示 Internet 上某一 资源的地址 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate 这个资源 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 URL的基本结构由5部分组成: ==&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表== 例如: http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123 #片段名:即锚点，例如看小说，直接定位到章节 参数列表格式:参数名=参数值&amp;参数名=参数值…. 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象: URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。 一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的 方法来获取这些属性: 针对HTTP协议的URLConnection类 ==URL的方法 openStream():能从网络上读取数据== 若希望输出数据，例如向服务器端的 CGI (公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口)程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。 URLConnection:表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. URL netchinaren = new URL (“http://www.atguigu.com/index.shtml&quot;); URLConnectonn u = netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 ==URI、URL和URN的区别==12URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 ==总结== 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 ==客户端-服务器==是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。==端口号== 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。==套接字==用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。 Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段:主机名(String) 和 IP 地址(int)。 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端-服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。 类 URL 和 URLConnection 提供了最 高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十三章 IO流","slug":"第十三章 IO流","date":"2020-11-28T12:25:50.563Z","updated":"2020-12-01T01:41:43.921Z","comments":true,"path":"undefined/4554.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4554.html","excerpt":"","text":"==重点掌握==：节点流、缓冲流、转换流、对象流File类的使用概念 File类的一个对象，==代表一个文件或一个文件目录==（俗称：文件夹） java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是==Java程序中的一个File对象，可能没有一个真实存在的文件或目录== File对象可以作为参数传递给流的构造器 ==File类不涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流== 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点“ 路径分隔符 路径中的每级目录之间用一个路径分隔符隔开。 ==路径分隔符和系统有关==： ①windows和DOS系统默认使用“\\”来表示 ②UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用，为了解决这个隐患，File类提供了一个常量： ==public static final String separator。根据操作系统，动态的提供分隔符== 内存 常用构造器 ==public File(String pathname)==：以pathname为路径创建对象(绝对路径或相对路径)，==相对路径默认当前路径为系统属性user.dir==。 IDEA中： 如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下； 如果使用main()测试，相对路径即为当前的Project下。 Eclipse中：不管是单元测试方法还是main()测试，相对路径都是当前的Project下。 ==public File(String parent,String child)==：以parent为父路径，child为子路径创建File对象。 ==public File(File parent,String child)==：根据一个父File对象和子文件路径创建File对象。 12345678910111213141516171819// 构造器的使用 @Test public void test1()&#123; // 构造器1： File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;D:\\\\workspace_idea1\\\\JavaSenior&quot;); System.out.println(file1); System.out.println(file2); // 构造器2： File file3 = new File(&quot;D:\\\\workspace_idea1&quot;, &quot;JavaSenior&quot;); System.out.println(file1); // 构造器3： File file4 = new File(file3, &quot;Hello.txt&quot;); System.out.println(file4); &#125; 常用方法 File类的获取功能： public String getAbsolutePath()：获取绝对路径 public String getPath()：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度 public long lastModified() ：获取最后一次的修改时间，毫秒值 1234567891011121314@Test public void test2() &#123; File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;\\\\Users\\\\i-mamba\\\\Desktop\\\\IO\\\\hi.txt&quot;); System.out.println(file1.getAbsoluteFile()); // /Users/i-mamba/程序员技能学习/Java/Java基础入门/code/IDEA-workspace/JavaSenior/day08/Hello.txt System.out.println(file1.getPath()); // Hello.txt System.out.println(file1.getName()); // Hello.txt System.out.println(file1.getParent()); // null System.out.println(file1.length()); // 12 System.out.println(file1.lastModified()); // 1606614159235 System.out.println(new Date(file1.lastModified())); // Sun Nov 29 09:42:39 CST 2020 &#125; 下面两方法适用于文件目录： public String[] list()：获取指定目录下的所有文件或者文件目录的==名称==数组 public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File路径数组 File类的重命名功能 public boolean renameTo(File dest)：把文件重命名为指定的文件路径 比如file1.renameTo(file2)，要保证返回true，==需要file1在硬盘中存在且file2在硬盘中不存在==。修改可包括路径和文件内容。 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile()：判断是否是文件 public boolean exists()：判断是否存在 public boolean canRead()：判断是否可读 public boolean canWrite()：判断是否可写 public boolean isHidden()：判断是否隐藏 1234567891011@Test public void test4() &#123; File file = new File(&quot;/Users/i-mamba/程序员技能学习&quot;); System.out.println(file.isDirectory()); // true System.out.println(file.isFile()); // false System.out.println(file.exists()); // true System.out.println(file.canRead()); // true System.out.println(file.canWrite()); // true System.out.println(file.isHidden()); // false &#125; File类的创建功能 public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建——&gt; 创建多层文件目录 ==注意事项==：如果你创建文件或者文件目录没有写盘符路径，那么默认在项目路径下。 File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项： ==Java中的删除不走回收站==； ==要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录== 练习题12345671. 利用File构造器，new 一个文件目录file。 * 在其中创建多个文件和目录 * 编写方法，实现删除file中指定文件的操作2. 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称。3. 遍历指定目录所有文件名称，包括子文件目录中的文件。 * 拓展1：并计算指定目录占用空间的大小 * 拓展2：删除指定文件目录及其下的所有文件 IO流原理及流的分类Java IO原理 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 ==Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行的== java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 输入输出：进入内存即为输入(Input)，出内存即为输出(Output) 流的分类 按操作==数据单位==不同分为：==字节流(8 bit)==，==字符流(16 bit)==。 按数据流的==流向==不同分为：==输入流==，==输出流==。 按流的==角色==的不同分为：==节点流==，==处理流==。 ==(抽象基类)== 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java的IO流共涉及40多个类，实际上非常规则，都是从者4个类派生的，==由这4个类派生出来的子类名称都是以其父类名作为子类名后缀== IO流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 ==抽象基类== InputStream OutputStream Reader Writer ==访问文件== FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter ==缓冲流== BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 节点流和处理流 ==节点流==：直接从数据源或目的地读写数据 ==处理流==：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能 InputStream &amp; Reader ==InputStream和Reader是所有输入流的基类==。 InputStream（典型实现：FileInputStream） int read() int read(byte[] b) int read(byte[] b,int off,int len) Reader（典型实现：FileReader） int read() int read(byte[] b) int read(byte[] b,int off,int len) 程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader InputStream int read()：从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。 int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 Reader int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1。 int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 OutputStream &amp; Writer OutputStream 和 Writer 也非常相似： void write(int b/int c); void write(byte[] b/char[] cbuf); void write(byte[] b/char[] buff, int off, int len); void flush(); void close(); 需要先刷新，再关闭此流 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数 void write(String str); void write(String str, int off, int len); FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。 OutputStream void write(int b)：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b)：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 void write(byte[] b,int off,int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 Writer void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf)：写入字符数组。 void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符。 void write(String str)：写入字符串。 void write(String str,int off,int len)：写入字符串的某一部分。 void flush()：刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 节点流(或文件流)通用步骤：123456* 实例化File类对象，指明要操作的文件* 提供具体的流* 数据的操作* 关闭资源 // 注意：异常处理 字符流FileReader 步骤： File类的实例化 FileReader流的实例化 读入的操作 资源关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546472. 说明点：* read()的理解：返回读入的一个字符，如果到大文件末尾，返回-1。* 异常处理：为了保证资源一定可以执行关闭操作。需要使用try-catch-finally处理。* 读入文件一定要存在，否则就会报FileNotFoundException3. 基本操作&#96;&#96;&#96;java@Test public void FileReaderTest() &#123; FileReader fileReader &#x3D; null; try &#123; &#x2F;&#x2F;1.实例化File类的对象，指明要操作的文件 File file &#x3D; new File(&quot;hello.txt&quot;); &#x2F;&#x2F;2.提供具体的流 fileReader &#x3D; new FileReader(file); &#x2F;&#x2F;3.数据的读入 &#x2F;&#x2F;read()：返回读入的一个字符。如果达到文件末尾，返回-1 &#x2F;&#x2F;方式一：&#x2F;&#x2F; int data &#x3D; fileReader.read();&#x2F;&#x2F; while (data !&#x3D; -1) &#123;&#x2F;&#x2F; System.out.print((char) data);&#x2F;&#x2F; &#x2F;&#x2F;读取下一个字符&#x2F;&#x2F; data &#x3D; fileReader.read();&#x2F;&#x2F; &#125; &#x2F;&#x2F;方式二：语法上针对于方式一的修改 int data; while ((data &#x3D; fileReader.read()) !&#x3D; -1) &#123; System.out.print((char) data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;4.流的关闭操作 try &#123; if (fileReader !&#x3D; null) &#123; fileReader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 对read()操作升级：使用read()的重载方法 1234567891011121314151617181920212223242526272829@Test public void FileReaderTest2() &#123; FileReader fileReader = null; try &#123; //1.File类的实例化 File file = new File(&quot;Hello.txt&quot;); //2.FileReader流的实例化 fileReader = new FileReader(file); //3.读入的操作 char[] cbuf = new char[5]; int len; while ((len = fileReader.read(cbuf)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileWriter 步骤： 创建File类的对象：指明读入和写出的文件 创建输入流和输出流的对象 数据的读入和写出操作 关闭流资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152532. &#x3D;&#x3D;说明点&#x3D;&#x3D; * 从内存中写出数据到硬盘的文件里 * 输出操作，对应的File可以不存在。 * 如果不存在，在输出过程中，会自动创建此文件 * 如果存在： * 使用的流构造器是: FileWriter(file,false) &#x2F; FileWriter(file)，对原有文件覆盖 * 使用的流构造器是: FileWriter(file,true)，不会对原有文件覆盖，而是在原有文件的基础上3. 基本操作&#96;&#96;&#96;java@Test public void FileWriterTest1() &#123; FileReader fileReader &#x3D; null; FileWriter fileWriter &#x3D; null; try &#123; &#x2F;&#x2F;1.创建File类的对象：指明读入和写出的文件 File file &#x3D; new File(&quot;Hello.txt&quot;); File file1 &#x3D; new File(&quot;Hello2.txt&quot;); &#x2F;&#x2F;2.创建输入流和输出流的对象 fileReader &#x3D; new FileReader(file); fileWriter &#x3D; new FileWriter(file1); &#x2F;&#x2F;3.数据的读入和写出操作 char[] cbuf &#x3D; new char[5]; int len; &#x2F;&#x2F; 记录每次读入到cbuf数组中的字符的个数 while ((len &#x3D; fileReader.read(cbuf)) !&#x3D; -1) &#123; &#x2F;&#x2F;每次写出len个字符 fileWriter.write(cbuf, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;4.关闭流资源 try &#123; if (fileWriter !&#x3D; null) &#123; fileWriter.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileReader !&#x3D; null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字节流FileInputStream ==注意点：使用字节流处理文本文件，可能出现乱码== 说明： 对于文本文件（.txt，.java，.c，.cpp），使用字符流处理 对于非文本文件，使用字节流处理 基本操作 1234567891011121314151617181920212223242526272829@Test public void fISStreamTest1() &#123; FileInputStream inputStream = null; try &#123; //造文件 File file = new File(&quot;cat.jpeg&quot;); //造流 inputStream = new FileInputStream(file); //读数据 int len; // 记录每次读取的字节的个数 byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(bytes[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 关闭流资源 if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 复制图片 123456789101112131415161718192021222324252627282930313233343536@Test public void fISStreamTest2() &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat2.jpeg&quot;); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通用操作：指定路径下的文件复制操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Test public void copyFile(String srcPath,String destPath) &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(srcPath); File file1 = new File(destPath); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[1024]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testCopyFile()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;文件路径&quot;; String destPath = &quot;复制路径&quot;; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;整个复制操作花费的时间为：&quot; + (end - start));//13031 //可以复制文本文件 &#125; &#125; 缓冲流 处理流的一种，“套接”在已有的流的基础上 缓冲流涉及到的类 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter ==作用==：提供流的读取、写入的速度 ==原因==：内部提供了一个缓冲区。默认情况下是8kb 说明： 先关闭外层流，再关闭内层流 ==关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略== 非文本文件的复制 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Test public void BfStreamTest1() &#123; BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try &#123; //1.造文件 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat3.jpeg&quot;); //2.造流 //2.1造节点流 FileInputStream inputStream = new FileInputStream(file); FileOutputStream outputStream = new FileOutputStream(file1); //2.2造处理流 bufferedInputStream = new BufferedInputStream(inputStream); bufferedOutputStream = new BufferedOutputStream(outputStream); //3.复制：数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = bufferedInputStream.read(bytes)) != -1) &#123; bufferedOutputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (bufferedOutputStream != null) bufferedOutputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if (bufferedInputStream != null) bufferedInputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 文本文件的复制，略，基本雷同 练习题 图片的加密 1234567891011121314151617181920212223242526272829303132333435363738394041public class PicTest &#123; /** * 图片的加密操作 */ @Test public void testEncrypt()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;cat.jpg&quot;); fos = new FileOutputStream(&quot;cat2.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; //核心 for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 图片的解密 对加密的文件做同样的异或操作 123456789101112131415161718192021222324252627282930313233343536373839/** * 图片的解密操作 */ @Test public void testDecode()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;加密后的玛雅.jpg&quot;); fos = new FileOutputStream(&quot;解密后的玛雅.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 获取文本上每个字符出现的次数 1//提示：遍历文本每一个字符，字符及出现次数保存在Map中，将Map中数据写入文件。 转换流 转换流提供了在字节流和字符流之间的转换 ==Java API提供了两个转换流==: ==InputStreamReader==：将InputStream转换为Reader ==OutputStreamWriter==；将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来==处理文件乱码==问题。实现==编码==和== 解码==的功能 InputStreamReader ==实现将字节的输入流按指定字符集转换为字符的输入流== 需要和InputStream“套接” 构造器 public InputStreamReader(InputStream in) public InputSreamReader(InputStream in,String charsetName) OutputStreamWriter ==实现将字符的输出流按指定字符集转换为字节的输出流== 需要和OutputStream“套接” 构造器 public OutputStreamWriter(OutputStream out) public OutputSreamWriter(OutputStream out,String charsetName) 字符编码 编码:字符串字节数组 解码:字节数组字符串 转换流的编码应用 可以将字符按指定编码格式存储 可以对文本数据按指定编码格式来解读 指定编码表的动作由构造器完成 标准输入、输出流 ==System.in==和==System.out==分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是==InputStream==，直接以流的形式读取了 System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向:通过System类的setIn()，setOut()方法对默认设备进行改变 练习 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序 1234567891011121314151617181920212223242526272829303132public class OtherStreamTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) &#123; System.out.println(&quot;请输入字符串：&quot;); String data = br.readLine(); if (data.equalsIgnoreCase(&quot;e&quot;) || data.equalsIgnoreCase(&quot;exit&quot;)) &#123; System.out.println(&quot;程序结束！&quot;); break; &#125; String upperCase = data.toUpperCase(); System.out.println(upperCase); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印流 ==实现将基本数据类型的数据格式转化为字符串输出==，指定输入/输出的位置 打印流：==PrintStream==和==PrintWriter== 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 例子 12345678910111213PrintStream ps = null; try &#123;FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true);if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件System.setOut(ps); &#125;for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i);if (i % 50 == 0) &#123; // 每50个数据一行System.out.println(); // 换行 &#125;&#125;&#125; catch (FileNotFoundException e) &#123;e.printStackTrace(); &#125; finally &#123;if (ps != null) &#123; ps.close();&#125; &#125; 数据流 作用：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类:(==用于读取和写出基本数据类型、String类的数据==) ==DataInputStream== 和 ==DataOutputStream== 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream中的方法 boolean readBoolean() char readChar() double readDouble() long readLong() String readUTF() byte readByte() float readFloat() short readShort() int readInt() void readFully(byte[] b) DataOutputStream中的方法 ==将上述的方法的read改为相应的write即可== 练习 将内存中的字符串、基本数据类型变量写出到文件中 1234567891011DataOutputStream dos = null;try &#123; // 创建连接到指定文件的数据输出流对象dos = new DataOutputStream(new FileOutputStream(&quot;destData.dat&quot;)); dos.writeUTF(&quot;我爱北京天安门&quot;); // 写UTF字符串 dos.writeBoolean(false); // 写入布尔值dos.writeLong(1234567890L); // 写入长整数 System.out.println(&quot;写文件成功!&quot;);&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流对象try &#123;if (dos != null) &#123;// 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close();&#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125; 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中 12345678910111213DataInputStream dis = null; try &#123;dis = new DataInputStream(new FileInputStream(&quot;destData.dat&quot;)); String info = dis.readUTF();boolean flag = dis.readBoolean();long time = dis.readLong();System.out.println(info); System.out.println(flag); System.out.println(time);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123;if (dis != null) &#123;try &#123; dis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125;&#125; ==注意==：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ 对象流基础概念 用于==存储==和==读取==基本数据类型数据或对象的处理流。它的强大之处就是==可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来== ==ObjectInputStream==和==OjbectOutputSteam== ==序列化==：用ObjectOutputStream类==保存==基本类型数据或对象的机制 ==反序列化==：用ObjectInputStream类==读取==基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream==不能序列化static和transient==修饰的成员变量 以下面的Person类为例 123456789101112public class Person implements Serializable &#123; public static final long serialVersionUID = 44353533453L; //将变量用static 和 transient修饰 private static String name; private transient int age;略 //此时的反序列化结果我爱北京天安门Person&#123;name=&#x27;null&#x27;, age=0&#125; //显然无法序列化这两个变量 对象的序列化 ==对象序列化机制==允许把内存中的Java对象转换成平台无关的==二进制流==，从 而允许把这种二进制流持久地==保存在磁盘上==，或通过网络将这种二进制流==传输到另一个网络节点==。//==当其它程序获取了这种二进制流，就可以恢复成原来的Java对象== ==序列化的好处==：在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI(Remote Method Invoke – 远程方法调用)过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此==序列化机制是 JavaEE 平台的基础== ==如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的==，==为了让某个类是可序列化的，该类必须实现如下两个接口之一==。 否则，会抛出NotSerializableException异常 $\\color{red}{Serializable}$ Externalizable ==凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量==: $\\color{red}{private static final long serialVersionUID}$; ==serialVersionUID==用来表明类的不同版本间的兼容性。简言之，其目的是==以序列化对象 进行版本控制，有关各版本反序列化时是否兼容==。 ==如果类没有显示定义这个静态常量==，它的值是==Java运行时环境根据类的内部细节自动生成==的。 若类的实例变量做了修改，serialVersionUID 可能发生变化。故==建议， 显式声明== ==Java的序列化机制==是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，==JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较==，如果相同就认为是==一致==的，==可以进行反序列化==，==否则就会出现序列化版本不一致的异 常。(InvalidCastException)== 使用对象流序列化对象序列化实现 ==若某个类实现了 Serializable 接口，该类的对象就是可序列化的:== 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 ==注意写出一次，操作flush()一次== 1234567891011121314151617181920//序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现@Testpublic void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反序列化实现 步骤 创建一个 ObjectInputStream 调用 readObject() 方法读取流中的对象 1234567891011121314151617181920212223//反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现@Testpublic void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 自定义类实现序列化 ==强调==：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是==可序列化的==，否则拥有该类型的 Field 的类也不能序列化 ==以Person类为例== 需要==实现接口==：Serializable 当前类==提供一个全局常量==：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化de 。(默认情况下，基本数据类型可序列化) package lesson; import org.junit.jupiter.api.Test; import java.io.*; /** * @author Justry * @Description 对象流的使用 * @date 2020-11-30 9:35 上午 */ public class ObiectIOStreamTest &#123; //序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现 @Test public void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); oos.writeObject(new Person(&quot;如花&quot;, 60)); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现 @Test public void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); System.out.println(str); // 我爱北京天安门 System.out.println(p); // Person&#123;name=&#39;如花&#39;, age=60&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 123456789#### Q1. 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗?&#96;&#96;&#96;java实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。&#x2F;&#x2F;这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活 随机存取文件流RandomAccessFile 类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写，即可以作为输入/出流 实现图片的复制 123456789101112131415161718192021222324@Test public void test1() throws IOException &#123; RandomAccessFile r1 = null; RandomAccessFile r2 = null; try &#123; r1 = new RandomAccessFile(new File(&quot;cat.jpeg&quot;), &quot;r&quot;); r2 = new RandomAccessFile(new File(&quot;cat2.jpeg&quot;), &quot;rw&quot;); byte[] buffer = new byte[1024]; int len; while ((len = r1.read(buffer)) != -1) &#123; r2.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (r2 != null) r2.close(); if (r1 != null) r1.close(); &#125; &#125; RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 ==RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置== long getFilePointer():获取文件记录指针的当前位置 void seek(long pos):将文件记录指针定位到 pos 位置 1234567891011@Testpublic void test2() throws IOException &#123; RandomAccessFile rw = new RandomAccessFile(&quot;Hello.txt&quot;, &quot;rw&quot;); rw.seek(&quot;Hello.txt&quot;.length()); // 将指针指到末尾，追加内容 rw.write(&quot;xyz&quot;.getBytes()); rw.close();&#125; 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式 r；以只读方式打开 rw；打开以便读取和写入 rwd；打开以便读取和写入；同步文件内容的更新 rws；打开以便读取和写入；同步文件内容和元数据的更新 ==如果模式为只读r==。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 ==如果模式为rw读写==，如果文件不 存在则会去创建文件；如果存在则不会创建，写到文件时会对原有内容进行部分覆盖 应用：多线程断点下载 流的基本应用小节 流是用来处理数据的。 处理数据时，一定要先明确数据源，与数据目的地  数据源可以是文件，可以是键盘。 数据目的地可以是文件、显示器或者其他设备。 而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等 NIO.2中Path、 Paths、Files类的使用 NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。==NIO将以更加高效的方式进行文件的读写操作==。 Java API中提供了两套NIO：==一套是针对标准输入输出NIO==，==另一套就是网 络编程NIO== 略，以后再学","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十一章 集合","slug":"第十一章 集合","date":"2020-11-27T01:12:32.106Z","updated":"2020-12-01T01:41:40.929Z","comments":true,"path":"undefined/f650.html","link":"","permalink":"https://asteroidcs.github.io/undefined/f650.html","excerpt":"","text":"Java集合框架集合与数组存储数据概述集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 数组存储的弊端 一旦初始化以后，其长度就不可以修改了，这就使得不便于扩展 数组中提供的方法非常有限，对于添加、删除、插入数据等操作不便，且效率不高 获取数组中实际元素的个数的需求，数组中没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。故无法满足对于无序、不可重复的需求 集合存储的优点集合的出现就是为了==解决数组存储数据方面的弊端== 集合框架结构：Java集合可分为==Collection==和==Map==两种体系 Collection接口：单列集合，用来存储一个一个的对象 List接口：==存储有序的、可重复的数据 ——&gt; “动态”数组== Set接口：==存储无序的、不可重复的数据== Collection接口继承树 Map接口：双列数据，==保存具有映射关系的“key-value”对的集合== Map接口继承树 Collection接口方法Collection接口 Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合——&gt; ==继承性的特点：可以调用父类的方法== ==JDK不提供Collection接口的任何直接实现，而是提供更具体的子接口(Set、List)实现== ——&gt; 意味着只能构造其子接口的对象，即ArrayList、LinkedList、Vector/LinkedHashSet、TreeSet等 在==Java5==之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；==从JDK 5.0增加了泛型以后==，Java集合可以记住容器中对象的数据类型。 $\\color{red}{注意：向Collection接口的实现类对象中添加数据obj时，要求obj所在类重写equals()方法}$ Collection接口常用方法 增加数据 add(Object e): 将元素e添加到集合coll中 addAll(Collection coll): 将coll集合中的元素添加到当前的集合中 123456789101112131415161718192021222324252627282930313233343536public class CollectionTest &#123; @Test public void addTest()&#123; //由于JDK不提供Collection接口的任何直接实现，所以这种写法是错误的 ---&gt; 只能用其子接口// Collection collection = new Collection(); //采用子接口实现 Collection collection1 = new ArrayList(); Collection collection2 = new ArrayList(); //add collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(new String(&quot;Tom&quot;)); System.out.println(collection1); // [123, 123, false, Tom] //addAll collection2.add(4324); collection2.add(&quot;555&quot;); collection2.add(&quot;123&quot;); collection2.add(new String(&quot;Jack&quot;)); collection2.add(true); System.out.println(collection2); // [4324, 555, 123, Jack, true] //将集合1加入集合2中 collection2.addAll(collection1); System.out.println(collection2); // [4324, 555, 123, Jack, true, 123, 123, false, Tom] &#125;&#125; ==从代码输出的结果可以看出：这里正好体现了List接口存放有序、可重复数据的特点== 删除数据 clear()：==清空==集合元素 remove(Object obj)：从当前集合中移除指定的obj元素 removeAll(Collection coll)：移除当前集合与另外的coll集合的==交集==中的元素 12345678910111213141516171819202122232425262728public void DeleteTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false, Tom] //remove collection1.remove(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false] // clear collection1.clear(); System.out.println(collection1); // [] //removeAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(123); collection1.removeAll(collection2); System.out.println(collection1); // [false, Tom] &#125; 查找数据 contains(Object obj)；判断当前集合中是否包含obj containsAll(Collection coll)：判断形参coll中所有元素是否都存在于当前集合中 123456789101112131415161718192021222324252627282930313233public void ContainsTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(&quot;Tom&quot;); //Contains boolean contains = collection1.contains(123); System.out.println(contains); // true boolean contains1 = collection1.contains(3543); System.out.println(contains1); // false /** * 此处调用的是String类中的equals，由于String重写了equals方法， * 故比较的是内容，而非地址，所以返回true， * 若自定义的类没有重写object的equals方法，则返回false */ System.out.println(collection1.contains(&quot;Tom&quot;)); // true //ContainsAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(&quot;Tom&quot;); //集合collection2中的所有元素是否都存在于collection1中 boolean b = collection1.containsAll(collection2); System.out.println(b); // true &#125; 集合的长度 size(): 获取添加的元素个数 其他 isEmpty()：判断当前集合是否为空 retainAll(Collection coll): 交集，将当前集合修改为当前集合与coll的交集 equals(Object obj): 判断当前集合与形参集合的元素是否都相同 hashCode()：返回当前对象的哈希值 toArray()：集合转换成数组 1234567891011121314151617181920212223242526public void toArray()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Object[] array = collection1.toArray(); for (int i = 0; i &lt; array.length; i++) &#123; // 123 123 false Tom System.out.print(array[i] + &quot; &quot;); &#125; // 拓展：数组 ---&gt; 集合 List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] System.out.println(list); List arr = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(arr); // [[I@3ecd23d9] ---&gt; 识别为了一个元素 List arr1 = Arrays.asList(123, 456); System.out.println(arr1); //[123, 456] List arr2 = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(arr2); // [123, 456] &#125; 12// 拓展：数组 ---&gt; 集合 : 调用Arrays类的静态方法asList() List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] iterator(): 返回Iterator接口的实例，用于遍历集合元素 $\\color{red}{在判断时会调用obj对象所在类的equals()方法}$ 集合的默认遍历方法（jdk8新特性）—&gt; ==forEach== 1234567891011@Testpublic void test5()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(343); coll.add(343); coll.forEach(System.out::println);//方法引用&#125; terator迭代器接口 ==Iterator仅用于遍历集合==，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合 12345678910111213public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; &quot;); // 123 123 false Tom &#125;&#125; ==集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前== 1234// 错误写法while (collection1.iterator().hasNext())&#123; // 每次产生一个全新的迭代器对象 System.out.println(collection1.iterator().next()); // 死循环 ---&gt; 不断输出第一个元素&#125; ==使用迭代器遍历集合一般使用的方式以及迭代器执行原理：== remove()方法 内部定义了remove方法，==Iterator可以删除集合的元素==，==区别集合的remove()方法和迭代器的remove()方法== 注意指针的位置，若调用remove()方法时指针位置为空，则报异常IllegalStateException。 1234567891011121314151617public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); if (&quot;Tom&quot;.equals(o))&#123; iterator.remove(); &#125; &#125; System.out.println(collection1); // [123, 123, false] &#125; foreach循环(增强for循环) Java 5.0 提供了foreach循环迭代访问Collection和数组 无需长度、索引 内部仍然调用了迭代器 ——&gt; ==底层：Iterator== 123for(元素类型 局部变量 : 数组/Collection对象)&#123; //对局部变量操作&#125; 123456789101112public void forEach()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); for (Object obj : collection1)&#123; System.out.print(obj + &quot; &quot;); // 123 123 false Tom &#125; &#125; $\\color{red}{注意：增强for循环是将值赋给局部变量，改变的是局部变量，不影响对象中的元素}$ 练习：判断输出结果为何？ 1234567891011public void testExer()&#123; String[] str = new String[5]; for(String myStr : str)&#123; myStr = &quot;atguigu&quot;; System.out.println(myStr); &#125;//5行&quot;atguigu&quot; for(int i = 0;i &lt; str.length;i++)&#123; System.out.println(str[i]); &#125;//5行null &#125; Collection子接口一：List 存储有序的、可重复的数据。==&gt; “动态”数组，替换原有的数组 —&gt; 避免了角标越界 理解：添加数据时，当原数组的存储空间不够时，会重新生成一个容量较大的新数组，将原数组中的元素放进新数组中，并添加新的数据 ———&gt; 占内存 List接口方法：除了从Collection集合继承的方法外，==List 集合里添加了一些根据索引来操作集合元素的方法== 增加数据 void add(int index,Object ele)：在index位置插入ele元素； boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来； 1234567891011121314151617181920212223242526272829@Test public void addTest()&#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //add //数组的第二个位置插入数据 list.add(2, 657); System.out.println(list); // [123, Tom, 657, false, 342] //addAll //将list1插入list的索引2位置 List list1 = new ArrayList(); list1.add(7868); list1.add(&quot;Jack&quot;); list1.add(true); list.addAll(2, list1); System.out.println(list); &#125; 删除数据 Object remove(int index)：移除指定index位置的元素，==并返回此元素== Object remove(Object obj)：移除指定的元素(若有多个，则只移除首位的元素)，==并返回true/false== 123456789101112131415161718192021222324@Test public void removeTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //remove(int index) Object o = list.remove(0); System.out.println(o); // 123 //remove(Object obj) boolean b = list.remove(&quot;Tom&quot;); System.out.println(b); // true boolean b1 = list.remove(&quot;Jack&quot;); System.out.println(b1); // false &#125; 查找 Object get(int index)：获取指定index位置的元素； int indexOf(Object obj)：返回obj在集合中首次出现的位置； int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置； List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合。 1234567891011121314151617181920212223242526272829@Test public void getTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.add(342); list.add(&quot;Tom&quot;); System.out.println(list); // [123, Tom, Jack, 342, Tom] // Object get(int index) Object o = list.get(2); System.out.println(o); // Jack // int indexOf(Object obj) int i = list.indexOf(&quot;Tom&quot;); System.out.println(i); // 1 // int lastIndexOf(Object obj) int i1 = list.lastIndexOf(&quot;Tom&quot;); System.out.println(i1); // 4 // List subList(int fromIndex, int toIndex) List list1 = list.subList(1, 4); System.out.println(list1); // [Tom, Jack, 342] &#125; 修改 Object set(int index, Object ele)：设置指定index位置的元素为ele； 123456789101112@Test public void setTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.set(1, 5464); System.out.println(list); // [123, 5464, Jack] &#125; ArrayList​ ==作为List接口的主要实现类；由于是线程不安全的，故效率高；底层使用Object[] elementData存储。== ==源码分析==： 123456789101112//jdk7的情况下：ArrayList list = new ArrayList();//底层创建而来长度为10的Object[]数组elementData；list.add(123);//elementData[0] = new Integer(123);//...list.add(12);//如果此次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)//jdk8中ArrayList的变化：ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组。list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中。//后续的添加扩容操作与jdk7无异 ==小结==：jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8则类似于懒汉式，延迟了数组的创建，节省内存。 【面试题】 1234567891011121314151617@Testpublic void testListRemove()&#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list); // [1]&#125;private static void updateList(List list)&#123; /** * 考点：确定调用哪个remove， 两个remove()方法中index优先权大于Object，删除索引为2的元素 */ list.remove(2);//两个remove()方法中index优先权大于Object，删除索引为2的元素 list.remove(new Integer(2));//删除值为2的元素&#125; LinkedList 对于==频繁的插入和删除==操作，使用此类效率比ArrayList高；底层使用双向链表存储。 1234567891011121314JavaLinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node除了保存数据，还定义了两个变量： prev：记录前一个元素的位置 next：记录下一个元素的位置 新增方法： 123456void addFirst(Object obj)void addLast(Object obj)Object getFirst()Object getLast()Object removeFirst()Object removeLast() Vector 作为List接口的古老实现类(1.0)；线程安全的，效率低；底层使用Object[] elementData存储。 源码分析： jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍。 新增方法： 12345void addElement(Object obj)void insertElementAt(Object obj,int index)void setElementAt(Object obj,int index)void removeElement(Object obj)void removeAllElements() ==面试题==：请问ArrayList/LinkedList/Vector的异同？谈谈你的理解。ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? ArrayList和LinkedList的异同 12二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 1Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。 Collection子接口二：Set Set接口是Collection的子接口，==set接口没有提供额外的方法==。都是Collection中声明过的方法。 ==存储无序的、不可重复的数据== ==&gt; 高中数学中的“集合” Set判断两个对象是否相同不是使用 == 运算符，而是根据equals()方法 HashSet 作为Set接口的主要实现类；==是线程不安全的，可以存储null值==。 以HashSet为例说明：Set存储无序的、不可重复的数据: ==无序性==：==不等于随机性==。存储的数据在底层数组中并非按照数组索引的顺序添加，而是==根据数据的哈希值决定的== ==不可重复性==：保证添加的元素==按照equals()判断==时，不能返回true。即：相同的元素只能添加一个。—&gt; ==因此自定义类需要重写equals( )方法和hashCode( )方法，先比较hash值，再用equals( )比较== ==要求==： 向Set中添加元素所在类，其所在类一定要==重写hashCode()和equals()==； ==重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码== —&gt; 哈希值 ==重写两个方法的小技巧==：对象中用作equals()方法比较的Field，都应该用来计算hashCode值 1234567891011121314151617@Test public void addTest()&#123; HashSet set = new HashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [657, Tom, 123] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [AA, 657, Tom, 123, Jack] ---&gt; 无序性 &#125; ==添加元素的过程：以HashSet为例== 向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值 ==此哈希值接着通过某种算法，计算出在HashSet底层数组中的存放位置（即为：索引位置）== 判断数组此位置上是否已有元素： 没有其他元素==&gt;添加成功。==&gt;情况1 有其他元素b(或以链表形式存在的多个元素)，则比较元素a与b的哈希值: 哈希值不同==&gt;添加成功。==&gt;情况2 哈希值相同，进而调用元素a所在类的equals()方法： 返回false==&gt;添加成功。==&gt;情况3 返回true，则添加失败。 对于添加成功的情况2和3而言：元素a与已经存在指定索性位置上的数据以链表的方式存储。 jdk7：元素a放到数组中，指向原来的元素。（头插） jdk8：原来的元素在数组中指向a元素。（尾插） 总结：七上八下 ==HashSet底层：数组+链表的结构== ==问题==：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 1234选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）31只占用5bits,相乘造成数据溢出的概率较小。31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) LinkedHashSet 作为HashSet的子类；遍历其内部数据时，==可以按照添加顺序遍历==。==对于频繁的遍历操作，LinkedHashSet效率高于HashSet== LinkedHashSet ==根据元素的 hashCode 值来决定元素的存储位置==，但它同时==使用双向链表维护元素的次序==，这使得元素看起来是以插入顺序保存的 123456789101112131415161718@Test public void LinkedHashSet()&#123; LinkedHashSet set = new LinkedHashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [123, Tom, 657] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [123, Tom, 657, Jack, AA] ---&gt; 按照添加顺序遍历 &#125; TreeSet ==以按照添加对象的指定属性进行排序== 向TreeSet中添加的数据。要求是相同类的对象 两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）。默认情况下，TreeSet采用自然排序 ==自然排序中==，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals() ==定制排序中==，比较两个对象是否相同的标准为：compare()返回0，不再是equals() 新增方法 Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) ==TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快== User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class User implements Comparable &#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; //自然排序：默认从小到大排序 @Override public int compareTo(Object o) &#123; if (o instanceof User) &#123; User user = (User) o;// return this.name.compareTo(user.name); // 二级排序 int compare = -this.name.compareTo(user.name); // 加了负号，所以按照姓名从大到小排序 if (compare != 0) &#123; return compare; &#125; else &#123; return Integer.compare(this.age, user.age); // 年龄从小到大排列 &#125; &#125; else &#123; throw new RuntimeException(&quot;输入类型不匹配！&quot;); &#125; &#125;&#125; 自然排序实现==（实现Comparable接口）——&gt; 重写compareTo( )方法== 1234567891011121314151617public class UserTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125;User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125; 定制排序实现 构建comparator对象，并重写compare（）方法 将其作为形参传入User类的构造器中 12345678910111213141516171819202122232425262728293031public class UserTest &#123; public static void main(String[] args) &#123; Comparator comparator = new Comparator() &#123; //按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入数据类型不匹配&quot;); &#125; &#125; &#125;; TreeSet set = new TreeSet(comparator); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125; ==非常非常经典的面试题：== 1234567891011121314151617@Test public void test1() &#123; HashSet set = new HashSet(); Person p1 = new Person(1001, &quot;AA&quot;); Person p2 = new Person(1002, &quot;BB&quot;); set.add(p1); // 根据算法算出hash值h1，确定在set中的存储位置 set.add(p2); // 根据算法算出hash值，确定在set中的存储位置 p1.name = &quot;CC&quot;; // 只改变p1的属性值，但p1已存入set，在set中位置不变 set.remove(p1); // 根据此时的p1(属性改变后)计算出的hash值h2≠h1，所以没能删除set中的p1 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;CC&quot;)); // 根据算法算出hash值h2，此位置无元素，添加成功 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;AA&quot;)); // 计算出hash值h1与p1所在位置哈希值相同，调用 // Person中的equals()方法，返回结果为false，此对象以链表的形式存入数组中，添加成功。 System.out.println(set); // [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;] &#125; Map接口 概述： ==双列数据，存储key-value对的数据== ==&gt; 类似于高中的函数，类比其他语言中的==字典== ==Map中的key：无序的，不可重复的==，使用Set存储所有的key。 ==&gt; key所在的类必须要重写equals()和hashCode()==（以HashMap为例） ==Map中的value：无序的，可重复的==，==使用Collection存储所有的value==。 –&gt; ==value所在类要重写equals()== 一个键值对：==key-value构成一个Entry对象==。 ==Map中的Entry：无序的，不可重复的，使用Set存储所有entry==。 ==添加、删除、修改等操作== Object put(Object key,Object value):将制定key-value添加到（或修改）当前map对象中。 void putAll(Map m):将m中所有key-value对存放到当前map中。 Object remove(Object key):移除指定key的key-value对，并返回value。没有相应的key则返回null void clear():清空当前map中的所有数据。与map=null操作不同 ==元素查询的操作== Object get(Object key):获取指定key对应的value。没有相应的key则返回null boolean containsKey(Object key):是否包含指定的key。 boolean containsValue(Object value):是否包含指定的value。 int size():返回map中key-value对的个数。 boolean isEmpty(): 判断当前map是否为空。 boolean equals(Object obj):判断当前map和参数对象是否相等 ==元视图操作的方法== Set keySet():返回所有key构成的Set集合。 Collections values():返回所有value构成的Collection集合。 Set entrySet():返回所有key-value构成的Set集合 ==总结：常用方法== 添加：put(Object key,Object value) 12345678910@Test public void putTest()&#123; HashMap hashMap = new HashMap(); hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; &#125; 删除：remove(Object key) 12345678910111213141516@Test public void removeTest()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; //remove Object remove = hashMap.remove(2); System.out.println(remove); // Tom System.out.println(hashMap); // &#123;tt=546&#125; &#125; 修改：put(Object key,Object value) 12345678910111213141516171819@Test public void put2Test()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; //修改 hashMap.put(2, &quot;Jim&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Jim, 564=Tom, 6=324&#125; &#125;&#125; 查询：get(Object key) 长度：size() 遍历：keySet() / values() / entrySet() 123456789101112131415161718192021@Test public void test1()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; Set set = hashMap.keySet(); Collection values = hashMap.values(); Set set1 = hashMap.entrySet(); System.out.println(set); // [tt, 2, 564, 6] System.out.println(values); // [546, Tom, Tom, 324] System.out.println(set1); // [tt=546, 2=Tom, 564=Tom, 6=324] &#125; HashMap ==作为Map的主要实现类==；线程不安全，效率高；==存储null的key和value== ==底层实现原理：(jdk7)== 12345678HashMap map = new HashMap();//在实例化以后，底层创建了一个长度为16的一维数组Entry[] table。//...可能已经执行过多次put...map.put(key1,value1);//首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值通过某种算法计算后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。---情况1/*如果，此位置上的数据不为空，(意味着此位置上一个或多个数据(以链表形式存在))，比较key1与已经存在的一个或多个数据的哈希值： 如果key1与已经存在的数据的哈希值都不相同，key1-value1添加成功。---情况2 如果key1与已经存在的某个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较： equals()返回false，添加成功。---情况3 equals()返回true，使用value1替换value2值。*/ ==补充==： 情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。 默认扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。 ==jdk8相较于jdk7在底层实现方面的不同== new HashMap()：底层没有创建一个长度为16的数组； jdk8底层的数组是Node[]，而非Entry[]； 首次调用put()时，底层创建长度为16的数组； jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 当某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组长度 &gt; 64 时，此索引位置上的的所有数据改为用红黑树存储。 HashMap的存储结构 ==几个常量值== —&gt; ==底层源码== DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75 threshold：扩容的临界值等于容量x填充因子：16*0.75 = 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64 table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数 threshold：扩容的临界值 = 容量*填充因子 loadFactor：填充因子 ==面试题==：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？ ==面试题==：负载因子的值太小，对HashMap有什么影响？ 1234负载因子的大小决定了HashMap的数据密度。负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 LinkedHashMap 概述 作为HashMap的子类 保证在遍历map元素时，可以按照添加的顺序实现遍历。 原理：在原有的HashMap地层结构基础上，添加了一对指针，指向前一个和后一个元素。 对于频繁的遍历操作，此类执行效率高于HashMap。 底层实现原理：(了解) 1234567//源码：static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after;//能记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 12345678910111213141516@Test public void LinkedHashMapTest()&#123; LinkedHashMap linkedHashMap = new LinkedHashMap(); //put linkedHashMap.put(2, &quot;Tom&quot;); linkedHashMap.put(&quot;tt&quot;, 546); linkedHashMap.put(6, 324); linkedHashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(linkedHashMap); // &#123;2=Tom, tt=546, 6=324, 564=Tom&#125; // 修改 linkedHashMap.put(2, &quot;Jack&quot;); System.out.println(linkedHashMap); // &#123;2=Jack, tt=546, 6=324, 564=Tom&#125; &#125; TreeMap ==保证按照添加的key-value对进行排序，实现遍历。此时考虑key的自然和定制排序==。==底层使用红黑树存储==。 向TreeMap中添加key-value，==要求key必须是由同一个类创建的对象==，因为要按照key进行自然排序、定制排序。 排序类似于之前的TreeSet。 ———&gt; ==同一个treeMap中的key的类型必须一致，意味着只能有仅只有一个类型的数据== ==TreeMap判断两个key相等的标准==：两个key通过compareTo()方法或者compare()方法返回0。———&gt; 因此涉及到了方法的重写 12345678910111213141516171819202122@Test public void TreeMapTest()&#123; TreeMap treeMap = new TreeMap(); treeMap.put(&quot;fsad&quot;, 453); treeMap.put(&quot;2&quot;, &quot;sad&quot;); treeMap.put(&quot;J&quot;, 435); System.out.println(treeMap); // &#123;2=sad, J=435, fsad=453&#125; treeMap.put(&quot;2&quot;, &quot;happy&quot;); System.out.println(treeMap); // &#123;2=happy, J=435, fsad=453&#125; //key的类型不一致，故而抛出异常 /** * java.lang.ClassCastException: class java.lang. * String cannot be cast to class java.lang.Integer (java.lang.String * and java.lang.Integer are in module java.base of loader &#x27;bootstrap&#x27;) */ Object put = treeMap.put(3, 342); System.out.println(put); &#125; Hashtable 作为Map古老的实现类(jdk1.0)；线程安全的，效率低；不能存储null的key和value。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序。 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Properties Properties 类是 Hashtable 的子类，常用来处理配置文件。key和value都是Sting类型。 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。 ==Collections工具类==概述 Collections 是一个操作 Set、List 和 Map 等集合的工具类。 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 ==常用方法== ==排序操作：(均为非static方法)== reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 ==查找、替换== Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package chapter_11;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @author Justry * @Description * @date 2020-11-28 11:52 上午 */public class CollectionsTest &#123; @Test public void Test1()&#123; ArrayList arrayList = new ArrayList(); arrayList.add(&quot;Tom&quot;); arrayList.add(546); arrayList.add(324); arrayList.add(&quot;Jack&quot;); System.out.println(arrayList); // [Tom, 546, 324, Jack] // reverse Collections.reverse(arrayList); System.out.println(arrayList); // [Jack, 324, 546, Tom] // swap Collections.swap(arrayList, 0, 2); System.out.println(arrayList); // [546, 324, Jack, Tom] //copy List&lt;Object&gt; arrayList1 = Arrays.asList(new Object[arrayList.size()]); System.out.println(arrayList1); // [null, null, null, null] Collections.copy(arrayList1, arrayList); System.out.println(arrayList1); // [546, 324, Jack, Tom] &#125;&#125; ==同步控制==： Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。 12// synchronizedXxx() List list = Collections.synchronizedList(arrayList); // 返回的list为线程安全的 补充：Enumeration Enumeration 接口是 Iterator 迭代器的 “古老版本”。 hasMoreElements() nextElement() 12345Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;);while(stringEnum.hasMoreElements())&#123; Object obj = stringEnum.nextElement(); System.out.println(obj);&#125; ==面试题==：Collection 和 Collections的区别？","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十二章 泛型","slug":"第十二章 泛型","date":"2020-11-26T14:23:19.245Z","updated":"2020-12-01T01:41:45.540Z","comments":true,"path":"undefined/95b4.html","link":"","permalink":"https://asteroidcs.github.io/undefined/95b4.html","excerpt":"","text":"范型的理解为什么要有泛型? 解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。 什么是范型？ 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 泛型的引入背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。 在集合中使用泛型​ ==使用范型的时候，这个范型指的是基本数据类型，即&lt;&gt;中不能放int、double、float等，应该放它们的包装类== 使用 使用范型之前的情况 12345678910111213141516@Test public void test1() &#123; ArrayList list = new ArrayList();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //问题一：；类型不安全// list.add(&quot;Tom&quot;); for (Object score : list) &#123; //问题二：强转时，可能会出现类型异常ClassCastException int stuScore = (Integer) score; System.out.println(stuScore); &#125; &#125; 使用范型的情况：以ArrayList为例 1234567891011121314151617181920212223@Test public void test2() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //编译时，就会进行类型检查，保证数据安全// list.add(&quot;Tom&quot;); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;// System.out.println(stuScore);// &#125; //方式二：Iterator Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; 使用泛型的情况：以HashMap为例 12345678910111213141516171819202122@Test public void test3() &#123;// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk新特性：类型推断 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;, 87); map.put(&quot;Jerry&quot;, 90); map.put(&quot;Jack&quot;, 66);// map.put(123,&quot;ABC&quot;); //泛型嵌套 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;--&gt;&quot; + value); &#125; &#125;： ==总结== 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型 比如：add(E e) —&gt;实例化以后：add(Integer e) ==注意点==：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型 自定义泛型类、泛型接口、泛型方法 范型的声明 12interface List&lt;T&gt; 和 class GenTest&lt;K,V&gt;其中，T，K，V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写 范型的实例化 12345//一定要在类名后面指定类型参数的值（类型）。如List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator();//T只能是累，不能用基本数据类型填充。但可以使用包装类填充//把一个集合中的内容限制为一个制定的数据类型，这就是generics背后的核心思想 泛型类 使用 12345678910111213141516171819202122232425public class Order&lt;T&gt; &#123; String OrderName; int orderId; //类的内部结构就可以使用类的范型 T orderT; //这里的T目前不确定什么类型，实例化的时候才会确定 public Order()&#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; OrderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125;&#125; 123456789101112@Test public void test4() &#123; //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;abc&quot;); //建议：实例化时指明类的泛型 Order&lt;String&gt; stringOrder = new Order&lt;String&gt;(&quot;orderAA&quot;, 1001, &quot;order:AA&quot;); stringOrder.setOrderT(&quot;AA:hello&quot;); &#125; ==细节== 范型类可能有多个参数，此时应该将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 范型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass(){} 实例话后，操作原来范型位置的结构必须与指定的范型类型一致 范型不同的引用不能相互赋值 尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中 范型如果不指定，将被擦除，范型对应的类型均按照Object处理，但不等价于Object。经验：范型要使用一路都用。要不用，一路都不要用 如果范型结构是一个接口或抽象类，则不创建范型类的对象 Jdk1.7，范型的简化操作：ArrayList flist = new ArrayList&lt;&gt;() 范型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的范型，在本类或本接口中即代表某种类型，可以作为静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的范型 异常类不能是范型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capcity]； 参考：ArrayList源码中声明：Object[] elementData，而非范型参数类型数组 父类有范型，子类可以选择保留泛型也可以选择指定泛型类型 子类不保留父类的泛型：按需实现 自类保留父类的泛型：泛型子类 ==总结==： 类的内部结构就可以使用类的范型 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 泛型方法 方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型，与类的泛型类没有任何关系 泛型方法的格式 1[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常 泛型方法声明泛型时也可以指定上限 泛型在继承上的体现 泛型在继承方面的体现* * 虽然类A是类B的父类，但是G 和*G二者不具备子父类关系，二者是并列关系。 * 补充：类A是类B的父类，A 是 B 的父类 通配符 使用类型==通配符:?== 比如:List ，Map List&lt;?&gt;是List、List等各种泛型List的父类 读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object 对于List&lt;?&gt;不能向其内部添加数据——&gt;因为我们不知道c的元素类型，我们不能向其中添加对象 唯一的例外是null，它是所有类型的成员 将任意元素加入到其中不是类型安全的 12Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); // 编译时错误 可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。 注意点 不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用 不能用在泛型类的声明上 不能用在创建对象上，右边属于创建集合对象 有限制条件的通配符 通配符指定上限：上限extends:使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 12? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 通配符指定下限：下限super:使用时指定的类型不能小于操作的类，即&gt;= 12? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 举例 12345678&lt;? extends Number&gt;//只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt;//只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt;//只允许泛型为实现Comparable接口的实现类的引用调用","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]}