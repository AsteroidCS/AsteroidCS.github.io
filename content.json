{"meta":{"title":"Asteroid","subtitle":"","description":"学而思，思而行","author":"Komorebi","url":"https://asteroidcs.github.io","root":"/"},"pages":[{"title":"about","date":"2020-11-25T10:24:48.000Z","updated":"2020-11-26T04:33:22.397Z","comments":false,"path":"about/index.html","permalink":"https://asteroidcs.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-25T10:14:53.000Z","updated":"2020-12-01T02:09:11.467Z","comments":true,"path":"categories/index.html","permalink":"https://asteroidcs.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-25T11:24:28.000Z","updated":"2020-12-01T02:11:25.713Z","comments":true,"path":"link/index.html","permalink":"https://asteroidcs.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-25T10:21:58.000Z","updated":"2020-12-01T02:10:23.419Z","comments":true,"path":"tags/index.html","permalink":"https://asteroidcs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第十章 枚举类与注解","slug":"Java基础/第十章 枚举类与注解","date":"2020-12-12T02:37:20.086Z","updated":"2020-12-15T01:44:31.426Z","comments":true,"path":"undefined/df1b.html","link":"","permalink":"https://asteroidcs.github.io/undefined/df1b.html","excerpt":"","text":"枚举类的使用 $\\color{red}{类的对象只有有限个，确定的}$。如 $\\color{gold}{当需要定义一组常量时，强烈建议使用枚举类。}$ 如果枚举类中只有一个对象，则可以作为一种单例模式的实现方式 枚举类的属性： $\\color{gold}{枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰}$ 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 注意： 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：$\\color{blue}{public static final}$ 对象如果有实例变量，应该声明为$\\color{blue}{private final}$，并在构造器中初始化 如何自定义枚举类 方式一：JDK 5.0之前，自定义枚举类 方式二：JDK 5.0时，可以是可以使用$\\color{blue}{enum关键字}$定义枚举类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 自定义枚举类 * * @author DawnLee * @create 2020-11-14 12:41 */public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(spring);//Season&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125; &#125;&#125;//自定义枚举类class Season&#123; //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器，并给对象属性初始化 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求2：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Enum类的主要方法 方法名 详细描述 valueOf 传递枚举类型的Class对象和枚举常量名称给静态方法valueOf，会的到与参数匹配的枚举常量 toString 得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读 equals 在枚举类型中可以直接使用“==”来比较两个枚举常量是否相等。Enum提供的这个equals()方法也是直接使用“==”实现的。它的存在是为了在Set、List和Map中使用。注意：equals()是不可变的。 hashCode Enum实现了hashCode()来和equals()保持一致，它也是不可变的。 getDeclaringClass 得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。 name 得到当前枚举常量的名称。建议优先使用toString()。 ordinal 得到当前枚举常量的次序。 compareTo 枚举类型实现了Comparable接口这样可以比较两个枚举常量的大小(按照声明的顺序排列) clone 枚举类型不能被Clone。为了防止子类实现克隆方法。Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()。 $\\color{red}{values()方法：}$返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 $\\color{red}{valueOf(String str)：}$返回枚举类对象名是str的对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 $\\color{red}{toString()：}$返回当前枚举类对象常量的名称。 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口。 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。 情况一：实现接口，在enum类中实现抽象方法。直接在接口类中重写抽象方法即可。 情况二：让枚举类的对象分别实现接口中的抽象方法。需要在每一个枚举对象后重写具有针对性的抽象方法。 1234567891011121314151617181920212223SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;,SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125;&#125;,AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125;&#125;,WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125;&#125;; 注解的使用注解(Annotation)概述 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)。 Annotation其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation可以像修饰符一样被使用, 可用于$\\color{red}{修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, }$这些信息被保存在Annotation的“name=value”对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：$\\color{gold}{框架 = 注解 + 反射 + 设计模式。}$ 常见的Annotation示例 使用Annotation时要在其前面增加@符号, 并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素。 $\\color{gold}{示例一：生成文档相关的注解}$ @author 标明开发该类模块的作者，多个作者之间使用,分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写 其中： @param @return 和 @exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名 形参类型 形参说明。 @return 的格式要求：@return 返回值类型 返回值说明。 @exception的格式要求：@exception 异常类型 异常说明。 @param和@exception可以并列多个。 12345678910111213141516171819202122package com.annotation.javadoc;/*** @author shkstart* @version 1.0* @see Math.java*/public class JavadocTest &#123; /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) &#123; &#125; /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius)&#123; return Math.PI * radius * radius; &#125; &#125; $\\color{gold}{示例二：在编译时进行格式检查(JDK内置的三个基本注解)}$ @Override: 限定重写父类方法, 该注解只能用于方法。 **@Deprecated: ** 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。 @SuppressWarnings: 抑制编译器警告。 123456789101112131415package com.annotation.javadoc;public class AnnotationTest&#123; public static void main(String[] args) &#123; @SuppressWarnings(&quot;unused&quot;) int a = 10; &#125; @Deprecated public void print()&#123; System.out.println(&quot;过时的方法&quot;); &#125; @Override public String toString() &#123; return &quot;重写的toString方法()&quot;; &#125; &#125; $\\color{gold}{示例三：跟踪代码依赖性，实现替代配置文件功能}$ Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。 spring框架中关于“事务”的管理。 自定义Annotation 定义新的 Annotation 类型使用 @interface 关键字。 自定义注解自动继承了java.lang.annotation.Annotation接口。 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字。 如果只有一个参数成员，建议使用参数名为value。 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”。 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation。 $\\color{red}{注意：自定义注解必须配上注解的信息处理流程(使用反射)才有意义。}$ 123456789101112131415161718package top.triabin._02annotation;/** * 如何自定义注解：参照@SuppressWarnings定义 * ① 注解声明为@interface * ② 内部定义成员，通常使用value表示 * ③ 可以指定成员的默认值，使用default定义 * ④ 如果自定义注解没有成员，表明是一个表标识作用 * * 如果注解有成员，在使用注解时，需要指明成员的值。 * 应用：@MyAnnotation(value=&quot;自己指定值，未指定则为default值&quot;) * * @author DawnLee * @create 2020-11-14 15:05 */public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; JDK的元注解 JDK 的元 Annotation 用于修饰其他 Annotation 定义。 JDK5.0提供了4个标准的meta-annotation类型，分别是： ①Retention ②Target ③Documented ④Inherited $\\color{red}{@Retention：}$只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。 RetentionPolicy.CLASS：在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值。 RetentionPolicy.RUNTIME：在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 $\\color{red}{@Target：}$用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。 @Documented：用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 @Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解。 实际应用中，使用较少。 利用反射获取注解信息(在反射部分涉及)JDK8中注解的新特性 Java 8对注解处理提供了两点改进：$\\color{red}{可重复的注解}$及$\\color{red}{可用于类型的注解}$。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。 可重复注解： 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class； MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解： DK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE ①ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ②ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第九章 常用类","slug":"Java基础/第九章 常用类","date":"2020-12-12T02:36:33.038Z","updated":"2020-12-14T08:23:50.249Z","comments":true,"path":"undefined/f1a6.html","link":"","permalink":"https://asteroidcs.github.io/undefined/f1a6.html","excerpt":"","text":"字符串相关的类：StringString的特性 String类：代表字符串。Java程序中所有的字符串面值（如”abc”）都作为此类的实例实现。 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 String内部定义了final char[] value用于存储字符串数据。 1234567public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash;//Default to 0 String实现了Serializable接口：表示字符串是支持序列化的； 实现了Comparable接口：表示String可以比较大小。 String是一个final类，代表不可改变的字符序列。体现： 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值。 通过字面量的方式（区别于new）给一个字符赋值，此时的字符串值生命在字符串常量池中。 字符串常量池中是不会存储相同内容的字符串的。 String对象的创建123456789101112String str = &quot;hello&quot;;//本质上this.value = new char[0];String s1 = new String();//this.value = original.value;String s2 = new String(String original);//this.value = Arrays.copyOf(value,value.length);String s3 = new String(char[] a);String s4 = new String(char[] a,int startIndex,int count); String的实例化方式： 方式一：通过字面量定义的方式 方式二：通过 new + 构造器 的方式 1234567891011121314151617181920/** * String的实例化方式 * 方式一：通过字面量定义的方式 * 方式二：通过 new + 构造器 的方式 */@Testpublic void test2()&#123; //通过字面量定义的方式：此时的s1和s2的数据JavaEE声明在方法区的字符串常量池中。 String s1 = &quot;JavaEE&quot;; String s2 = &quot;JavaEE&quot;; //通过 new + 构造器 的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 String s3 = new String(&quot;JavaEE&quot;); String s4 = new String(&quot;JavaEE&quot;); System.out.println(s1 == s2);//true System.out.println(s1 == s3);//false System.out.println(s1 == s4);//false System.out.println(s3 == s2);//false&#125; 面试题：String str1 = &quot;abc&quot;;与String str2 = new String (&quot;abc&quot;);的区别？ 字符串对象是如何存储的123456789101112public class Person&#123; String name; int age; public Person()&#123; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125;&#125; 12345678public void test2()&#123; System.out.println(&quot;********************&quot;); Person p1 = new Person(&quot;Tom&quot;,12); Person p2 = new Person(&quot;Tom&quot;,12); System.out.println(p1.name.equals(p2.name));//true System.out.println(p1.name == p2.name);//true&#125; 面试题：String s = new String(&quot;abc&quot;);方式创建对象，在内存中创建了几个对象？ 1答：2个。一个是堆空间中new的结构，另一个是char[]对应的常量池中的数据（”abc”）。 练习题： 12345678910111213141516171819202122@Testpublic void test3()&#123; String s1 = &quot;JavaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;JavaEEhadoop&quot;; String s4 = &quot;JavaEE&quot; + &quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;JavaEE&quot; + s2; String s7 = s1 + s2; System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false String s8 = s5.intern();//返回值得到的s8使用的是常量池中已经存在的“JavaEEhadoop” System.out.println(s3 == s8);//true&#125; 结论： 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 只要其中有一个变量，结果就在堆空间中。 如果拼接的结果调用intern()方法，返回值就在常量池中。 String常用方法 nt length()：返回字符串的长度： return value.length。 char charAt(int index)：返回某索引处的字符：return value[index]。 boolean isEmpty()：判断是否是空字符串：return value.length == 0。 String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写。 String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写。 String trim()：返回字符串的副本，忽略前导空白和尾部空白。 boolean equals(Object obj)：比较字符串的内容是否相同。 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写。 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”。 int compareTo(String anotherString)：比较两个字符串的大小。 String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true。 int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引。 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 注：indexOf和lastIndexOf方法如果未找到都是返回-1。 String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement)：使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement)：使 用 给 定 的eplacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 String与基本数据类型转换 字符串 → 基本数据类型、包装类 ① Integer包装类的public static int parseInt(String s)：可将由“数字”字符组成的字符串转换为整形。 ② 类似的，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。 基本数据类型、包装类 → 字符串 ① 调用String类的public String valueOf(int n)可将int型转换为字符串。 ② 相应的，valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型2到字符串的转换。 字符数组 → 字符串 ① String类的构造器：String(char[])和String(char[], int offset, int length)分别用字符数组中的全部字符和部分字符创建字符串对象。 字符串 → 字符数组 ① public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。 ② public void getChars(int srcBegin, int srcEnd, char dst, int dstBegin)：提供了将制定索引范围内的字符串存放到数组中的方法。 字节数组 → 字符串 ① String(byte[])：通过使用平台的默认字符集解码指定的byte数组，构造一个新的String。 ② String(byte[], int offset, int length)：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构成一个字符串对象。 字符串 → 字节数组 ① public byte[] getBytes()：使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中。 ② public byte[] getBytes(String charsetName)：使用指定的字符集将此String编码到byte序列，并将结果存储到新的byte数组。 实际应用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package top.triabin._01string;import org.junit.Test;import java.io.UnsupportedEncodingException;import java.util.Arrays;/** * 涉及到String类与其他结构之间的转换 * * @author DawnLee * @create 2020-11-03 14:12 */public class StringTest1 &#123; /** * String与基本数据类型、包装类之间的转换 */ @Test public void test1()&#123; //字符串 → 基本数据类型、包装类 String str1 = &quot;123&quot;; int num = Integer.parseInt(str1);//123 //基本数据类型、包装类 → 字符串 String str2 = String.valueOf(num);//&quot;123&quot; String str3 = num + &quot;&quot;;//&quot;123&quot; &#125; /** * String与char[]之间的转换 */ @Test public void test2()&#123; String str1 = &quot;abc123&quot;;//题目：反转字符串指定部分字母，例：a21cb3 //Sting → char[]：调用String的toCharArray()方法 char[] charArray = str1.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) &#123; System.out.println(charArray[i]); &#125; //char[] → Sting：调用String的构造器 char[] arr = new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;; String str2 = new String(arr); System.out.println(str2); &#125; /** * String与byte[]之间的转换 * * 编码：字符串 → 字节 * 解码：解码的逆过程，字节 → 字符串 * * 说明：解码时，要求解码使用的字符集必须与编码使用的字符集一致，否则会出现乱码 */ @Test public void test3() throws UnsupportedEncodingException &#123; String str1 = &quot;abc123中国&quot;; System.out.println(&quot;原字符串str1：&quot; + str1); //String → byte[]：调用String的getBytes()方法 byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码 System.out.println(&quot;使用默认的字符集(UTF-8)编码str1为bytes：&quot; + Arrays.toString(bytes)); byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码 System.out.println(&quot;使用gbk编码str1为gbks：&quot; + Arrays.toString(gbks)); //byte[] → String： String str2 = new String(bytes);//使用默认的字符集，进行解码 System.out.println(&quot;使用默认字符集(UTF-8)解码bytes：&quot; + str2); String str3 = new String(gbks); System.out.println(&quot;使用默认字符集(UTF-8)解码gbks：&quot; + str3);//出现乱码，原因：编码集和解码集不一致 String str4 = new String(gbks,&quot;gbk&quot;);//指定解码方式为gbk System.out.println(&quot;使用gbk解码gbks：&quot; + str4);//没有出现乱码，原因：编码集与解码集一致 &#125;&#125; StringBuffer与StringBuilder类 String/StringBuffer、StringBuilder三者的异同？ String：不可变的字符序列；底层结构使用char[]存储。 StringBuffer：可变的字符序列；线程安全的，效率低；底层结构使用char[]存储。 StringBuilder：可变的字符序列；JDK 5.0新增的，线程不安全的，效率高；底层结构使用char[]存储。 源码分析： 123456789String str = new String();//char[] value = new char[];String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度为16的数组。sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;sb1.append(&#x27;c&#x27;);//value[2] = &#x27;c&#x27;;StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length + 16]; 问题1 System.out.println(sb2.length());//3 问题2 扩容问题，如果要添加的数据底层数组存不下了，那就需要扩容底层数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议使用StringBuffer(int capacity)或StringBuilder(int capacity)以指定长度，避免扩容浪费资源，降低效率。 StringBuffer的常用方法：（StringBuilder与它相同） StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接。 StringBuffer delete(int start,int end)：删除指定位置的内容。 StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str。 StringBuffer insert(int offset, xxx)：在指定位置插入xxx。 StringBuffer reverse() ：把当前字符序列逆转。 public int indexOf(String str)：返回字符串第一次出现的索引。 public String substring(int start,int end)：返回一个从start开始到end索引结束的左闭右开区间的子字符串。 public int length()： public char charAt(int n) public void setCharAt(int n ,char ch) 总结 增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n ,char ch)修改一个字符，replace(int start, int end, String str)修改一个字符串 查：char charAt(int n) 插：insert(int offset, xxx) 长度：length() *遍历：for() + charAt()、toString() 应用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package top.triabin._01string;import org.junit.Test;/** * 关于StringBuffer和StringBuilder的使用 * * @author DawnLee * @create 2020-11-03 15:21 */public class StringBufferBuilderTest &#123; /* String/StringBuffer、StringBuilder三者的异同？ String：不可变的字符序列；底层结构使用char[]存储； StringBuffer：可变的字符序列；线程安全的，效率低；底层结构使用char[]存储； StringBuilder：可变的字符序列；JDK 5.0新增的，线程不安全的，效率高；底层结构使用char[]存储； */ @Test public void test1()&#123; StringBuffer sb1 = new StringBuffer(&quot;abc&quot;); sb1.setCharAt(0,&#x27;m&#x27;); System.out.println(sb1);//mbc，可变 StringBuffer sb2 = new StringBuffer(); System.out.println(sb2.length());//0 &#125; /** * StringBuffer的常用方法：（StringBuilder与它相同） */ @Test public void test2()&#123; StringBuffer s1 = new StringBuffer(&quot;abc&quot;); s1.append(1); s1.append(&#x27;2&#x27;); System.out.println(s1);//abc12// s1.delete(2,4);//ab2// s1.replace(2,4,&quot;hello&quot;);//abhello2// s1.insert(2,false);//abfalsec12,s1.length() = 10// s1.reverse();//21cba String s2 = s1.substring(1, 3);//bc System.out.println(s1); System.out.println(s2); &#125; /** * 对比String、StringBuffer、StringBuilder三者的效率 * 从高到低：StringBuilder &gt; StringBuffer &gt; String */ @Test public void test3()&#123; //初始设置 long startTime = 0L; long endTime = 0L; String text = &quot;&quot;; StringBuffer buffer = new StringBuffer(&quot;&quot;); StringBuilder builder = new StringBuilder(&quot;&quot;); //开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuffer的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuilder的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++)&#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;String的执行时间：&quot; + (endTime - startTime)); &#125;&#125; JDK 8之前的日期时间API java.lang.System类 System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 计算世界时间的主要标准有 UTC(Coordinated Universal Time) GMT(Greenwich Mean Time) CST(Central Standard Time) 应用 1234567891011Java/** * System类中的currentTimeMillis() */@Testpublic void test1()&#123; long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time);&#125; java.util.Date类表示特定的瞬间，精确到毫秒。 构造器： ① Date()：使用无参构造器创建的对象可以获取本地的当前时间。 ② Date(long date) 常用方法 ① getTime()：返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。 ② toString()：把此Date对象转换成以下形式的String：dow mon dd hh:mm:ss zzz yyyy 其中：dow是一周中的某一天（Sun，Mon，Tue，Wed，Thu，Fri，Sat），zzz是时间标准。 ③ 其他很多方法都过时了。 应用 12345678910111213141516171819202122232425262728293031323334353637383940Java/** * java.util.Date类 * |---java.sql.Date类 * 1.两个构造器的使用 * &gt;构造器一：Date()：创建一个对应当前时间的Date对象 * &gt;构造器二：创建指定毫秒数的对象 * * 2.两个方法的使用 * &gt;toString()：显示当前年、月、日、时、分、秒 * &gt;getTime()：获取当前Date对象对应的的时间戳。 * * 3.java.sql.Date对应着数据库中的日期类型变量 * &gt;如何实例化 * &gt;如何将java.util.Date对象转换为java.sql.Date对象 */@Testpublic void test2()&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Wed Nov 04 22:40:52 CST 2020 System.out.println(date1.getTime());//1604500906084 //构造器二：创建指定毫秒数的对象 Date date2 = new Date(1604500906084L); System.out.println(date2.toString());//Wed Nov 04 22:41:46 CST 2020 //创建java.sql.Date对象 java.sql.Date date3 = new java.sql.Date(1604500906084L); System.out.println(date3);//2020-11-04 //如何将java.util.Date对象转换为java.sql.Date对象 //情况一： // Date date4 = new java.sql.Date(1604500906084L); // java.sql.Date date5 = (java.sql.Date) date4; //情况二： Date date6 = new Date(); java.sql.Date date7 = new java.sql.Date(date6.getTime());&#125; java.text.SimpleDateFormat类​ SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析。 两个操作 ① 格式化：日期 → 字符串 ② 解析：格式化的逆过程，字符串 → 日期 实例化 应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Java/** * SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析 * * 1.两个操作： * 1.1 格式化：日期 --&gt; 字符串 * 1.2 解析：格式化的逆过程，字符串 --&gt; 日期 * * 2.SimpleDateFormat的实例化 */@Testpublic void test3()&#123; //实例化SimpleDateFormat：使用默认构造器 SimpleDateFormat sdf = new SimpleDateFormat(); //格式化：日期 --&gt; 字符串 Date date = new Date(); System.out.println(date); String format = sdf.format(date); System.out.println(format);//20-11-6 下午10:13 //解析：格式化的逆过程，字符串 --&gt; 日期 String str = &quot;20-11-6 下午10:13&quot;; Date date1 = null; try &#123; date1 = sdf.parse(str); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; System.out.println(date1); //************按照指定的方式格式化和解析：调用带参的构造器***************** // SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;); SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss aaa&quot;); String format1 = sdf1.format(date); System.out.println(format1);//2020-11-06 10:23:14 下午 //解析：要求字符串必须符合SimpleDateFormat识别的格式（通过构造器参数体现） Date date2 = null; try &#123; date2 = sdf1.parse(&quot;2020-11-06 10:23:14 下午&quot;); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; System.out.println(date2);&#125; 练习：将字符串”2020-09-08”转换为java.sql.Date 1234567891011121314151617Java/** * 练习一：字符串&quot;2020-09-08&quot;转换为java.sql.Date */@Testpublic void testExer()&#123; String birth = &quot;2020-09-08&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try&#123; date = sdf.parse(birth); &#125;catch(ParseException e)&#123; e.printStackTrace(); &#125; java.sql.Date birthDate = new java.sql.Date(date.getTime()); System.out.println(birthDate);&#125; java.util.Calender(日历)类 Calendar是一个抽象基类，主要用于完成日期字段之间相互操作的功能。 获取Calendar实例的方法： ① 使用Calendar.getInstance()方法 ② 调用它的子类GregorianCalendar的构造器 一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND。 ①pubilc void set(int field,int value)：field为本周/月/年的第几天，将今天改为指定周/月/年的第value天； ②public void add(int field,int amount)：将本周/月/年的第field天加/减amount天； ③public final Date getTime()：将Calendar类转换为Date类； ④public fianl void setTime(Date date)：将Date类转换为Calendar类。 注意： ①获取月份时：月是0，二月是1，以此类推，12月是11； ②获取星期时：周日是1，周一是2……周六是7。 实际应用 1234567891011121314151617181920212223242526272829303132333435363738Java/** * Calendar日历类（抽象类）的使用 */@Testpublic void testCalendar()&#123; //1.实例化 //方式一：创建其子类（GregorianCalendar）的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance(); // System.out.println(calendar.getClass()); //2.常用方法 //get() int days = calendar.get(Calendar.DAY_OF_MONTH);//返回今天是本月的第几天 System.out.println(days); System.out.println(calendar.get(Calendar.DAY_OF_YEAR));//返回今天是今年的第几天 //set() calendar.set(Calendar.DAY_OF_MONTH,22);//将今天改为本月第22天 days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days);//22 //add() calendar.add(Calendar.DAY_OF_MONTH,3); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days);//25(22 + 3),减相应天数则将amount改为负数即可 //getTime()：日历类 --&gt; Date Date date = calendar.getTime(); System.out.println(date); //setTime()：Date --&gt; 日历类 Date date1 = new Date(); calendar.setTime(date1); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days);&#125; JDK 8中新日期时间API新时间日期AP java.time：包含值对象的基础包； java.time.chrono：提供对不同的日历系统的访问； java.time.format – 格式化和解析时间和日期； java.time.temporal – 包括底层框架和扩展特性； java.time.zone – 包含时区支持的类。 说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。 LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 ①LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。 ②LocalTime表示一个时间，而不是日期。 ③LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * LocalDate、LocalTime、LocalDateTime的使用 * * 说明： * 1.LocalDateTime相较于LocalDate、LocalTime，使用频率更高。 * 2.类似于Calendar */@Testpublic void test1() &#123; //now()：获取当前的日期、时间或日期+时间 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate);//2020-11-13 System.out.println(localTime);//12:16:39.144 System.out.println(localDateTime);//2020-11-13T12:16:39.144 //of()：设置指定的年、月、日、时、分、秒，没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 11, 12, 12, 14, 59); System.out.println(localDateTime1);//2020-11-12T12:14:59 //getXxx()：获取相关属性 System.out.println(localDateTime.getDayOfMonth());//13 System.out.println(localDateTime.getDayOfWeek());//FRIDAY System.out.println(localDateTime.getMonth());//NOVEMBER System.out.println(localDateTime.getMonthValue());//11 System.out.println(localDateTime.getMinute());//20 //体现不可变性 //withXxx()：设置相关属性 LocalDate localDate1 = localDate.withDayOfMonth(22); System.out.println(localDate);//2020-11-13 System.out.println(localDate1);//2020-11-22 LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime);//2020-11-13T12:25:18.535 System.out.println(localDateTime2);//2020-11-13T04:25:18.535 //仍体现不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime);//2020-11-13T12:28:01.609 System.out.println(localDateTime3);//2021-02-13T12:28:01.609 LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime);//2020-11-13T12:30:29.578 System.out.println(localDateTime4);//2020-11-07T12:30:29.578&#125; 瞬时：Instant Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。 java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 (1 ns = 10-9 s) 1秒 = 1000毫秒 =106微秒=109纳秒。 应用： 123456789101112131415161718192021222324Java/** * Instant的使用 * * 类似于java.util.Date类 */@Testpublic void test2()&#123; //now()：获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2020-11-13T04:49:25.712Z //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2020-11-13T12:51:00.439+08:00 //toEpochMilli()：获取自1970-01-01 00:00:00(UTC)到当前时间的毫秒数 --&gt; 类似Date类的getTime() long milli = instant.toEpochMilli(); System.out.println(milli);//1605243305678 //ofEpochMilli()：通过给定的毫秒数，获取Instant实例 --&gt; 类似Date(long millis) Instant instant1 = Instant.ofEpochMilli(1605243305678L); System.out.println(instant1);//2020-11-13T04:55:05.678Z&#125; 格式化与解析日期或时间​ java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式。如 ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 应用： 123456789101112131415161718192021222324252627282930313233343536373839404142Java/** * DateTimeFormatter：格式化或解析日期、时间 * 类似于SimpleDateFormat */@Testpublic void test3()&#123; //实例化方式一：预定义标准格式 DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化：日期 --&gt; 字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime);//2020-11-13T13:13:58.363 System.out.println(str1);//显示结果相同，只是类型变了 //解析：字符串 --&gt; 日期 TemporalAccessor parse = formatter.parse(&quot;2020-11-13T13:13:58.363&quot;); System.out.println(parse);//&#123;&#125;,ISO resolved to 2020-11-13T13:13:58.363 //实例化方式二：本地化相关的格式。如ofLocalDateTime() //FormatStyle.LONG/MEDIUM/SHORT：适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); //格式化 String str2 = formatter1.format(LocalDateTime.now()); System.out.println(str2);//2020年11月13日 下午01时35分39秒 //解析略 //ofLocalDate() //FormatStyle.FULL/LONG/MEDIUM/SHORT DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2020年11月13日 星期五 //重点：方式三：自定义格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss E&quot;) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2020-11-13 04:45:27 //解析 TemporalAccessor parse1 = formatter3.parse(&quot;2020-11-13 04:45:27&quot;); System.out.println(parse1);//&#123;HourOfAmPm=4, MinuteOfHour=45, SecondOfMinute=27, MilliOfSecond=0, NanoOfSecond=0, MicroOfSecond=0&#125;,ISO resolved to 2020-11-13&#125; 其他API ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris。 ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等。 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 持续时间：Duration，用于计算两个“时间”间隔。 日期间隔：Period，用于计算两个“日期”间隔。 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。 TemporalAdjusters : 该类通过静态方法。 (firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。 参考：与传统日期处理的转换 Java比较器负整数，如果当前对象this等于形参对象obj，则返回零。 方式一：自然排序(java.lang.Comparable) Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。 如果当前对象this大 于形参对象obj，则返回正整数 如果当前对象this小于形参对象obj，则返回负整数 如果当前对象this等于形参对象obj，则返回零 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 Comparable 的典型实现：(默认都是从小到大排列的) String：按照字符串中字符的Unicode值进行比较 Character：按照字符的Unicode值来进行比较 实例： 1234567891011121314151617181920@Testpublic void test1() &#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;, &quot;JJ&quot;, &quot;DD&quot;&#125;; Arrays.sort(arr); System.out.println(Arrays.toString(arr));&#125;@Testpublic void test2()&#123; Goods[] arr = new Goods[5]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,23); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //[Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=23.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]&#125; 方式二：定制排序(java.util.Comparator) 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，**或者实现了**java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的 顺序，或者为那些没有自然顺序的对象 collection 提供排序。 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void test3()&#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;, &quot;JJ&quot;, &quot;DD&quot;&#125;; Arrays.sort(arr,new Comparator()&#123; //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123; String s1 = (String)o1; String s2 = (String)o2; return -s1.compareTo(s2);//从大到小 &#125; throw new RuntimeException(&quot;输入数据不一致！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr));//[MM, KK, JJ, GG, DD, CC, AA]&#125;/** * 练习 */@Testpublic void test4()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,23); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;huaweiMouse&quot;,22); arr[5] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr, new Comparator() &#123; //先按照产品名称从高到低，在按照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice()); &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入数据不一致！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); //[Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=22.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=23.0&#125;]&#125; System类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量：System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version Java运行时环境版本 java.home Java安装目录 os.name 操作系统名称 os.version 操作系统版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 实例： 1234567891011121314151617181920212223242526272829303132333435package top.triabin._05system;import org.junit.Test;/** * System类的使用 * * @author DawnLee * @create 2020-11-13 22:20 */public class SystemTest &#123; @Test public void test()&#123; String javaVersion = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;java的version:&quot; + javaVersion); String javaHome = System.getProperty(&quot;java.home&quot;); System.out.println(&quot;java的home:&quot; + javaHome); String osName = System.getProperty(&quot;os.name&quot;); System.out.println(&quot;os的name:&quot; + osName); String osVersion = System.getProperty(&quot;os.version&quot;); System.out.println(&quot;os的version:&quot; + osVersion); String userName = System.getProperty(&quot;user.name&quot;); System.out.println(&quot;user的name:&quot; + userName); String userHome = System.getProperty(&quot;user.home&quot;); System.out.println(&quot;user的home:&quot; + userHome); String userDir = System.getProperty(&quot;user.dir&quot;); System.out.println(&quot;user的dir:&quot; + userDir); &#125;&#125; Math类​ java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 abs：绝对值 acos,asin,atan,cos,sin,tan：三角函数 sqrt：平方根 pow(double a,doble b)：a的b次幂 log：自然对数 exp：e为底指数 max(double a,double b)：获取两数之中的较大值 min(double a,double b)：获取两数之中的较小值 random()：返回0.0到1.0的随机数 long round(double a)：double型数据a转换为long型（四舍五入） toDegrees(double angrad)：弧度—&gt;角度 toRadians(double angdeg) 角度—&gt;弧度 BigInteger与BigDecimalBigInteger nteger类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val)：根据字符串构建BigInteger对象 常用方法 BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 ①public BigDecimal(double val) ②public BigDecimal(String val) 常用方法 ①public BigDecimal add(BigDecimal augend) ②public BigDecimal subtract(BigDecimal subtrahend) ③public BigDecimal multiply(BigDecimal multiplicand) ④public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 123456789101112131415161718192021222324Javapackage top.triabin._07bigintegerdecimal;import java.math.BigDecimal;import java.math.BigInteger;/** * BigInteger和BigDecimal类常用方法的使用 * * @author DawnLee * @create 2020-11-13 22:47 */public class InteDeciTest &#123; @org.junit.Test public void test()&#123; BigInteger bi = new BigInteger(&quot;12433241123&quot;); BigDecimal bd = new BigDecimal(&quot;12435.351&quot;); BigDecimal bd2 = new BigDecimal(&quot;11&quot;); System.out.println(bi); // System.out.println(bd.divide(bd2)); System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP)); System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));//保留15位小数 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第七章 异常处理","slug":"Java基础/第七章 异常处理","date":"2020-12-11T16:00:00.000Z","updated":"2020-12-12T02:33:10.130Z","comments":true,"path":"undefined/4aff.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4aff.html","excerpt":"","text":"异常概述与异常体系结构 概念：在Java语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）。 Java程序在执行过程中所发生的的异常事件可分为两类： $\\color{blue}{Error：}$Java虚拟机无法解决的严重问题。如JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError（栈溢出）和OOM（java.lang.OutOfMeoryError，堆溢出）。一般不编写针对性的代码进行处理。 $\\color{blue}{Exception：}$其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如： $\\color{red}{指针访问}$ $\\color{red}{试图读取不存在的文件}$ $\\color{red}{网络连接中断}$ $\\color{red}{数组角标越界}$ 对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法时由程序员在编写程序时，就考虑到错误的检测、错误消息提示，以及错误的处理。 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等 分类：编译时异常和运行时异常 红色：编译时异常，即受检(checked)异常。 蓝色：运行时异常，即非受检(unchecked)异常。 运行时异常 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响。 编译时异常 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。 对于这类异常，如果程序不处理，可能会带来意想不到的结果。 面试题：常见的异常有哪些？举例说明 编译时异常： IOException FileNotFoundException ClassNotFoundException 运行时异常： NullPointerException（空指针异常） ArrayIndexOutOfBoundsException（数组下标越界） ClassCastException NumberFormatException（数字格式化异常） InputMismatchException（输入不匹配异常） ArithmeticException（算数异常） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@SuppressWarnings(&quot;unused&quot;)public class Exception &#123; //************************编译时异常************************ @Test public void test7() &#123;// File file = new File(&quot;hello.txt&quot;);// FileInputStream fis = new FileInputStream(file);//FileNotFoundException// int data = fis.read();//IOException// while(data !=-1) &#123;// System.out.println((char)data);// data = fis.read();//IOException// &#125;// fis.close();//IOException &#125; //************************运行时异常************************ //ArithmeticException:算术异常 @Test public void test6() &#123; int a = 10; int b = 0; System.out.println(a / b); &#125; //InputMismatchException @Test public void test5() &#123; Scanner scan = new Scanner(System.in); int score = scan.nextInt();//当输入类型不是int型时报错：InputMismatchException System.out.println(score); scan.close(); &#125; //NumberFormatException @Test public void test4() &#123; String str = &quot;123&quot;; str = &quot;abc&quot;; int num = Integer.parseInt(str); System.out.println(num); &#125; //ClassCastException @Test public void test3() &#123; Object obj = new Date(); String str = (String)obj; &#125; //IndexOutOfBoundsException @Test public void test2() &#123; //ArrayIndexOutOfBoundsException// int[] arr = new int[10];// System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = &quot;abc&quot;; System.out.println(str.charAt(3)); &#125; //NullPointerException @SuppressWarnings(&quot;null&quot;) @Test public void test1() &#123;// int[][] arr = null;// System.out.println(arr[3]); String str = &quot;abcd&quot;; str = null; System.out.println(str.charAt(0)); &#125;&#125; 异常处理机制一：try-catch-finally异常处理：抓抛模型 过程一：“抛”，程序正常执行中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。 一旦抛出对象以后，其后的代码就不再执行。 过程二：“抓”，可以理解为异常的处理方式：① try-catch-finally ②throws try-catch-finally的使用1234567891011try&#123; //可能出现异常的代码&#125;catch(异常类型1 变量名1)&#123; //处理异常的方式1&#125;catch(异常类型2 变量名2)&#123; //处理异常的方式2&#125;//……finally&#123; //一定会执行的代码&#125; 说明 finally是可选的 使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入到catch中进行异常处理。一旦处理完成，就跳出当前try-catch结构（没有写finally的情况），继续执行其后的代码。 catch中的异常类型如果没有子父类关系，则声明的先后（上下）无所谓；catch中的异常类型如果满足子父类关系，则要求一定先声明子类。否则，报错。 常用的异常对象处理方式： String getMessage() 获取异常信息，返回字符串 printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void。 在try结构中声明的变量，在try结构外无法调用。 如果确实要在外面调用，可以先在try结构上面初始化变量，再在try结构后面调用。 try-catch-finally结构可以嵌套。 体会1：使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现。 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，一定要考虑异常的处理。 12345678910111213141516171819202122232425import org.junit.Test;public class ExceptionTest1 &#123; @Test public void test1() &#123; String str = &quot;123&quot;; str = &quot;abc&quot;; int num = 0; try &#123; num = Integer.parseInt(str); System.out.println(&quot;Hello--1&quot;);//未能执行此语句，因为程序遇到异常后直接抛出异常，停止执行后面的语句，转而执行catch操作，异常被catch解决后程序正常执行，所以后面的hello--2正常显示 &#125;catch(NumberFormatException e) &#123;// System.out.println(&quot;出现数值转换异常了，莫慌……&quot;); //String getMessage():// System.out.println(e.getMessage()); //printStackTrace(): e.printStackTrace(); &#125; System.out.println(num); System.out.println(&quot;Hello--2&quot;); &#125;&#125; try-catch-finally中finally的使用 finally是可选的。 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动地进行手动地进行资源的释放。此时的资源释放，就需要声明在finally中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import org.junit.Test;public class FinallyTest &#123; @Test public void test2() &#123; FileInputStream fis = null; try &#123; File file = new File(&quot;hello1.txt&quot;); fis = new FileInputStream(file);//FileNotFoundException int data = fis.read();//IOException while(data != -1) &#123; System.out.print((char)data); data = fis.read();//IOException &#125;// fis.close();//IOException，将此结构放到finally结构中 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fis != null) fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void testMethod() &#123; int num = method(); System.out.println(num);//先执行finally中的内容，再执行catch中的内容 &#125; public int method() &#123; try &#123; int[] arr = new int[10]; System.out.println(arr[10]); return 1; &#125;catch(ArrayIndexOutOfBoundsException e) &#123; e.printStackTrace(); return 2; &#125;finally &#123; System.out.println(&quot;我一定会被执行&quot;); &#125; &#125; @Test public void test1() &#123; try &#123; int a = 10; int b = 0; System.out.println(a / b); &#125;catch(ArithmeticException e) &#123; e.printStackTrace(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;楼主是真的帅！！！&quot;); &#125; &#125;&#125; 异常处理机制二：throwsthrows + 异常类型 “throws + 异常类型” 写在方法的声明处。指明方法执行时可能会抛出的异常类型。 一旦方法执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时就会被抛出。异常代码后续代码就不再执行。 注意：try-catch-finally：真正将异常处理掉了。 throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 开发中，如何选择使用try-catch-finally还是throws？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后有调用了另外的几个方法，这几个方法时递进关系执行的。则这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/* * 异常处理的方式二：throws + 异常类型 */public class ThrowsTest &#123; public static void main(String[] args) &#123; try&#123; method2(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; method3(); &#125; public static void method3() &#123; try &#123; method2(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void method2() throws IOException&#123; method1(); &#125; public static void method1() throws FileNotFoundException,IOException&#123; File file = new File(&quot;hello.txt&quot;); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while(data != -1) &#123; System.out.print((char)data); data = fis.read(); &#125; fis.close(); &#125;&#125; 方法重写的规则之一：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。 12345678910111213141516171819202122232425262728293031323334import java.io.FileNotFoundException;import java.io.IOException;/* * 方法重写的规则之一： * 子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。 * */public class OverrideTest &#123; public static void main(String[] args) &#123; OverrideTest test = new OverrideTest(); test.display(new SubClass()); &#125; public void display(SuperClass s) &#123; try &#123; s.method(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SuperClass&#123; public void method() throws IOException&#123; &#125;&#125;class SubClass extends SuperClass&#123; public void method() throws FileNotFoundException&#123; &#125;&#125; 手动抛出异常：throw关于异常对象的产生 系统自动生成的异常对象 手动生成一个异常对象，并抛出（throw） 1234567891011121314151617181920212223242526272829303132public class StudentTest &#123; public static void main(String[] args) &#123; try &#123; Student s = new Student(); s.regist(-1001); System.out.println(s); &#125; catch (Exception e) &#123;// e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125;&#125;class Student&#123; private int id; public void regist(int id) throws Exception &#123; if(id &gt; 0) &#123; this.id = id; &#125;else &#123;// System.out.println(&quot;您输入的数据非法！&quot;); //手动抛出一个异常对象// throw new RuntimeException(&quot;您输入的数据非法！&quot;); throw new Exception(&quot;您输入的数据非法！&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;]&quot;; &#125;&#125; 运行结果 用户自定义异常类1234567891011121314151617/* * 如何自定义异常类？ * 1. 继承现有的异常结构：RuntimeException、Exception * 2. 提供全局常量：serialVersionUID * 3. 提供重载构造器 * */public class MyException extends RuntimeException&#123; static final long serialVersionUID = -7034897193246939L; public MyException() &#123; &#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 练习 编写应用程序EcmDef.java，接收命令行的两个参数，要求不能输入负数，计算两数相除。 对数据类型不一致（NumberFormatException）、缺少命令行参数（ArrayIndexOutOfBoundsException）、除以0（ArithmeticException）及输入负数（EcDef自定义的异常）进行处理。 提示： (1) 在主类(EcmDef)中定义异常方法(ecm)完成两数相除功能。 (2) 在main()方法中使用异常处理语句进行异常处理。 (3) 在程序中，自定义对应输入负数的异常类(EcDef)。 (4) 运行时接受参数 java EcmDef 20 10 //args[0]=“20” args[1]=“10”。 (5) Interger类的static方法parseInt(String s)将s转换成对应的int值。 如：int a=Interger.parseInt(“314”); //a = 314 123456789101112package top.triabin._06userdefined.exercise1; /** * 在程序中，自定义对应输入负数的异常类(EcDef)。 */ public class EcDef extends Exception&#123; static final long serialVersionUID = -33875164229948L; public EcDef() &#123;&#125; public EcDef(String msg) &#123; super(msg); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637package top.triabin._06userdefined.exercise1; public class EcmDef &#123; public static void main(String[] args) &#123; try &#123; int i = Integer.parseInt(args[0]); int j = Integer.parseInt(args[1]); double result = ecm(i,j); System.out.println(result); &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;数据类型不一致&quot;); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;缺少命令行参数&quot;); &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;除数为0&quot;); &#125; catch (EcDef e) &#123; System.out.println(e.getMessage()); &#125; &#125; /** * @Description * @author Dawn Lee * @version 1.0 * @data 2020-10-1414:28:48 * * @param i 被除数 * @param j 除数 * @return 商 * @throws EcDef */ public static double ecm(int i,int j) throws EcDef&#123; if(i &lt; 0 || j &lt; 0) &#123; throw new EcDef(&quot;分子或分母为负数了！&quot;); &#125; return i / j; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第八章 多线程 - Java","slug":"Java基础/第八章 多线程","date":"2020-12-11T16:00:00.000Z","updated":"2020-12-14T08:22:20.141Z","comments":true,"path":"undefined/2508.html","link":"","permalink":"https://asteroidcs.github.io/undefined/2508.html","excerpt":"","text":"基本概念：程序、进程、线程基本概念 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡过程。——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静止的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，**每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元/内存地址空间→它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简洁、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 进程与线程 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。 一个Java应用程序java.exe，$\\color{gold}{其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。}$当然如果发生异常，会影响主线程。 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 使用多线程的优点​ 背景：以单核CPU为例，只是用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成的时间要短，为何仍需要多个线程呢？ 提高应用程序的响应。对图形化页面更有意义，可增强用户体验。 提高计算机系统CPU的利用率。 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 何时需要用到多线程？ 程序需要同时执行两个或多个任务 程序要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等 需要一些后台运行的程序时、 线程调的创建和使用 JDK1.5之前创建新执行线程有两种方法： 继承Thread类的方式 实现Runnable接口的方式 线程的创建和启动方式一：继承于Thread类 Java语言的JVM允许程序运行多个线程它通过 java.lang.Thread 类来实现。 $\\color{gold}{Thread类的特性：}$ 每个线程都是通过某个特定的Thread对象的run()方法来操作的，经常把run()方法的主体称为线程体。 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()。 构造器 步骤 创建一个继承于Thread类的子类 重写Thread类的run()方法 –&gt; 将此线程执行的操作声明在run()中 创建Thread子类对象，即创建了线程对象。 调用线程对象start方法：启动线程，调用run方法。 注意点： 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。 想要启动多线程，必须调用start方法。 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。 使用实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * * 例子：遍历100以内所有偶数 * * @author DawnLee * @create 2020-10-21-22:07 *///1、创建一个继承于Thread类的子类class MyThread extends Thread&#123;// 2、重写Thread类的run() @Override public void run() &#123; for (int i = 0;i &lt; 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);//Thread.currentThread().getName()，获取当前线程名称 &#125; &#125; &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; //3、创建Thread类的子类对象 MyThread t1 = new MyThread(); //4、通过对象调用start():①启动当前线程 ②调用当前线程的run()方法 t1.start();// t1.run();// 问题一：不能通过直接调用run()方法的方式启动线程// 问题二：再启动一个线程，遍历100以内的偶数// t1.start();//不可以让已经start()的线程去执行，会报IllegalThreadStateException //需要重新创建一个线程对象// MyThread t2 = new MyThread();// t2.start(); //以下操作仍然是在main线程中执行 for(int i = 0;i &lt; 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;&#125;// 从运行结果可以看出，两个线程的执行结果交替显示，既两个线程并行执行。 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数。 方式一： 123456789101112131415161718192021222324252627282930313233&#x2F;** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * @author DawnLee * @create 2020-10-21-22:52 *&#x2F;public class ThreadDemo &#123; public static void main(String[] args) &#123; new MyThread1().start(); new MyThread2().start(); &#125;&#125;class MyThread1 extends Thread&#123; @Override public void run() &#123; for(int i &#x3D; 0;i &lt; 100;i++)&#123; if(i % 2 &#x3D;&#x3D; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;&#125;class MyThread2 extends Thread&#123; @Override public void run() &#123; for(int i &#x3D; 0;i &lt; 100;i++)&#123; if(i % 2 !&#x3D; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;&#125; 方式二：创建匿名子类 1234567891011121314151617181920212223242526272829303132Javapackage top.triabin._01.exer1;/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * @author DawnLee * @create 2020-10-21-22:52 */public class ThreadDemo &#123; public static void main(String[] args) &#123; new Thread()&#123; @Override public void run() &#123; for(int i = 0;i &lt; 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; for(int i = 0;i &lt; 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; Thread类的常用方法 void start()：启动线程并执行对象的run()方法。 run()：线程在被调度时执行的操作。 String getName()：返回线程的名称。 void setName(String name)：设置该线程名称。 static Thread courrentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和runnable实现类。 static void yield()：线程让步 ① 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。 ② 若队列中没有同优先级的线程，忽略此方法。 join()：当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止。 低优先级的线程也可以获得执行 static void sleep(long millis)：（指定时间：毫秒） ① 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队。 ② 抛出InterruptedException异常 stop()：已过时。强制结束线程生命周期，不推荐使用。 boolean isAlive()：返回booleean，判断线程是否还活着。 线程的调度 调度策略 时间片 抢占式：高优先级的线程抢占CPU。 Java的调度方法 同优先级线程组成先进先出队列（先到服务），使用时间片策略。 对高优先级，使用优先调度的抢占式策略。 线程的优先级 线程的优先等级(1~10) ① MAX_PRIORITY：10 → 最大优先级(Thread.MAX_PRIORITY == 10) ② MIN_PRIORITY：1 → 最小优先级(Thread.MIN_PRIORITY == 1) ③ NORM_PRIORITY：5 → 默认优先级 涉及的方法 ① getPriority()：返回线程优先级 ② setPriority(int newPriority)：改变线程的优先级 说明 ① 线程创建时继承父线程的优先级 ② $\\color{gold}{低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。}$ 线程的创建和启动方式二：实现Runnable接口 定义子类，实现Runnable接口。 子类中重写Runnable接口中的run方法。 通过Thread类含参构造器创建线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 1234567891011121314151617181920212223242526272829303132333435363738/** * * 例子：遍历100以内的所有偶数 * * @author DawnLee * @create 2020-10-23 22:18 *///1、创建一个实现Runnable接口的类class MThread implements Runnable&#123; //2、实现类去实现Runnable中的抽象方法：run() @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;&#125;public class ThreadTest1&#123; public static void main(String[] args) &#123; //3、创建实现类的对象 MThread mThread = new MThread(); //4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); //5、通过Thread类的对象调用start() t1.setName(&quot;线程1&quot;); t1.start(); //再启动一个线程，遍历100以内的偶数 Thread t2 = new Thread(mThread); t2.setName(&quot;线程2&quot;); t2.start(); &#125;&#125; 两种方式比较 开发中：优先选择实现Runnable接口的方式 原因： 实现Runnable接口的方式没有单继承的局限性 实现的方式更适合来处理多个线程有共享数据的情况 联系：public class Thread implements Runnable（Thread类本身也实现了Runnable接口） 相同点：两种方式都需要重写run()方法，将线程要执行的逻辑声明在run()中。 补充：线程的分类​ Java中，线程分为两类：一种是守护线程，一种是用户线程。 它们几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用Thread.setDaemon(true)可以把一个用户线变成一个守护线程。 Java垃圾回收站就是一个典型的守护线程。 若JVM中都是守护线程，当前JVM将退出。 线程的生命周期 JDK中用Thread.State类定义了线程的几种状态： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED;&#125; ​ 想要实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能。 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。 线程的同步​ 例子：创建三个窗口卖票，总票数为100张，现使用Runnable接口的方式 问题：卖票过程中，出现了重票、错票 –&gt; 出现了线程的安全问题。 问题出现的原因：当年某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 如何解决：当线程a在操作ticket（共享数据）的时候，其他线程不能参与进来，直到线程a操作完ticket，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 在Java中，通过同步机制来解决线程的安全问题。 方式一：同步代码块 方式二：同步方法 方式一：同步代码快123synchronized(同步监视器)&#123; //需要被同步的代码&#125; 说明： ​ ① 操作共享数据的代码，即为需要被同步的代码 ​ ② 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据 ​ ③ 同步监视器，俗称：锁。任何一个类的对象都可以充当锁。 $\\color{red}{要求：}$多个线程必须共用同一把锁。 补充： 在实现Runnable接口创建多线程的方式中，可以考虑使用this充当同步监视器；在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类(类名.class)充当同步监视器。 使用同步代码块解决实现Runnable接口中的线程安全问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 例子：创建三个窗口卖票，总票数为100张，现使用Runnable接口的方式 * * 使用同步代码块解决实现Runnable接口的线程安全问题。 * * @author DawnLee * @create 2020-10-24 12:57 */public class WindowTest &#123; public static void main(String[] args) &#123; Window window = new Window(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window implements Runnable&#123; private int ticket = 100;// Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized(this)&#123;//此时的this：唯一的Window的对象 //synchronized(obj) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;: 卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 使用代码块解决继承Thread类的线程安全问题 与1相似，只需将同步监视器改为 当前类.class 即可。 同步小结： 同步的方式解决了线程的安全问题。（好处） 操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程过程，效率低。（局限性） 方式二：同步方法​ 如果操作共享数据的代码完整的声明在一个方法中，可将此方法声明为同步的。 使用同步方法解决实现Runnable接口中的线程安全问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Javapackage top.triabin._04threadsyn;/** * 使用同步方法来解决实现Runnable接口的线程安全问题 * * @author DawnLee * @create 2020-10-24 14:30 */public class WindowTest2 &#123; public static void main(String[] args) &#123; Win win = new Win(); Thread w1 = new Thread(win); Thread w2 = new Thread(win); Thread w3 = new Thread(win); w1.setName(&quot;窗口1&quot;); w2.setName(&quot;窗口2&quot;); w3.setName(&quot;窗口3&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125;class Win implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while(true)&#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;: 卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125; 使用同步方法处理继承Thread类的方式中的线程安全问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Javapackage top.triabin._04threadsyn;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * * @author DawnLee * @create 2020-10-24 14:46 */public class WindowTest3 &#123; public static void main(String[] args) &#123; Win2 w1 = new Win2(); Win2 w2 = new Win2(); Win2 w3 = new Win2(); w1.setName(&quot;窗口1&quot;); w2.setName(&quot;窗口2&quot;); w3.setName(&quot;窗口3&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125;class Win2 extends Thread&#123; private static int ticket = 100; @Override public void run() &#123; while(true)&#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Win2.class // private synchronized void show()&#123;//同步监视器：w1,w2,w3，此种解决方法是错误的 if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;: 卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125; 关于同步方法的总结： 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this； 静态的同步方法，同步监视器是：当前类本身。 使用同步机制将单例模式中的懒汉式改写为线程安全的1234567891011121314151617181920212223242526272829303132333435package top.triabin._04threadsyn.lazysingletion;/** * 使用同步机制将单例模式中的懒汉式改写为线程安全的 * * @author DawnLee * @create 2020-10-24 15:47 */public class BankTest &#123;&#125;class Bank&#123; private Bank()&#123;&#125; private static Bank instance = null; public static Bank getInstance()&#123; //方式一：效率稍差// synchronized (Bank.class) &#123;// if(instance == null)&#123;// instance = new Bank();// &#125;// return instance;// &#125; //方式二：效率更高 if(instance == null)&#123; synchronized(Bank.class)&#123; if(instance == null)&#123; instance = new Bank(); &#125; &#125; &#125; return instance; &#125;&#125; 线程的死锁问题 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。 **解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 演示线程的死锁问题 * * @author DawnLee * @create 2020-10-24 22:17 */public class DeadLockTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized(s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 方式三：Lock(锁) — JDK5.0新增 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock 是控制多个线程共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 ReentrantLook类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁 步骤： 实例化ReentrantLock 调用锁定方法lock() 调用解锁方法unlock() 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package top.triabin._04threadsyn;import java.util.concurrent.locks.ReentrantLock;/** * 解决线程安全问题的方式三：Lock锁 --- JDK 5.0新增 * * @author DawnLee * @create 2020-10-24 22:44 */class Windows implements Runnable&#123; private int ticket = 100; //1、实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while(true)&#123; try &#123; //2、调用锁定方法lock() lock.lock(); if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;: 售票，票号为：&quot; + ticket--); &#125; else &#123; break; &#125; &#125;finally&#123; //3、调用解锁方法unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Windows windows = new Windows(); Thread w1 = new Thread(windows); Thread w2 = new Thread(windows); Thread w3 = new Thread(windows); w1.setName(&quot;窗口1&quot;); w2.setName(&quot;窗口2&quot;); w3.setName(&quot;窗口3&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; synchronized 与 Lock 的对比 同：二者都可解决线程安全问题 异：synchronized机制在执行完相应的同步代码块以后，自动的释放同步监视器；Lock需要手动的启动同步（lock()）和手动结束同步（unlock()）。 优先使用顺序：Lock → 同步代码块（已经进入了方法体，分配了相应资源） → 同步方法（在方法体之外 面试题：如何解决线程安全问题？有几种方式？ 练习​ 银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 ​ 问题：该程序是否有安全问题，如果有，如何解决？ 【提示】 明确哪些代码是多线程运行代码，须写入run()方法。 明确什么是共享数据。 明确多线程运行代码中哪些语句是操作共享数据的。 拓展问题：可否实现两个储户交替存钱的操作？ 分析： 是否是多线程问题？ 是，两个储户 是否有共享数据？ 有，账户（或账户余额） 是否有线程安全问题？ 有 需要考虑如何解决线程安全问题？ 同步机制：有三种方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package top.triabin._04threadsyn.exer;/** * 银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 * 问题：该程序是否有安全问题，如果有，如何解决？ * * @author DawnLee * @create 2020-10-24 23:21 */class Account&#123; private double balance; public Account(double balance) &#123; this.balance = balance; &#125; //存钱 public synchronized void deposit(double amt)&#123; if(amt &gt; 0)&#123; balance += amt; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;存钱成功。余额为：&quot; + balance); &#125; &#125;&#125;class Customer extends Thread&#123; private Account acct; public Customer(Account acct)&#123; this.acct = acct; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; acct.deposit(1000); &#125; &#125;&#125;public class AccountTest &#123; public static void main(String[] args) &#123; Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(&quot;甲&quot;); c2.setName(&quot;乙&quot;); c1.start(); c2.start(); &#125;&#125; 线程的通信线程通信实例：使用两个线程交替打印1-100涉及到的三个方法： wait(): 一旦执行此方法，当前线程就进入阻塞状态。并释放同步监视器。 notify(): 一旦执行习方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 说明： 上述三个方法必须使用在同步代码块或同步方法中。 三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常。 三个方法定义在java.lang.Object类中。 面试题：sleep()和wait()的异同？ 相同点：一旦执行方法，都可以使当前线程进入阻塞状态。 不同点：1）两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()； 调用的范要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中； 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，而wait()会。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package top.triabin._05threadcommunication.example;/** * 线程通信实例：使用两个线程交替打印1-100。 * * @author DawnLee * @create 2020-10-24 23:53 */class Number implements Runnable&#123; private int number = 1; @Override public void run() &#123; while(true)&#123; synchronized (this) &#123; notify(); if(number &lt;= 100)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number++); try &#123; //使得调用如下wait()方法的线程进入阻塞状态 wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 经典例题：生产者/消费者问题 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如人：20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 这里可能出现两个问题： 生产者比消费者快时，消费者会漏掉一些数据没有取到。 消费者比生产者快时，消费者会取相同的数据。 分析： 是否是多线程问题？ 是，生产者线程，消费者线程 是否有共享数据？ 是，店员（或产品） 如何解决线程的安全问题？ 同步机制，有三种方法 是否涉及到线程的通信？ 是 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package top.triabin._05threadcommunication.exer;/** * 经典例题：生产者/消费者问题 * * @author DawnLee * @create 2020-10-25 19:54 */class Clerk&#123; private int productCount = 0; //生产产品 public synchronized void produceProduct() &#123; if(productCount &lt; 20)&#123; System.out.println(Thread.currentThread().getName() + &quot;开始生产第&quot; + ++productCount + &quot;个产品&quot;); notify(); &#125;else&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //消费产品 public synchronized void consumeProduct() &#123; if(productCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;开始消费第&quot; + productCount-- + &quot;个产品&quot;); notify(); &#125;else&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Producer extends Thread&#123;//生产者 private Clerk clerk; public Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(getName() + &quot;: 开始生产产品……&quot;); while(true)&#123; clerk.produceProduct(); &#125; &#125;&#125;class Customer extends Thread&#123;//消费者 private Clerk clerk; public Customer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(getName() + &quot;: 开始消费产品……&quot;); while(true)&#123; clerk.consumeProduct(); &#125; &#125;&#125;public class ProductTest &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(&quot;生产者1&quot;); Customer c1 = new Customer(clerk); c1.setName(&quot;消费者1&quot;); p1.start(); c1.start(); &#125;&#125; JDK5.0新增线程创建方式新增方式一：实现Callable接口步骤： 创建一个Callable接口的实现类； 重写call()方法，将此线程需要执行的操作声明在call()方法中; 创建Callable接口实现类的对象; 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask类的对象; 将FutureTask类的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法; 获取Callable中call()方法的返回值。（如果需要） 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以有返回值。 call()可以抛出异常，被外面的操作捕获，获取异常信息。 Callable支持泛型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package top.triabin._06newway;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * 创建线程的实现方式三：实现Callable接口 --- JDK 5.0新增 * * 例子：遍历100以内的偶数，并返回偶数和。 * * @author DawnLee * @create 2020-10-25 20:32 *///1、创建一个Callable接口的实现类class NumThread implements Callable &#123; //2、重写call()方法，将此线程需要执行的操作声明在call()方法中 @Override public Object call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(i); sum += i; &#125; &#125; return sum; &#125;&#125;public class ThreadNew &#123; public static void main(String[] args) &#123; //3、创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4、将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask类的对象 FutureTask futureTask = new FutureTask(numThread); //5、将FutureTask类的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法 new Thread(futureTask).start(); try &#123; //6、获取Callable中call()方法的返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(&quot;总和为：&quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 新增方式二：使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 便于线程管理： ① corePoolSize：核心池的大小 ② maximumPoolSize：最大线程数 ③ keepAliveTime：线程没有任务时最多保持多长时间后会终止 线程池相关API： JDK 5.0起提供了线程池相关的API：ExecutorService和Excutors。 ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor。 ① void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable； ② Future submit(Callable task)：执行任务，有返回值，一般用来执行Callable； ③ void shutdown()：关闭连接池。 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。 ① Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池； ② Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池； ③ Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池； ④ Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期运行。 1234567891011121314151617181920212223242526272829303132333435363738394041package top.triabin._06newway;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 创建线程的方式四：使用线程池 * * 面试题：创建多线程有几种方式？ 4种 * * @author DawnLee * @create 2020-10-29 16:35 */class NumberThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1、提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //设置线程池的属性 System.out.println(service.getClass()); //2、执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适用于Runnable// service.submit(Callable callable);//适用于Callable //3、关闭线程池 service.shutdown(); &#125;&#125; 知识点问答sleep()和wait()的区别。123两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()；调用的范要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中；关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，而wait()会。 创建多线程有哪几种方式？1234继承Thread类实现Runnable接口实现Callable接口线程池：提高响应速度，提高了资源的重用率，便于管理 Java中有几种方法可以实现一个线程(jdk5.0之前)？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？123答：有两种实现方法，分别是继承Thread类与实现Runnable接口，使用synchronized关键字修饰同步方法。反对使用stop()方法，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们，结果很难检查出真正的问题所在。反对使用suspend()方法，是因为它容易发生死锁。调用suspend()方法的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定，此时，其他任何线程都不能访问锁定的资源，就会造成死锁。所以不应该使用suspend()，而应该在自己的Thread类中置入一个标志，指出线程应该活动还是挂起，便用wait()命令其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 同步和异步有何异同，在什么情况下分别使用他们？举例说明。12答：如果数据将在线程间共享，例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法返回时，就应该使用异步编程，在很多情况下采用异步编程往往更有效率。 启动一个线程是用run()还是start()？1答：启动一个线程是调用start()方法，使线程所代表的的虚拟机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法就是正常的对象调用方法的执行，并不是使用分线程来执行的。 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?1答：不能，一个对象的synchronized方法只能由一个线程访问。 请说出你所知道的线程同步的方法。1234567wait()：使一个线程处于等待状态，并释放所有对象的lock。②sleep()：使一个正在运行的线程处于睡眠状，是一个静态方法，调用此方法要捕捉InterruptedException异常。③notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候并不能确切地唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。④notifyAll()：唤醒所有处于等待状态的线程，注意并不是给所有线程一个对象的锁，而是让它们竞争。 多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？1答：实现方法有两种，分别是继承Thread类与实现Runnable接口；同步的实现方面有两种，分别是synchronized与wait-notify。 简述synchronized和java.util.concurrent.locks.Lock的异同？123相同点：Lock能完成synchronized所实现的所有功能。不同点：Lock有比synchronized更精准的线程语义和性能。synchronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally语句中释放。","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"第六章 面向对象（下）","slug":"Java基础/第六章 面向对象（下）","date":"2020-12-11T16:00:00.000Z","updated":"2020-12-12T02:33:15.518Z","comments":true,"path":"undefined/d5b3.html","link":"","permalink":"https://asteroidcs.github.io/undefined/d5b3.html","excerpt":"","text":"关键字：staticstatic关键字的使用 static：静态的。 可以用来修饰：属性、方法、代码块、内部类。 ==使用static来修饰属性:静态变量== 属性：按是否使用是static修饰，又分为静态属性和非静态属性（实例变量） ==实例变量==：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样属性值的修改。 ==静态变量==：我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用次静态变量时，是修改过的。 static修饰属性的其他说明： 静态变量随着类的加载而加载，可以通过“类.静态变量”的方式调用； 静态变量的加载要早于对象的创建； 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 ==使用static来修饰方法：静态方法== 随着类的加载而加载，可以通过“类.静态方法”的方式进行调用; 静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用静态的方法或属性，也可以调用非静态的方法或属性。 static注意点： 在静态方法内不能使用this关键字和super关键字; 关于静态属性和静态方法的使用，都从生命周期的角度去解释。 开发中，如何确定一个属性是否要声明为static的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static。 开发中，如何确定一个方法是否要声明为static的？ 操作静态属性的方法,通常设置为static的； 工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections。 代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package top.triabin._01static;/* * static关键字的使用：代码示例 */public class StaticTest &#123; @SuppressWarnings(&quot;static-access&quot;) public static void main(String[] args) &#123; Chinese.nation = &quot;中国&quot;; Chinese c1 = new Chinese(); System.out.println(&quot;通过“类.静态变量”的方式赋值的静态变量：&quot; + c1.nation); c1.name = &quot;姚明&quot;; c1.age = 40; c1.nation = &quot;CHN&quot;; Chinese c2 = new Chinese(); c2.name = &quot;马龙&quot;; c2.age = 30; System.out.println(c1.nation + &quot; \\t&quot; +c2.nation );//CHN CHN c2.nation = &quot;CHINA&quot;; System.out.println(c1.nation + &quot;\\t&quot; +c2.nation);//CHINA CHINA // Chinese.name = &quot;张继科&quot;;//编译不通过，不能使用类去调用非静态属性 c1.eat(); Chinese.show(); // Chinese.eat();//编译不通过，不能使用类去调用非静态方法 &#125;&#125;class Chinese&#123; String name; int age; static String nation; public void eat() &#123; System.out.println(&quot;中国人吃中餐&quot;); //调用非静态结构 this.info(); System.out.println(&quot;name: &quot; + name); //调用静态结构 walk(); System.out.println(&quot;nation: &quot; + Chinese.nation); &#125; public static void show() &#123; System.out.println(&quot;我是一个中国人！&quot;);// eat();//静态方法中，只能调用静态的方法或属性// name = &quot;Triabin&quot; System.out.println(Chinese.nation);//可以调用静态的属性或方法，属性前可以省略了“类名.”（Chinese.） &#125; public void info() &#123; System.out.println(&quot;name: &quot; + name + &quot;,age: &quot; + age); &#125; public static void walk() &#123;&#125;&#125; 结果： 应用举例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CircleTest &#123; public static void main(String[] args) &#123; Circle c1 = new Circle(); Circle c2 = new Circle(); Circle c3 = new Circle(3.4); System.out.println(&quot;c1的id：&quot; + c1.getId()); System.out.println(&quot;c2的id：&quot; + c2.getId()); System.out.println(&quot;c3的id：&quot; + c3.getId()); System.out.println(&quot;创建圆的个数为：&quot; + Circle.getTotal()); &#125;&#125;class Circle&#123; private double radius; private int id; private static int total;//记录创建圆的个数 private static int init = 1001;//static声明的属性被所有对象所共享 public Circle() &#123; id = init++; total++; &#125; public Circle(double radius) &#123; this(); this.radius = radius; &#125; public double findArea() &#123; return Math.PI * radius * radius; &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; public int getId() &#123; return id; &#125; public static int getTotal() &#123; return total; &#125;&#125; 结果 单例（Singleton）设计模式 设计模式是在$\\color{red}{大量的实践中总结和理论化之后优选的代码结构、编程风格、 以及解决问题的思考方式。}$设计模免去我们自己再思考和摸索。就像是经典 的棋谱，不同的棋局，我们用不同的棋谱。”套路” 设计模式： 创建型模式，共5种：工厂方法模式、抽象工厂模式、$\\color{red}{单例模式}$、创造者模式、原型模式； 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式； 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 PS：设计模式是独立于语言之外的，就像数据结构与算法。 单例设计模式只是上述设计模式中的一种。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。 如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。 $\\color{red}{如何实现？}$ 饿汉式实现 坏处：直接加载对象，对象加载时间过长； 好处：饿汉式是线程安全的。 1234567891011121314151617181920212223public class SingletonTest1 &#123; public static void main(String[] args) &#123; Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2);//true &#125;&#125;//饿汉式class Bank &#123; //1. 私有化类的构造器 private Bank() &#123;&#125; //2. 内部创建类的对象 //4. 此对象必须声明为static的 private static Bank instance = new Bank(); //3. 提供公共的静态的方法，返回类的对象 public static Bank getInstance() &#123; return instance; &#125;&#125; 懒汉式实现 好处：到需要时才加载对象，延迟对象的创建； 目前写法坏处：线程不安全。—&gt; 到多线程内容时再修改 12345678910111213141516171819202122232425public class SingletonTest2 &#123; public static void main(String[] args) &#123; Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2);//true &#125;&#125;class Order&#123; //1. 私有化类的构造器 private Order() &#123;&#125; //2. 声明当前类对象没有初始化 //4. 此对象也必须声明为static的 private static Order instance = null; //3. 声明public、static的返回当前类对象的方法 public static Order getInstance() &#123; if(instance == null) &#123; instance = new Order(); &#125; return instance; &#125;&#125; 单例模式的优点：由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 $\\color{gold}{单例设计模式应用场景}$ $\\color{blue}{网站的计数器}$，一般也是单例模式实现，否则难以同步。 $\\color{blue}{应用程序的日志应用}$，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 $\\color{blue}{数据库连接池)$的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 项目中，$\\color{blue}{读取配置文件的类}$，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。 $\\color{blue}{Application也是单例的典型应用}$。 Windows的$\\color{blue}{Task Manager(任务管理器)}$就是很典型的单例模式。 Windows的$\\color{blue}{Recycle Bin (回收站)}$也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 练习题 编写一个类实现银行账户的概念，包含的属性有“账号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。账号要自动生成。 编写主类，使用银行账户类，输入、输出3个储户的上述信息。 考虑：哪些属性可以设计成static属性。 Account类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package top.triabin._01exercise1;/* * 课后练习题1：Account类 * 编写一个类实现银行账户的概念，包含的属性有“账号”、“密码”、“存款余额”、“利率”、 * “最小余额”，定义封装这些属性的方法。账号要自动生成。 */public class Account &#123; private int id; private String pwd = &quot;000000&quot;; private double balance; private static double interestRate; private static double minBalance = 1.0; private static int iterId = 1001; private static int total; public Account() &#123; id = iterId++; total++; &#125; public Account(String pwd,double balance) &#123; this(); this.pwd = pwd; this.balance = balance; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public static double getInterestRate() &#123; return interestRate; &#125; public static void setInterestRate(double interestRate) &#123; Account.interestRate = interestRate; &#125; public static double getMinBalance() &#123; return minBalance; &#125; public static void setMinBalance(double minBalance) &#123; Account.minBalance = minBalance; &#125; public int getId() &#123; return id; &#125; public static int getTotal() &#123; return total; &#125; @Override public String toString() &#123; return &quot;Account [id=&quot; + id + &quot;, pwd=&quot; + pwd + &quot;, balance=&quot; + balance + &quot;]&quot;; &#125;&#125; 主类Bank 12345678910111213141516171819202122package top.triabin._01exercise1;/* * 课后练习题1主类：Bank、 * 编写主类，使用银行账户类，输入、输出3个储户的上述信息。 */public class Bank &#123; public static void main(String[] args) &#123; Account a1 = new Account(); a1.setBalance(201314); Account a2 = new Account(&quot;quqian&quot;,2000); Account a3 = new Account(&quot;123455&quot;,1314); Account.setInterestRate(3.5); Account.setMinBalance(100); System.out.println(a1); System.out.println(a2); System.out.println(a3); System.out.println(&quot;最小余额 = &quot; + Account.getMinBalance()); System.out.println(&quot;账户数量 = &quot; + Account.getTotal()); System.out.println(&quot;利率 = &quot; + Account.getInterestRate()); &#125;&#125; 结果 理解main方法的语法main()方法的使用说明 main()作为程序的入口。 main()方法也是一个普通的静态方法。 1234567891011121314151617package top.triabin._02main;public class MainTest &#123; public static void main(String[] args) &#123; Main.main(new String[100]); &#125;&#125;class Main&#123; public static void main(String[] args) &#123; args = new String[100]; for(int i = 0;i &lt; args.length;i++) &#123; args[i] = &quot;args_&quot; + i; System.out.println(args[i]); &#125; &#125;&#125; 运行时会询问将哪一个main()方法作为程序入口 main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner） 12345678910111213package top.triabin._02main;/* * main()方法与控制台交互示例代码 */public class MainInteract &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; args.length;i++) &#123; System.out.println(&quot;String型：&quot; + args[i]); int num = Integer.parseInt(args[i]); System.out.println(&quot;int型：&quot; + num); &#125; &#125;&#125; 类的成员之四：代码块基本概念和作用 代码块的作用：用来初始化类、对象。 代码块如果有修饰，只能是static。 分类：静态代码块、非静态代码块。 静态代码块： 内部可以有输出语句 随着类的加载而执行，而且只执行一次 作用：初始化类信息 如果一个类中定义了多个代码块，则按照声明的先后顺序执行 静态代码块的执行优于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块： 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性进行初始化 非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package top.triabin._03codeblock;/* * 类的成员之四：代码块 * * 1. 代码块的作用：用来初始化类、对象。 * 2. 代码块如果有修饰，只能是static。 * 3. 分类：静态代码块、非静态代码块 * * 4. 静态代码块 * * 5. 非静态代码块 * */public class BlockTest &#123; public static void main(String[] args) &#123; String descr = Person.descr; System.out.println(descr); Person p1 = new Person(); @SuppressWarnings(&quot;unused&quot;) Person p2 = new Person(); System.out.println(p1.age); Person.info(); &#125;&#125;class Person&#123; //属性 String name; int age; static String descr = &quot;我是一个人&quot;; //构造器 public Person() &#123;&#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; //代码块 //static代码块 static &#123; System.out.println(&quot;hello,static block_1!&quot;); //调用静态结构 descr = &quot;我是一个爱学习的人1&quot;; info();// eat();// name = &quot;Triabin&quot;;//不能调用非静态结构 &#125; static &#123; System.out.println(&quot;hello,static block_2!&quot;); &#125; //非static代码块 &#123; System.out.println(&quot;hello,block!&quot;); //调用非静态结构 age = 1; eat(); //调用静态结构 descr = &quot;我是一个爱学习的人&quot;; info(); &#125; //方法 public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; public static void info() &#123; System.out.println(&quot;我是一个快乐的人&quot;); &#125;&#125; 应用举例 先父后子，静态先行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 package top.triabin._03codeblock; //总结：先父后子，静态先行 class Root&#123; static&#123; System.out.println(&quot;Root的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Root的普通初始化块&quot;); &#125; public Root()&#123; System.out.println(&quot;Root的无参数的构造器&quot;); &#125; &#125; class Mid extends Root&#123; static&#123; System.out.println(&quot;Mid的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通初始化块&quot;); &#125; public Mid()&#123; System.out.println(&quot;Mid的无参数的构造器&quot;); &#125; public Mid(String msg)&#123; //通过this调用同一类中重载的构造器 this(); System.out.println(&quot;Mid的带参数构造器，其参数值：&quot; + msg); &#125; &#125; class Leaf extends Mid&#123; static&#123; System.out.println(&quot;Leaf的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通初始化块&quot;); &#125; public Leaf()&#123; //通过super调用父类中有一个字符串参数的构造器 super(&quot;尚硅谷&quot;); System.out.println(&quot;Leaf的构造器&quot;); &#125; &#125; public class LeafTest&#123; public static void main(String[] args)&#123; new Leaf(); System.out.println(); new Leaf(); &#125;&#125; 对属性可以赋值的位置总结： 默认初始化 显示初始化 构造器中初始化 有了对象以后，可以通过“对象.属性”或“对象.方法”的方式，进行赋值 在代码块中赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④，②和⑤谁写在前面就先执行谁。 关键字：final基本概念和使用 final可以用来修饰的结构：类、方法、变量 $\\color{gold}{final用来修饰一个类}$：此类不能被其他类继承。 比如：String类、System类、StringBuffer类 $\\color{gold}{final用来修饰方法}$：表明此方法不可以被重写。 比如：Object类中的getClass() $\\color{gold}{final用来修饰变量}$：此时的”变量“就称为是一个常量 final修饰属性：可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化 final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不能重新赋值。 static final用来修饰属性：全局常量 static final用来修饰方法：不可重写的静态方法 练习题 面试题：排错 123456789101112131415161718192021public class Something&#123; public int addOne(final int x)&#123; return ++x;//错误 //return x + 1; &#125;&#125;public class Something&#123; public static void main(String[] args)&#123; Other o = new Other(); new Something().addOne(o); &#125; public void addOne(final Other o)&#123; //o = new Other();//错误 o.i++; &#125;&#125;class Other&#123; public int i;&#125; 抽象类与抽象方法概念： 随着继承层次的中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫抽象类。 abstract关键字的使用 abstract可以用来修饰：类、方法。 abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作 abstract修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。 若子类重写了父类中所有抽象方法后，此子类可实例化 若子类没有重写父类中所有抽象方法，则次子类也是一个抽象类，需要使用abstract修饰 abstract使用上的注意点： abstract不能用来修饰：属性、构造器等结构 abstract不能用来修饰私有方法、静态方法、final的方法 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package top.triabin._05abstract;/* * abstract关键字的使用： * 1. abstract：抽象的 * 2. abstract可以用来修饰：类、方法 * 3. abstract修饰类：抽象类 * 4. abstract修饰方法：抽象方法 * 5. abstract使用上的注意点： */public class AbstractTest &#123; public static void main(String[] args) &#123; //一旦Person类抽象了，就不可实例化// Person p1 = new Person();//Cannot instantiate the type Person// p1.eat(); &#125;&#125;abstract class Person&#123; String name; int age; public Person() &#123;&#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; //不是抽象方法// public void eat() &#123;//// &#125; //抽象方法 public abstract void eat(); public void walk() &#123; System.out.println(&quot;人走路&quot;); &#125;&#125;class Student extends Person&#123; public Student(String name,int age) &#123; super(name,age); &#125; @Override public void eat() &#123; // TODO Auto-generated method stub //必须重写父类中所有的抽象方法，否则子类无法实例化 &#125;&#125; 抽象类的匿名子类12345678910111213141516171819202122232425262728/* * Person为抽象类、Person的eat()和breath()为抽象方法 *///……//创建匿名子类的对象：pPerson p = new Person()&#123; @Override public void eat()&#123; // TODO Auto-generated method stub &#125; @Override public void breath()&#123; // TODO Auto-generated method stub &#125; method(p);&#125;//创建匿名子类的匿名对象method(new Person()&#123; @Override public void eat()&#123; // TODO Auto-generated method stub &#125; @Override public void breath()&#123; // TODO Auto-generated method stub &#125;&#125;); 多态的应用：模板方法设计模式（TemplateMethod） 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。 解决的问题： 当功能内部的一部分实现是确定的，一部分实现是不确定的。这时可以吧不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。 举例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 抽象类的应用：模板方法的设计模式 * * */public abstract class TemplateTest &#123; public static void main(String[] args) &#123; Template t = new SubTemlate(); t.spendTime(); &#125;&#125;abstract class Template&#123; /** * * @Description 计算某段代码执行所需要花费的时间 * @author Dawn Lee * @version 1.0 * @data 2020-8-2416:07:07 * */ public void spendTime() &#123; long start = System.currentTimeMillis(); code();//不确定的部分，易变的部分 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (start - end)); &#125; public abstract void code();&#125;class SubTemlate extends Template&#123; private int count = 0; @Override public void code() &#123; for(int i = 2;i &lt;= 1000;i++) &#123; boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++) &#123; if(i % j == 0) &#123; isFlag = false; break; &#125; &#125; if(isFlag) &#123; System.out.print(i + &quot; &quot;); count += 1; if(count == 10) &#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125;&#125; 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet/doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 练习题 编写一个Employee类，声明为抽象类，包含如下三个属性： name，id，salary。 提供必要的构造器和抽象方法：work()。 对于Manager类来说，他既是员工，还具有奖金（bonus）的属性。请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * * @Description 编写一个Employee类，声明为抽象类，包含如下三个属性： * name，id，salary。 * 提供必要的构造器和抽象方法：work()。 * @author DawnLee * @version 1.0 * @data 2020-8-24 9:59:51 * */abstract public class Employee &#123; private String name;//姓名 private int id;//工号 private double salary;//薪资 public Employee() &#123; super(); &#125; public Employee(String name, int id, double salary) &#123; super(); this.name = name; this.id = id; this.salary = salary; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public abstract void work();&#125; 1234567891011121314151617181920212223242526/* * 对于Manager类来说，他既是员工，还具有奖金（bonus）的属性。 */public class Manager extends Employee &#123; private double bonus;//奖金 public Manager(double bonus) &#123; super(); this.bonus = bonus; &#125; public Manager(String name,int id,double salary,double bonus) &#123; super(name,id,salary); this.bonus = bonus; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public double getBonus() &#123; return bonus; &#125; @Override public void work() &#123; System.out.println(&quot;管理员工，提高公司的运行效率&quot;); &#125;&#125; 12345678package top.triabin._05exercise1;public class CommonEmployee extends Employee &#123; @Override public void work() &#123; System.out.println(&quot;员工在一线车间生产产品&quot;); &#125;&#125; 12345678910111213package top.triabin._05exercise1;/* * 请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。 */public class EmployeeTest &#123; public static void main(String[] args) &#123; Employee manager = new Manager(&quot;库克&quot;,1001,5000,50000); manager.work(); CommonEmployee commonEmployee = new CommonEmployee(); commonEmployee.work(); &#125;&#125; 接口（interface）概述 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。 接口的本质是契约，标准，规范，就像法律一样。指定好后大家都要遵守。 举例 接口的使用 使用interface来定义。 在Java语言中，接口和类是并列的两个结构。 如何定义接口：定义接口中的成员 ① JDK7以前：只能定义全局常量和抽象方法 全局常量：public static final的，但是书写时可以省略不写 抽象方法：public abstract的 ② JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。（暂略） 接口中不能定义构造器，意味着接口不可以实例化。 Java开发中，接口通过让类去实现(implements)的方式来使用。 如果实现类覆盖了接口中所有抽象方法，则次实现类可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。 Java类可以实现说个接口 —&gt; 弥补了Java单继承性的局限性。 格式：class AA extends BB implements CC,DD,EE,…{} 先写继承，后写实现。 接口与接口之间可以继承，而且可以多继承。 接口的具体使用体现多态性。 接口实际上可以看做是一种规范。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * 接口的使用 */public class InterfaceTest &#123; public static void main(String[] args) &#123; System.out.println(Flyable.MAX_SPEED); System.out.println(Flyable.MIN_SPEED);// Flyable.MIN_SPEED = 2;//The final field Flyable.MIN_SPEED cannot be assigned Plane plane = new Plane(); plane.fly(); &#125;&#125;interface Flyable&#123; //全局常量 public static final int MAX_SPEED = 7900;//第一宇宙速度 int MIN_SPEED = 1;//省略了public static final //抽象方法 public abstract void fly(); void stop();//省略了public abstract // public Flyable() &#123;// //Interfaces cannot have constructors// &#125;&#125;interface Attackable&#123; &#125;class Plane implements Flyable&#123; @Override public void fly() &#123; System.out.println(&quot;通过引擎起飞&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;驾驶员减速停止&quot;); &#125;&#125;abstract class Kite implements Flyable&#123; @Override public void fly() &#123; // TODO Auto-generated method stub &#125;&#125;class Bullet extends Object implements Flyable,Attackable,CC&#123; @Override public void fly() &#123; // TODO Auto-generated method stub &#125; @Override public void stop() &#123; // TODO Auto-generated method stub &#125; @Override public void method1() &#123; // TODO Auto-generated method stub &#125; @Override public void method2() &#123; // TODO Auto-generated method stub &#125;&#125;//************************************interface AA&#123; void method1();&#125;interface BB&#123; void method2();&#125;interface CC extends AA,BB&#123; //多继承&#125; 面试题：抽象类与接口有哪些异同？ 应用举例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * 接口的使用 * 1. 接口使用上也满足多态。 * 2. 接口，实际上就是定义了一种多态。 * 3. 开发中，体会面向接口编程。 */public class USBTest &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); //1. 创建了接口的非匿名实现类的非匿名对象 Flash flash = new Flash(); computer.transferData(flash); System.out.println(); //2. 创建了接口的非匿名实现类的匿名对象 computer.transferData(new Printer()); System.out.println(); //3. 创建了接口的匿名实现类的非匿名对象 USB phone = new USB() &#123; @Override public void start() &#123; System.out.println(&quot;手机开始工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;手机结束工作&quot;); &#125; &#125;; computer.transferData(phone); //4. 创建了接口的匿名实现类的匿名对象 computer.transferData(new USB() &#123; @Override public void start() &#123; System.out.println(&quot;mp3开始工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;mp3结束工作&quot;); &#125; &#125;); &#125;&#125;class Computer&#123; public void transferData(USB usb) &#123;//USB usb = new Flash(); 接口的多态性 usb.start(); System.out.println(&quot;具体传输数据的细节&quot;); usb.stop(); &#125;&#125;interface USB&#123; //常量：定义了长、宽、最大最小的传输速率等 void start(); void stop();&#125;class Flash implements USB&#123; @Override public void start() &#123; System.out.println(&quot;U盘开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;U盘结束工作&quot;); &#125;&#125;class Printer implements USB&#123; @Override public void start() &#123; System.out.println(&quot;打印机开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;打印机结束工作&quot;); &#125;&#125; 代理模式（Proxy） 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 123456789101112131415161718192021222324252627282930313233343536373839/* * 接口的应用：代理模式 */public class NetWorkTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); &#125;&#125;interface NetWork&#123; public void browse();&#125;//被代理类class Server implements NetWork&#123; @Override public void browse() &#123; System.out.println(&quot;真实的服务器访问网络&quot;); &#125;&#125;//代理类class ProxyServer implements NetWork&#123; private NetWork work; public ProxyServer(NetWork work) &#123; this.work = work; &#125; public void check()&#123; System.out.println(&quot;联网之前的一些检查工作&quot;); &#125; @Override public void browse() &#123; check(); work.browse(); &#125;&#125; 应用场景： 安全代理：屏蔽对真实角色的直接访问。 远程代理：通过代理类处理远程方法调用（RMI）。 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。 分类： 静态代理（静态定义代理类） 动态代理 （动态生成代理类） JDK自动的动态代理，需要反射等知识 工厂设计模式Java8中关于接口的改进 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。 Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。 静态方法：使用static关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。 默认方法：默认方法使用default关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 * */public interface CompareA &#123; //静态方法 public static void method1() &#123; System.out.println(&quot;CompareA：北京&quot;); &#125; //默认方法 public default void method2() &#123; System.out.println(&quot;CompareA：上海&quot;); &#125; default void method3() &#123;//public可省略 System.out.println(&quot;CompareA：上海&quot;); &#125;&#125;public interface CompareB &#123; default void method3() &#123;//public可省略 System.out.println(&quot;CompareB：上海&quot;); &#125;&#125;public class SuperClass &#123; public void method3() &#123; System.out.println(&quot;SuperClass：北京&quot;); &#125;&#125;public class SubClassTest &#123; public static void main(String[] args) &#123; SubClass s = new SubClass();// s.method1(); //知识点1：接口中定义的静态方法只能通过接口来调用。 CompareA.method1(); //知识点2：通过实现类的对象，可以调用接口中的默认方法 //实现类可以重写接口中的默认方法 s.method2(); //知识点3：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么 //子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法。(类优先原则) //知识点4：如果子类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现 //类没有重写此方法的情况下，报错。(接口冲突) //这就需要我们在实现类中重写此方法 s.method3(); &#125;&#125;class SubClass extends SuperClass implements CompareA,CompareB&#123; public void method2() &#123; System.out.println(&quot;SubClass：上海&quot;); &#125; public void method3() &#123; System.out.println(&quot;SubClass：深圳&quot;); &#125; //知识点5：如何在子类（或实现类）的方法中调用父类、接口中被重写的方法 public void myMethod() &#123; method3();//自己定义的重写方法 super.method3();//调用的是父类中声明的 //调用接口中默认的方法 CompareA.super.method3(); CompareB.super.method3(); &#125;&#125; 类的成员之五：内部类 ava中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。 内部类的分类：成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）。 成员内部类： 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 关注如下3个问题： ① 如何实例化成员内部类 ② 如何在成员内部类中区分调用外部类的结构 ③ 开发中局部内部类的使用 见《InnerClassTest1.java》 使用实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * 类的内部成员之五：内部类 */public class InnerClassTest &#123; public static void main(String[] args) &#123; //创建Dog实例（静态的成员内部类）： Person.Dog dog = new Person.Dog(); dog.show(); //创建Bird实例（非静态的成员内部类）：// Person.Bird bird = new Person.Bird();//错误的 Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); System.out.println(); bird.display(&quot;形参&quot;); &#125;&#125;class Person&#123; String name = &quot;外部类&quot;; int age; public void eat() &#123; System.out.println(&quot;人：吃饭&quot;); &#125; static class Dog&#123; //静态成员内部类 String name; int age; public void show() &#123; System.out.println(&quot;卡拉是条狗&quot;); &#125; &#125; class Bird&#123; //非静态成员内部类 String name = &quot;内部类&quot;; public void sing() &#123; System.out.println(&quot;唱歌&quot;); Person.this.eat();//调用外部类的非静态属性 &#125; public void display(String name) &#123; System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 &#125; &#125; public void method() &#123; class AA&#123; //局部内部类 &#125; &#123; //局部内部类(代码块内) &#125; &#125; public Person() &#123; class CC&#123; //局部内部类(构造器内) &#125; &#125;&#125; 12345678public class InnerClassTest1 &#123; //开发中很少见 public void method() &#123; //局部内部类 class AA&#123; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十四章 网络编程","slug":"Java基础/第十四章 网络编程","date":"2020-11-30T04:25:18.289Z","updated":"2020-12-10T13:18:44.225Z","comments":true,"path":"undefined/ce7e.html","link":"","permalink":"https://asteroidcs.github.io/undefined/ce7e.html","excerpt":"","text":"网络基础计算机网络​ 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。 网络编程的目的​ 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有两个主要的问题 如何准确地定位网络上一台或多台主机;定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信要素概述如何实现网络中的主机互相通信 通信双方地址 IP 端口号 一定的规则(即:网络通信协议。有两套参考模型) OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广 ==TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。== 数据传输视图 ==通信要素1: IP和端口号==IP 地址:InetAddress 唯一的标识 Internet 上的计算机(通信实体) 本地回环地址(hostAddress):127.0.0.1 主机名(hostName):localhost IP地址分类方式1:IPV4 和 IPV6 PV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1 IPV6:128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984 IP地址分类方式2:==公网地址(万维网使用)==和==私有地址(局域网使用)==。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用 特点:不易记忆 ==端口号==：标识正在计算机上运行的进程(程序) ==不同的进程有不同的端口号== 被规定为一个 16 位的整数 0~65535 端口分类: 公认端口:0~1023。被预先定义的服务通信占用(如:HTTP占用端口 80，FTP占用端口21，Telnet占用端口23) 注册端口:1024~49151。分配给用户进程或应用程序。(如:Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等) 动态/私有端口:49152~65535 ==端口号与IP地址的组合得出一个网络套接字：Socket。== InetAddress类 Internet上的主机有两种方式表示地址: 域名(hostName): www.atguigu.com P 地址(hostAddress): 202.108.35.210 123456789101112public class InternetAddressTest&#123; public static void main(String[] args) &#123; try &#123; InetAddress address = InetAddress.getByName(&quot;www.atguigu.com&quot;); System.out.println(address); // www.atguigu.com/58.215.145.106 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; InetAddress类主要表示IP地址，两个子类:Inet4Address、Inet6Address InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: www.atguigu.com 和 202.108.35.210 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS) 负责将域名转化成IP地址，这样才能和主机建立连接。———==域名解析== InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) InetAddress提供了如下几个常用的方法 public String getHostAddress(): 返回 IP 地址字符串(以文本表现形式) public String getHostName(): 获取此 IP 地址的主机名 public boolean isReachable(int timeout): 测试是否可以达到该地址 ==通信要素2：网络协议== 网络通信协议 ​ 计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代 码结构、传输控制步骤、出错控制等制定标准。 问题:网络协议太复杂 ​ 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩，解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢? 通信协议分层的思想 ​ 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。 TCP/IP协议簇 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol) ==TCP/IP 以其两个主要协议==：==传输控制协议(TCP)==和==网络互联协议(IP)==而得 名，实际上是一组协议，包括多个具有不同功能且互为关联的协议 ==IP(Internet Protocol)协议==是网络层的主要协议，支持网间互连的数据通信 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理链路层==、==IP层==、==传输层==和==应用层==。 TCP 和 UDP TCP协议: 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用==“三次握手”==方式，点对点通信，==是可靠的== TCP协议进行通信的两个应用进程:客户端、服务端。 在连接中可==进行大数据量的传输== 传输完毕，==需释放已建立的连接，效率低== UDP协议: 将数据、源、目的封装成数据包，==不需要建立连接== 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的  可以广播发送 发送数据结束时==无需释放资源，开销小，速度快== Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。 ==网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字== 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。  一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类: 流套接字(stream socket):使用TCP提供可依赖的字节流服务 数据报套接字(datagram socket):使用UDP提供“尽力而为”的数据报服务 TCP网络编程基于Socket的TCP编程 Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模 型如图所示 ==客户端Socket的工作过程包含以下四个基本的步骤:== 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到 Socket 的输入/出流:：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输 按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 (但不能读取自己放入线路的信息)，通过输出流将信息写入线程。 关闭 Socket:：断开客户端到服务器的连接，释放线路 ==服务器程序的工作过程包含以下四个基本的步骤:== 调用 ServerSocket(int port) :创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept():监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。 调用 该Socket类对象的 getOutputStream() 和 getInputStream ():获取输出 流和输入流，开始网络数据的发送和接收。 关闭ServerSocket和Socket对象:客户端访问结束，关闭通信套接字 客户端创建Socket对象 客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是: Socket(String host,int port)throws UnknownHostException,IOException:向服务器(域名是 host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。 Socket(InetAddress address,int port)throws IOException:根据InetAddress对象所表示的 IP地址以及端口号port发起连接。 客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求 服务器建立 ServerSocket 对象 erverSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。 所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象 例题1：客户端发送内容给服务端，服务端将内容打印到控制台上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package lesson1;import org.junit.jupiter.api.Test;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * @author Justry * @Description 实现TCP的网络编程：客户端发送信息给服务器，服务端将数据显示在控制台上 * @date 2020-11-30 1:38 下午 */public class TCPTest1 &#123; //客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; InetAddress localHost = InetAddress.getLocalHost(); socket = new Socket(localHost, 8899); os = socket.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //服务端 @Test public void server() &#123; ServerSocket serverSocket = null; InputStream is = null; ByteArrayOutputStream baos = null; Socket socket = null; try &#123; serverSocket = new ServerSocket(8899); socket = serverSocket.accept(); is = socket.getInputStream(); baos = new ByteArrayOutputStream(); byte[] bytes = new byte[20]; int len; while ((len = is.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); &#125; System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (serverSocket != null) &#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 例题2：客户端发送文件给服务端，服务端将文件保存在本地例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给 客户端。并关闭相应的连接。 练习1：服务端读取图片并发送给客户端，客户端保存图片到本地练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端客户端—服务端 客户端: 自定义 浏览器 服务端: 自定义 Tomcat服务器 UDP网络编程 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，==系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达==。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。 ==UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样==。 常用方法 UDP网络通信 流程 DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送、接收方法 5. 关闭Socket 发送端与接收端是两个独立的运行程序 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package lesson1;import org.junit.jupiter.api.Test;import java.io.IOException;import java.net.*;/** * @author Justry * @Description * @date 2020-11-30 2:46 下午 */public class UDPTest &#123; @Test public void sender() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress localHost = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, localHost, 9090); socket.send(packet); socket.close(); &#125; @Test public void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] bytes = new byte[100]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); socket.receive(packet); System.out.println(new String(packet.getData(), 0, packet.getLength())); socket.close(); &#125;&#125; URL编程URL类 URL(Uniform Resource Locator):统一资源定位符，它表示 Internet 上某一 资源的地址 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate 这个资源 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 URL的基本结构由5部分组成: ==&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表== 例如: http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123 #片段名:即锚点，例如看小说，直接定位到章节 参数列表格式:参数名=参数值&amp;参数名=参数值…. 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象: URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。 一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的 方法来获取这些属性: 针对HTTP协议的URLConnection类 ==URL的方法 openStream():能从网络上读取数据== 若希望输出数据，例如向服务器端的 CGI (公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口)程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。 URLConnection:表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. URL netchinaren = new URL (“http://www.atguigu.com/index.shtml&quot;); URLConnectonn u = netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 ==URI、URL和URN的区别==12URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 ==总结== 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 ==客户端-服务器==是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。==端口号== 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。==套接字==用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。 Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段:主机名(String) 和 IP 地址(int)。 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端-服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。 类 URL 和 URLConnection 提供了最 高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十三章 IO流","slug":"Java基础/第十三章 IO流","date":"2020-11-28T12:25:50.563Z","updated":"2020-12-10T13:18:49.626Z","comments":true,"path":"undefined/4554.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4554.html","excerpt":"","text":"==重点掌握==：节点流、缓冲流、转换流、对象流File类的使用概念 File类的一个对象，==代表一个文件或一个文件目录==（俗称：文件夹） java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是==Java程序中的一个File对象，可能没有一个真实存在的文件或目录== File对象可以作为参数传递给流的构造器 ==File类不涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流== 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点“ 路径分隔符 路径中的每级目录之间用一个路径分隔符隔开。 ==路径分隔符和系统有关==： ①windows和DOS系统默认使用“\\”来表示 ②UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用，为了解决这个隐患，File类提供了一个常量： ==public static final String separator。根据操作系统，动态的提供分隔符== 内存 常用构造器 ==public File(String pathname)==：以pathname为路径创建对象(绝对路径或相对路径)，==相对路径默认当前路径为系统属性user.dir==。 IDEA中： 如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下； 如果使用main()测试，相对路径即为当前的Project下。 Eclipse中：不管是单元测试方法还是main()测试，相对路径都是当前的Project下。 ==public File(String parent,String child)==：以parent为父路径，child为子路径创建File对象。 ==public File(File parent,String child)==：根据一个父File对象和子文件路径创建File对象。 12345678910111213141516171819// 构造器的使用 @Test public void test1()&#123; // 构造器1： File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;D:\\\\workspace_idea1\\\\JavaSenior&quot;); System.out.println(file1); System.out.println(file2); // 构造器2： File file3 = new File(&quot;D:\\\\workspace_idea1&quot;, &quot;JavaSenior&quot;); System.out.println(file1); // 构造器3： File file4 = new File(file3, &quot;Hello.txt&quot;); System.out.println(file4); &#125; 常用方法 File类的获取功能： public String getAbsolutePath()：获取绝对路径 public String getPath()：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度 public long lastModified() ：获取最后一次的修改时间，毫秒值 1234567891011121314@Test public void test2() &#123; File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;\\\\Users\\\\i-mamba\\\\Desktop\\\\IO\\\\hi.txt&quot;); System.out.println(file1.getAbsoluteFile()); // /Users/i-mamba/程序员技能学习/Java/Java基础入门/code/IDEA-workspace/JavaSenior/day08/Hello.txt System.out.println(file1.getPath()); // Hello.txt System.out.println(file1.getName()); // Hello.txt System.out.println(file1.getParent()); // null System.out.println(file1.length()); // 12 System.out.println(file1.lastModified()); // 1606614159235 System.out.println(new Date(file1.lastModified())); // Sun Nov 29 09:42:39 CST 2020 &#125; 下面两方法适用于文件目录： public String[] list()：获取指定目录下的所有文件或者文件目录的==名称==数组 public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File路径数组 File类的重命名功能 public boolean renameTo(File dest)：把文件重命名为指定的文件路径 比如file1.renameTo(file2)，要保证返回true，==需要file1在硬盘中存在且file2在硬盘中不存在==。修改可包括路径和文件内容。 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile()：判断是否是文件 public boolean exists()：判断是否存在 public boolean canRead()：判断是否可读 public boolean canWrite()：判断是否可写 public boolean isHidden()：判断是否隐藏 1234567891011@Test public void test4() &#123; File file = new File(&quot;/Users/i-mamba/程序员技能学习&quot;); System.out.println(file.isDirectory()); // true System.out.println(file.isFile()); // false System.out.println(file.exists()); // true System.out.println(file.canRead()); // true System.out.println(file.canWrite()); // true System.out.println(file.isHidden()); // false &#125; File类的创建功能 public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建——&gt; 创建多层文件目录 ==注意事项==：如果你创建文件或者文件目录没有写盘符路径，那么默认在项目路径下。 File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项： ==Java中的删除不走回收站==； ==要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录== 练习题12345671. 利用File构造器，new 一个文件目录file。 * 在其中创建多个文件和目录 * 编写方法，实现删除file中指定文件的操作2. 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称。3. 遍历指定目录所有文件名称，包括子文件目录中的文件。 * 拓展1：并计算指定目录占用空间的大小 * 拓展2：删除指定文件目录及其下的所有文件 IO流原理及流的分类Java IO原理 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 ==Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行的== java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 输入输出：进入内存即为输入(Input)，出内存即为输出(Output) 流的分类 按操作==数据单位==不同分为：==字节流(8 bit)==，==字符流(16 bit)==。 按数据流的==流向==不同分为：==输入流==，==输出流==。 按流的==角色==的不同分为：==节点流==，==处理流==。 ==(抽象基类)== 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java的IO流共涉及40多个类，实际上非常规则，都是从者4个类派生的，==由这4个类派生出来的子类名称都是以其父类名作为子类名后缀== IO流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 ==抽象基类== InputStream OutputStream Reader Writer ==访问文件== FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter ==缓冲流== BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 节点流和处理流 ==节点流==：直接从数据源或目的地读写数据 ==处理流==：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能 InputStream &amp; Reader ==InputStream和Reader是所有输入流的基类==。 InputStream（典型实现：FileInputStream） int read() int read(byte[] b) int read(byte[] b,int off,int len) Reader（典型实现：FileReader） int read() int read(byte[] b) int read(byte[] b,int off,int len) 程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader InputStream int read()：从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。 int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 Reader int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1。 int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 OutputStream &amp; Writer OutputStream 和 Writer 也非常相似： void write(int b/int c); void write(byte[] b/char[] cbuf); void write(byte[] b/char[] buff, int off, int len); void flush(); void close(); 需要先刷新，再关闭此流 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数 void write(String str); void write(String str, int off, int len); FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。 OutputStream void write(int b)：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b)：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 void write(byte[] b,int off,int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 Writer void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf)：写入字符数组。 void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符。 void write(String str)：写入字符串。 void write(String str,int off,int len)：写入字符串的某一部分。 void flush()：刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 节点流(或文件流)通用步骤：123456* 实例化File类对象，指明要操作的文件* 提供具体的流* 数据的操作* 关闭资源 // 注意：异常处理 字符流FileReader 步骤： File类的实例化 FileReader流的实例化 读入的操作 资源关闭 说明点： read()的理解：返回读入的一个字符，如果到大文件末尾，返回-1。 异常处理：为了保证资源一定可以执行关闭操作。需要使用try-catch-finally处理。 读入文件一定要存在，否则就会报FileNotFoundException 基本操作 12345678910111213141516171819202122232425262728293031323334353637@Test public void FileReaderTest() &#123; FileReader fileReader = null; try &#123; //1.实例化File类的对象，指明要操作的文件 File file = new File(&quot;hello.txt&quot;); //2.提供具体的流 fileReader = new FileReader(file); //3.数据的读入 //read()：返回读入的一个字符。如果达到文件末尾，返回-1 //方式一：// int data = fileReader.read();// while (data != -1) &#123;// System.out.print((char) data);// //读取下一个字符// data = fileReader.read();// &#125; //方式二：语法上针对于方式一的修改 int data; while ((data = fileReader.read()) != -1) &#123; System.out.print((char) data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流的关闭操作 try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 对read()操作升级：使用read()的重载方法 1234567891011121314151617181920212223242526272829@Test public void FileReaderTest2() &#123; FileReader fileReader = null; try &#123; //1.File类的实例化 File file = new File(&quot;Hello.txt&quot;); //2.FileReader流的实例化 fileReader = new FileReader(file); //3.读入的操作 char[] cbuf = new char[5]; int len; while ((len = fileReader.read(cbuf)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileWriter 步骤： 创建File类的对象：指明读入和写出的文件 创建输入流和输出流的对象 数据的读入和写出操作 关闭流资源 ==说明点== 从内存中写出数据到硬盘的文件里 输出操作，对应的File可以不存在。 * 如果不存在，在输出过程中，会自动创建此文件 * 如果存在： * 使用的流构造器是: FileWriter(file,false) / FileWriter(file)，对原有文件覆盖 * 使用的流构造器是: FileWriter(file,true)，不会对原有文件覆盖，而是在原有文件的基础上 基本操作 12345678910111213141516171819202122232425262728293031323334353637383940@Test public void FileWriterTest1() &#123; FileReader fileReader = null; FileWriter fileWriter = null; try &#123; //1.创建File类的对象：指明读入和写出的文件 File file = new File(&quot;Hello.txt&quot;); File file1 = new File(&quot;Hello2.txt&quot;); //2.创建输入流和输出流的对象 fileReader = new FileReader(file); fileWriter = new FileWriter(file1); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len; // 记录每次读入到cbuf数组中的字符的个数 while ((len = fileReader.read(cbuf)) != -1) &#123; //每次写出len个字符 fileWriter.write(cbuf, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流资源 try &#123; if (fileWriter != null) &#123; fileWriter.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字节流FileInputStream ==注意点：使用字节流处理文本文件，可能出现乱码== 说明： 对于文本文件（.txt，.java，.c，.cpp），使用字符流处理 对于非文本文件，使用字节流处理 基本操作 1234567891011121314151617181920212223242526272829@Test public void fISStreamTest1() &#123; FileInputStream inputStream = null; try &#123; //造文件 File file = new File(&quot;cat.jpeg&quot;); //造流 inputStream = new FileInputStream(file); //读数据 int len; // 记录每次读取的字节的个数 byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(bytes[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 关闭流资源 if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 复制图片 123456789101112131415161718192021222324252627282930313233343536@Test public void fISStreamTest2() &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat2.jpeg&quot;); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通用操作：指定路径下的文件复制操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Test public void copyFile(String srcPath,String destPath) &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(srcPath); File file1 = new File(destPath); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[1024]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testCopyFile()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;文件路径&quot;; String destPath = &quot;复制路径&quot;; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;整个复制操作花费的时间为：&quot; + (end - start));//13031 //可以复制文本文件 &#125; &#125; 缓冲流 处理流的一种，“套接”在已有的流的基础上 缓冲流涉及到的类 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter ==作用==：提供流的读取、写入的速度 ==原因==：内部提供了一个缓冲区。默认情况下是8kb 说明： 先关闭外层流，再关闭内层流 ==关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略== 非文本文件的复制 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Test public void BfStreamTest1() &#123; BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try &#123; //1.造文件 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat3.jpeg&quot;); //2.造流 //2.1造节点流 FileInputStream inputStream = new FileInputStream(file); FileOutputStream outputStream = new FileOutputStream(file1); //2.2造处理流 bufferedInputStream = new BufferedInputStream(inputStream); bufferedOutputStream = new BufferedOutputStream(outputStream); //3.复制：数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = bufferedInputStream.read(bytes)) != -1) &#123; bufferedOutputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (bufferedOutputStream != null) bufferedOutputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if (bufferedInputStream != null) bufferedInputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 文本文件的复制，略，基本雷同 练习题 图片的加密 1234567891011121314151617181920212223242526272829303132333435363738394041public class PicTest &#123; /** * 图片的加密操作 */ @Test public void testEncrypt()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;cat.jpg&quot;); fos = new FileOutputStream(&quot;cat2.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; //核心 for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 图片的解密 对加密的文件做同样的异或操作 123456789101112131415161718192021222324252627282930313233343536373839/** * 图片的解密操作 */ @Test public void testDecode()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;加密后的玛雅.jpg&quot;); fos = new FileOutputStream(&quot;解密后的玛雅.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 获取文本上每个字符出现的次数 1//提示：遍历文本每一个字符，字符及出现次数保存在Map中，将Map中数据写入文件。 转换流 转换流提供了在字节流和字符流之间的转换 ==Java API提供了两个转换流==: ==InputStreamReader==：将InputStream转换为Reader ==OutputStreamWriter==；将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来==处理文件乱码==问题。实现==编码==和== 解码==的功能 InputStreamReader ==实现将字节的输入流按指定字符集转换为字符的输入流== 需要和InputStream“套接” 构造器 public InputStreamReader(InputStream in) public InputSreamReader(InputStream in,String charsetName) OutputStreamWriter ==实现将字符的输出流按指定字符集转换为字节的输出流== 需要和OutputStream“套接” 构造器 public OutputStreamWriter(OutputStream out) public OutputSreamWriter(OutputStream out,String charsetName) 字符编码 编码:字符串字节数组 解码:字节数组字符串 转换流的编码应用 可以将字符按指定编码格式存储 可以对文本数据按指定编码格式来解读 指定编码表的动作由构造器完成 标准输入、输出流 ==System.in==和==System.out==分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是==InputStream==，直接以流的形式读取了 System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向:通过System类的setIn()，setOut()方法对默认设备进行改变 练习 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序 1234567891011121314151617181920212223242526272829303132public class OtherStreamTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) &#123; System.out.println(&quot;请输入字符串：&quot;); String data = br.readLine(); if (data.equalsIgnoreCase(&quot;e&quot;) || data.equalsIgnoreCase(&quot;exit&quot;)) &#123; System.out.println(&quot;程序结束！&quot;); break; &#125; String upperCase = data.toUpperCase(); System.out.println(upperCase); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印流 ==实现将基本数据类型的数据格式转化为字符串输出==，指定输入/输出的位置 打印流：==PrintStream==和==PrintWriter== 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 例子 12345678910111213PrintStream ps = null; try &#123;FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true);if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件System.setOut(ps); &#125;for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i);if (i % 50 == 0) &#123; // 每50个数据一行System.out.println(); // 换行 &#125;&#125;&#125; catch (FileNotFoundException e) &#123;e.printStackTrace(); &#125; finally &#123;if (ps != null) &#123; ps.close();&#125; &#125; 数据流 作用：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类:(==用于读取和写出基本数据类型、String类的数据==) ==DataInputStream== 和 ==DataOutputStream== 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream中的方法 boolean readBoolean() char readChar() double readDouble() long readLong() String readUTF() byte readByte() float readFloat() short readShort() int readInt() void readFully(byte[] b) DataOutputStream中的方法 ==将上述的方法的read改为相应的write即可== 练习 将内存中的字符串、基本数据类型变量写出到文件中 1234567891011DataOutputStream dos = null;try &#123; // 创建连接到指定文件的数据输出流对象dos = new DataOutputStream(new FileOutputStream(&quot;destData.dat&quot;)); dos.writeUTF(&quot;我爱北京天安门&quot;); // 写UTF字符串 dos.writeBoolean(false); // 写入布尔值dos.writeLong(1234567890L); // 写入长整数 System.out.println(&quot;写文件成功!&quot;);&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流对象try &#123;if (dos != null) &#123;// 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close();&#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125; 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中 12345678910111213DataInputStream dis = null; try &#123;dis = new DataInputStream(new FileInputStream(&quot;destData.dat&quot;)); String info = dis.readUTF();boolean flag = dis.readBoolean();long time = dis.readLong();System.out.println(info); System.out.println(flag); System.out.println(time);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123;if (dis != null) &#123;try &#123; dis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125;&#125; ==注意==：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ 对象流基础概念 用于==存储==和==读取==基本数据类型数据或对象的处理流。它的强大之处就是==可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来== ==ObjectInputStream==和==OjbectOutputSteam== ==序列化==：用ObjectOutputStream类==保存==基本类型数据或对象的机制 ==反序列化==：用ObjectInputStream类==读取==基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream==不能序列化static和transient==修饰的成员变量 以下面的Person类为例 123456789101112public class Person implements Serializable &#123; public static final long serialVersionUID = 44353533453L; //将变量用static 和 transient修饰 private static String name; private transient int age;略 //此时的反序列化结果我爱北京天安门Person&#123;name=&#x27;null&#x27;, age=0&#125; //显然无法序列化这两个变量 对象的序列化 ==对象序列化机制==允许把内存中的Java对象转换成平台无关的==二进制流==，从 而允许把这种二进制流持久地==保存在磁盘上==，或通过网络将这种二进制流==传输到另一个网络节点==。//==当其它程序获取了这种二进制流，就可以恢复成原来的Java对象== ==序列化的好处==：在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI(Remote Method Invoke – 远程方法调用)过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此==序列化机制是 JavaEE 平台的基础== ==如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的==，==为了让某个类是可序列化的，该类必须实现如下两个接口之一==。 否则，会抛出NotSerializableException异常 $\\color{red}{Serializable}$ Externalizable ==凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量==: $\\color{red}{private static final long serialVersionUID}$; ==serialVersionUID==用来表明类的不同版本间的兼容性。简言之，其目的是==以序列化对象 进行版本控制，有关各版本反序列化时是否兼容==。 ==如果类没有显示定义这个静态常量==，它的值是==Java运行时环境根据类的内部细节自动生成==的。 若类的实例变量做了修改，serialVersionUID 可能发生变化。故==建议， 显式声明== ==Java的序列化机制==是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，==JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较==，如果相同就认为是==一致==的，==可以进行反序列化==，==否则就会出现序列化版本不一致的异 常。(InvalidCastException)== 使用对象流序列化对象序列化实现 ==若某个类实现了 Serializable 接口，该类的对象就是可序列化的:== 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 ==注意写出一次，操作flush()一次== 1234567891011121314151617181920//序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现@Testpublic void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反序列化实现 步骤 创建一个 ObjectInputStream 调用 readObject() 方法读取流中的对象 1234567891011121314151617181920212223//反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现@Testpublic void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 自定义类实现序列化 ==强调==：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是==可序列化的==，否则拥有该类型的 Field 的类也不能序列化 ==以Person类为例== 需要==实现接口==：Serializable 当前类==提供一个全局常量==：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化de 。(默认情况下，基本数据类型可序列化) package lesson; import org.junit.jupiter.api.Test; import java.io.*; /** * @author Justry * @Description 对象流的使用 * @date 2020-11-30 9:35 上午 */ public class ObiectIOStreamTest &#123; //序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现 @Test public void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); oos.writeObject(new Person(&quot;如花&quot;, 60)); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现 @Test public void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); System.out.println(str); // 我爱北京天安门 System.out.println(p); // Person&#123;name=&#39;如花&#39;, age=60&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 123456789#### Q1. 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗?&#96;&#96;&#96;java实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。&#x2F;&#x2F;这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活 随机存取文件流RandomAccessFile 类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写，即可以作为输入/出流 实现图片的复制 123456789101112131415161718192021222324@Test public void test1() throws IOException &#123; RandomAccessFile r1 = null; RandomAccessFile r2 = null; try &#123; r1 = new RandomAccessFile(new File(&quot;cat.jpeg&quot;), &quot;r&quot;); r2 = new RandomAccessFile(new File(&quot;cat2.jpeg&quot;), &quot;rw&quot;); byte[] buffer = new byte[1024]; int len; while ((len = r1.read(buffer)) != -1) &#123; r2.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (r2 != null) r2.close(); if (r1 != null) r1.close(); &#125; &#125; RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 ==RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置== long getFilePointer():获取文件记录指针的当前位置 void seek(long pos):将文件记录指针定位到 pos 位置 1234567891011@Testpublic void test2() throws IOException &#123; RandomAccessFile rw = new RandomAccessFile(&quot;Hello.txt&quot;, &quot;rw&quot;); rw.seek(&quot;Hello.txt&quot;.length()); // 将指针指到末尾，追加内容 rw.write(&quot;xyz&quot;.getBytes()); rw.close();&#125; 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式 r；以只读方式打开 rw；打开以便读取和写入 rwd；打开以便读取和写入；同步文件内容的更新 rws；打开以便读取和写入；同步文件内容和元数据的更新 ==如果模式为只读r==。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 ==如果模式为rw读写==，如果文件不 存在则会去创建文件；如果存在则不会创建，写到文件时会对原有内容进行部分覆盖 应用：多线程断点下载 流的基本应用小节 流是用来处理数据的。 处理数据时，一定要先明确数据源，与数据目的地，数据源可以是文件，可以是键盘。 数据目的地可以是文件、显示器或者其他设备。 而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等 NIO.2中Path、 Paths、Files类的使用 NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。==NIO将以更加高效的方式进行文件的读写操作==。 Java API中提供了两套NIO：==一套是针对标准输入输出NIO==，==另一套就是网 络编程NIO== 实战总结： 一个流只能使用一次，不能重复使用，若想使用，必须重新创建流","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十一章 集合","slug":"Java基础/第十一章 集合","date":"2020-11-27T01:12:32.106Z","updated":"2020-12-10T13:18:33.298Z","comments":true,"path":"undefined/f650.html","link":"","permalink":"https://asteroidcs.github.io/undefined/f650.html","excerpt":"","text":"Java集合框架集合与数组存储数据概述集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 数组存储的弊端 一旦初始化以后，其长度就不可以修改了，这就使得不便于扩展 数组中提供的方法非常有限，对于添加、删除、插入数据等操作不便，且效率不高 获取数组中实际元素的个数的需求，数组中没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。故无法满足对于无序、不可重复的需求 集合存储的优点集合的出现就是为了==解决数组存储数据方面的弊端== 集合框架结构：Java集合可分为==Collection==和==Map==两种体系 Collection接口：单列集合，用来存储一个一个的对象 List接口：==存储有序的、可重复的数据 ——&gt; “动态”数组== Set接口：==存储无序的、不可重复的数据== Collection接口继承树 Map接口：双列数据，==保存具有映射关系的“key-value”对的集合== Map接口继承树 Collection接口方法Collection接口 Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合——&gt; ==继承性的特点：可以调用父类的方法== ==JDK不提供Collection接口的任何直接实现，而是提供更具体的子接口(Set、List)实现== ——&gt; 意味着只能构造其子接口的对象，即ArrayList、LinkedList、Vector/LinkedHashSet、TreeSet等 在==Java5==之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；==从JDK 5.0增加了泛型以后==，Java集合可以记住容器中对象的数据类型。 $\\color{red}{注意：向Collection接口的实现类对象中添加数据obj时，要求obj所在类重写equals()方法}$ Collection接口常用方法 增加数据 add(Object e): 将元素e添加到集合coll中 addAll(Collection coll): 将coll集合中的元素添加到当前的集合中 123456789101112131415161718192021222324252627282930313233343536public class CollectionTest &#123; @Test public void addTest()&#123; //由于JDK不提供Collection接口的任何直接实现，所以这种写法是错误的 ---&gt; 只能用其子接口// Collection collection = new Collection(); //采用子接口实现 Collection collection1 = new ArrayList(); Collection collection2 = new ArrayList(); //add collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(new String(&quot;Tom&quot;)); System.out.println(collection1); // [123, 123, false, Tom] //addAll collection2.add(4324); collection2.add(&quot;555&quot;); collection2.add(&quot;123&quot;); collection2.add(new String(&quot;Jack&quot;)); collection2.add(true); System.out.println(collection2); // [4324, 555, 123, Jack, true] //将集合1加入集合2中 collection2.addAll(collection1); System.out.println(collection2); // [4324, 555, 123, Jack, true, 123, 123, false, Tom] &#125;&#125; ==从代码输出的结果可以看出：这里正好体现了List接口存放有序、可重复数据的特点== 删除数据 clear()：==清空==集合元素 remove(Object obj)：从当前集合中移除指定的obj元素 removeAll(Collection coll)：移除当前集合与另外的coll集合的==交集==中的元素 12345678910111213141516171819202122232425262728public void DeleteTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false, Tom] //remove collection1.remove(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false] // clear collection1.clear(); System.out.println(collection1); // [] //removeAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(123); collection1.removeAll(collection2); System.out.println(collection1); // [false, Tom] &#125; 查找数据 contains(Object obj)；判断当前集合中是否包含obj containsAll(Collection coll)：判断形参coll中所有元素是否都存在于当前集合中 123456789101112131415161718192021222324252627282930313233public void ContainsTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(&quot;Tom&quot;); //Contains boolean contains = collection1.contains(123); System.out.println(contains); // true boolean contains1 = collection1.contains(3543); System.out.println(contains1); // false /** * 此处调用的是String类中的equals，由于String重写了equals方法， * 故比较的是内容，而非地址，所以返回true， * 若自定义的类没有重写object的equals方法，则返回false */ System.out.println(collection1.contains(&quot;Tom&quot;)); // true //ContainsAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(&quot;Tom&quot;); //集合collection2中的所有元素是否都存在于collection1中 boolean b = collection1.containsAll(collection2); System.out.println(b); // true &#125; 集合的长度 size(): 获取添加的元素个数 其他 isEmpty()：判断当前集合是否为空 retainAll(Collection coll): 交集，将当前集合修改为当前集合与coll的交集 equals(Object obj): 判断当前集合与形参集合的元素是否都相同 hashCode()：返回当前对象的哈希值 toArray()：集合转换成数组 1234567891011121314151617181920212223242526public void toArray()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Object[] array = collection1.toArray(); for (int i = 0; i &lt; array.length; i++) &#123; // 123 123 false Tom System.out.print(array[i] + &quot; &quot;); &#125; // 拓展：数组 ---&gt; 集合 List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] System.out.println(list); List arr = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(arr); // [[I@3ecd23d9] ---&gt; 识别为了一个元素 List arr1 = Arrays.asList(123, 456); System.out.println(arr1); //[123, 456] List arr2 = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(arr2); // [123, 456] &#125; 12// 拓展：数组 ---&gt; 集合 : 调用Arrays类的静态方法asList() List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] iterator(): 返回Iterator接口的实例，用于遍历集合元素 $\\color{red}{在判断时会调用obj对象所在类的equals()方法}$ 集合的默认遍历方法（jdk8新特性）—&gt; ==forEach== 1234567891011@Testpublic void test5()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(343); coll.add(343); coll.forEach(System.out::println);//方法引用&#125; terator迭代器接口 ==Iterator仅用于遍历集合==，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合 12345678910111213public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; &quot;); // 123 123 false Tom &#125;&#125; ==集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前== 1234// 错误写法while (collection1.iterator().hasNext())&#123; // 每次产生一个全新的迭代器对象 System.out.println(collection1.iterator().next()); // 死循环 ---&gt; 不断输出第一个元素&#125; ==使用迭代器遍历集合一般使用的方式以及迭代器执行原理：== remove()方法 内部定义了remove方法，==Iterator可以删除集合的元素==，==区别集合的remove()方法和迭代器的remove()方法== 注意指针的位置，若调用remove()方法时指针位置为空，则报异常IllegalStateException。 1234567891011121314151617public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); if (&quot;Tom&quot;.equals(o))&#123; iterator.remove(); &#125; &#125; System.out.println(collection1); // [123, 123, false] &#125; foreach循环(增强for循环) Java 5.0 提供了foreach循环迭代访问Collection和数组 无需长度、索引 内部仍然调用了迭代器 ——&gt; ==底层：Iterator== 123for(元素类型 局部变量 : 数组/Collection对象)&#123; //对局部变量操作&#125; 123456789101112public void forEach()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); for (Object obj : collection1)&#123; System.out.print(obj + &quot; &quot;); // 123 123 false Tom &#125; &#125; $\\color{red}{注意：增强for循环是将值赋给局部变量，改变的是局部变量，不影响对象中的元素}$ 练习：判断输出结果为何？ 1234567891011public void testExer()&#123; String[] str = new String[5]; for(String myStr : str)&#123; myStr = &quot;atguigu&quot;; System.out.println(myStr); &#125;//5行&quot;atguigu&quot; for(int i = 0;i &lt; str.length;i++)&#123; System.out.println(str[i]); &#125;//5行null &#125; Collection子接口一：List 存储有序的、可重复的数据。==&gt; “动态”数组，替换原有的数组 —&gt; 避免了角标越界 理解：添加数据时，当原数组的存储空间不够时，会重新生成一个容量较大的新数组，将原数组中的元素放进新数组中，并添加新的数据 ———&gt; 占内存 List接口方法：除了从Collection集合继承的方法外，==List 集合里添加了一些根据索引来操作集合元素的方法== 增加数据 void add(int index,Object ele)：在index位置插入ele元素； boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来； 1234567891011121314151617181920212223242526272829@Test public void addTest()&#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //add //数组的第二个位置插入数据 list.add(2, 657); System.out.println(list); // [123, Tom, 657, false, 342] //addAll //将list1插入list的索引2位置 List list1 = new ArrayList(); list1.add(7868); list1.add(&quot;Jack&quot;); list1.add(true); list.addAll(2, list1); System.out.println(list); &#125; 删除数据 Object remove(int index)：移除指定index位置的元素，==并返回此元素== Object remove(Object obj)：移除指定的元素(若有多个，则只移除首位的元素)，==并返回true/false== 123456789101112131415161718192021222324@Test public void removeTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //remove(int index) Object o = list.remove(0); System.out.println(o); // 123 //remove(Object obj) boolean b = list.remove(&quot;Tom&quot;); System.out.println(b); // true boolean b1 = list.remove(&quot;Jack&quot;); System.out.println(b1); // false &#125; 查找 Object get(int index)：获取指定index位置的元素； int indexOf(Object obj)：返回obj在集合中首次出现的位置； int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置； List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合。 1234567891011121314151617181920212223242526272829@Test public void getTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.add(342); list.add(&quot;Tom&quot;); System.out.println(list); // [123, Tom, Jack, 342, Tom] // Object get(int index) Object o = list.get(2); System.out.println(o); // Jack // int indexOf(Object obj) int i = list.indexOf(&quot;Tom&quot;); System.out.println(i); // 1 // int lastIndexOf(Object obj) int i1 = list.lastIndexOf(&quot;Tom&quot;); System.out.println(i1); // 4 // List subList(int fromIndex, int toIndex) List list1 = list.subList(1, 4); System.out.println(list1); // [Tom, Jack, 342] &#125; 修改 Object set(int index, Object ele)：设置指定index位置的元素为ele； 123456789101112@Test public void setTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.set(1, 5464); System.out.println(list); // [123, 5464, Jack] &#125; ArrayList​ ==作为List接口的主要实现类；由于是线程不安全的，故效率高；底层使用Object[] elementData存储。== ==源码分析==： 123456789101112//jdk7的情况下：ArrayList list = new ArrayList();//底层创建而来长度为10的Object[]数组elementData；list.add(123);//elementData[0] = new Integer(123);//...list.add(12);//如果此次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)//jdk8中ArrayList的变化：ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组。list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中。//后续的添加扩容操作与jdk7无异 ==小结==：jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8则类似于懒汉式，延迟了数组的创建，节省内存。 【面试题】 1234567891011121314151617@Testpublic void testListRemove()&#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list); // [1]&#125;private static void updateList(List list)&#123; /** * 考点：确定调用哪个remove， 两个remove()方法中index优先权大于Object，删除索引为2的元素 */ list.remove(2);//两个remove()方法中index优先权大于Object，删除索引为2的元素 list.remove(new Integer(2));//删除值为2的元素&#125; LinkedList 对于==频繁的插入和删除==操作，使用此类效率比ArrayList高；底层使用双向链表存储。 1234567891011121314JavaLinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node除了保存数据，还定义了两个变量： prev：记录前一个元素的位置 next：记录下一个元素的位置 新增方法： 123456void addFirst(Object obj)void addLast(Object obj)Object getFirst()Object getLast()Object removeFirst()Object removeLast() Vector 作为List接口的古老实现类(1.0)；线程安全的，效率低；底层使用Object[] elementData存储。 源码分析： jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍。 新增方法： 12345void addElement(Object obj)void insertElementAt(Object obj,int index)void setElementAt(Object obj,int index)void removeElement(Object obj)void removeAllElements() ==面试题==：请问ArrayList/LinkedList/Vector的异同？谈谈你的理解。ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? ArrayList和LinkedList的异同 12二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 1Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。 Collection子接口二：Set Set接口是Collection的子接口，==set接口没有提供额外的方法==。都是Collection中声明过的方法。 ==存储无序的、不可重复的数据== ==&gt; 高中数学中的“集合” Set判断两个对象是否相同不是使用 == 运算符，而是根据equals()方法 HashSet 作为Set接口的主要实现类；==是线程不安全的，可以存储null值==。 以HashSet为例说明：Set存储无序的、不可重复的数据: ==无序性==：==不等于随机性==。存储的数据在底层数组中并非按照数组索引的顺序添加，而是==根据数据的哈希值决定的== ==不可重复性==：保证添加的元素==按照equals()判断==时，不能返回true。即：相同的元素只能添加一个。—&gt; ==因此自定义类需要重写equals( )方法和hashCode( )方法，先比较hash值，再用equals( )比较== ==要求==： 向Set中添加元素所在类，其所在类一定要==重写hashCode()和equals()==； ==重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码== —&gt; 哈希值 ==重写两个方法的小技巧==：对象中用作equals()方法比较的Field，都应该用来计算hashCode值 1234567891011121314151617@Test public void addTest()&#123; HashSet set = new HashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [657, Tom, 123] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [AA, 657, Tom, 123, Jack] ---&gt; 无序性 &#125; ==添加元素的过程：以HashSet为例== 向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值 ==此哈希值接着通过某种算法，计算出在HashSet底层数组中的存放位置（即为：索引位置）== 判断数组此位置上是否已有元素： 没有其他元素==&gt;添加成功。==&gt;情况1 有其他元素b(或以链表形式存在的多个元素)，则比较元素a与b的哈希值: 哈希值不同==&gt;添加成功。==&gt;情况2 哈希值相同，进而调用元素a所在类的equals()方法： 返回false==&gt;添加成功。==&gt;情况3 返回true，则添加失败。 对于添加成功的情况2和3而言：元素a与已经存在指定索性位置上的数据以链表的方式存储。 jdk7：元素a放到数组中，指向原来的元素。（头插） jdk8：原来的元素在数组中指向a元素。（尾插） 总结：七上八下 ==HashSet底层：数组+链表的结构== ==问题==：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 1234选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）31只占用5bits,相乘造成数据溢出的概率较小。31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) LinkedHashSet 作为HashSet的子类；遍历其内部数据时，==可以按照添加顺序遍历==。==对于频繁的遍历操作，LinkedHashSet效率高于HashSet== LinkedHashSet ==根据元素的 hashCode 值来决定元素的存储位置==，但它同时==使用双向链表维护元素的次序==，这使得元素看起来是以插入顺序保存的 123456789101112131415161718@Test public void LinkedHashSet()&#123; LinkedHashSet set = new LinkedHashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [123, Tom, 657] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [123, Tom, 657, Jack, AA] ---&gt; 按照添加顺序遍历 &#125; TreeSet ==以按照添加对象的指定属性进行排序== 向TreeSet中添加的数据。要求是相同类的对象 两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）。默认情况下，TreeSet采用自然排序 ==自然排序中==，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals() ==定制排序中==，比较两个对象是否相同的标准为：compare()返回0，不再是equals() 新增方法 Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) ==TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快== User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class User implements Comparable &#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; //自然排序：默认从小到大排序 @Override public int compareTo(Object o) &#123; if (o instanceof User) &#123; User user = (User) o;// return this.name.compareTo(user.name); // 二级排序 int compare = -this.name.compareTo(user.name); // 加了负号，所以按照姓名从大到小排序 if (compare != 0) &#123; return compare; &#125; else &#123; return Integer.compare(this.age, user.age); // 年龄从小到大排列 &#125; &#125; else &#123; throw new RuntimeException(&quot;输入类型不匹配！&quot;); &#125; &#125;&#125; 自然排序实现==（实现Comparable接口）——&gt; 重写compareTo( )方法== 1234567891011121314151617public class UserTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125;User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125; 定制排序实现 构建comparator对象，并重写compare（）方法 将其作为形参传入User类的构造器中 12345678910111213141516171819202122232425262728293031public class UserTest &#123; public static void main(String[] args) &#123; Comparator comparator = new Comparator() &#123; //按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入数据类型不匹配&quot;); &#125; &#125; &#125;; TreeSet set = new TreeSet(comparator); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125; ==非常非常经典的面试题：== 1234567891011121314151617@Test public void test1() &#123; HashSet set = new HashSet(); Person p1 = new Person(1001, &quot;AA&quot;); Person p2 = new Person(1002, &quot;BB&quot;); set.add(p1); // 根据算法算出hash值h1，确定在set中的存储位置 set.add(p2); // 根据算法算出hash值，确定在set中的存储位置 p1.name = &quot;CC&quot;; // 只改变p1的属性值，但p1已存入set，在set中位置不变 set.remove(p1); // 根据此时的p1(属性改变后)计算出的hash值h2≠h1，所以没能删除set中的p1 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;CC&quot;)); // 根据算法算出hash值h2，此位置无元素，添加成功 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;AA&quot;)); // 计算出hash值h1与p1所在位置哈希值相同，调用 // Person中的equals()方法，返回结果为false，此对象以链表的形式存入数组中，添加成功。 System.out.println(set); // [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;] &#125; Map接口 概述： ==双列数据，存储key-value对的数据== ==&gt; 类似于高中的函数，类比其他语言中的==字典== ==Map中的key：无序的，不可重复的==，使用Set存储所有的key。 ==&gt; key所在的类必须要重写equals()和hashCode()==（以HashMap为例） ==Map中的value：无序的，可重复的==，==使用Collection存储所有的value==。 –&gt; ==value所在类要重写equals()== 一个键值对：==key-value构成一个Entry对象==。 ==Map中的Entry：无序的，不可重复的，使用Set存储所有entry==。 ==添加、删除、修改等操作== Object put(Object key,Object value):将制定key-value添加到（或修改）当前map对象中。 void putAll(Map m):将m中所有key-value对存放到当前map中。 Object remove(Object key):移除指定key的key-value对，并返回value。没有相应的key则返回null void clear():清空当前map中的所有数据。与map=null操作不同 ==元素查询的操作== Object get(Object key):获取指定key对应的value。没有相应的key则返回null boolean containsKey(Object key):是否包含指定的key。 boolean containsValue(Object value):是否包含指定的value。 int size():返回map中key-value对的个数。 boolean isEmpty(): 判断当前map是否为空。 boolean equals(Object obj):判断当前map和参数对象是否相等 ==元视图操作的方法== Set keySet():返回所有key构成的Set集合。 Collections values():返回所有value构成的Collection集合。 Set entrySet():返回所有key-value构成的Set集合 ==总结：常用方法== 添加：put(Object key,Object value) 12345678910@Test public void putTest()&#123; HashMap hashMap = new HashMap(); hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; &#125; 删除：remove(Object key) 12345678910111213141516@Test public void removeTest()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; //remove Object remove = hashMap.remove(2); System.out.println(remove); // Tom System.out.println(hashMap); // &#123;tt=546&#125; &#125; 修改：put(Object key,Object value) 12345678910111213141516171819@Test public void put2Test()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; //修改 hashMap.put(2, &quot;Jim&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Jim, 564=Tom, 6=324&#125; &#125;&#125; 查询：get(Object key) 长度：size() 遍历：keySet() / values() / entrySet() 123456789101112131415161718192021@Test public void test1()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; Set set = hashMap.keySet(); Collection values = hashMap.values(); Set set1 = hashMap.entrySet(); System.out.println(set); // [tt, 2, 564, 6] System.out.println(values); // [546, Tom, Tom, 324] System.out.println(set1); // [tt=546, 2=Tom, 564=Tom, 6=324] &#125; HashMap ==作为Map的主要实现类==；线程不安全，效率高；==存储null的key和value== ==底层实现原理：(jdk7)== 12345678HashMap map = new HashMap();//在实例化以后，底层创建了一个长度为16的一维数组Entry[] table。//...可能已经执行过多次put...map.put(key1,value1);//首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值通过某种算法计算后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。---情况1/*如果，此位置上的数据不为空，(意味着此位置上一个或多个数据(以链表形式存在))，比较key1与已经存在的一个或多个数据的哈希值： 如果key1与已经存在的数据的哈希值都不相同，key1-value1添加成功。---情况2 如果key1与已经存在的某个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较： equals()返回false，添加成功。---情况3 equals()返回true，使用value1替换value2值。*/ ==补充==： 情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。 默认扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。 ==jdk8相较于jdk7在底层实现方面的不同== new HashMap()：底层没有创建一个长度为16的数组； jdk8底层的数组是Node[]，而非Entry[]； 首次调用put()时，底层创建长度为16的数组； jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 当某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组长度 &gt; 64 时，此索引位置上的的所有数据改为用红黑树存储。 HashMap的存储结构 ==几个常量值== —&gt; ==底层源码== DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75 threshold：扩容的临界值等于容量x填充因子：16*0.75 = 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64 table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数 threshold：扩容的临界值 = 容量*填充因子 loadFactor：填充因子 ==面试题==：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？ ==面试题==：负载因子的值太小，对HashMap有什么影响？ 1234负载因子的大小决定了HashMap的数据密度。负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 LinkedHashMap 概述 作为HashMap的子类 保证在遍历map元素时，可以按照添加的顺序实现遍历。 原理：在原有的HashMap地层结构基础上，添加了一对指针，指向前一个和后一个元素。 对于频繁的遍历操作，此类执行效率高于HashMap。 底层实现原理：(了解) 1234567//源码：static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after;//能记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 12345678910111213141516@Test public void LinkedHashMapTest()&#123; LinkedHashMap linkedHashMap = new LinkedHashMap(); //put linkedHashMap.put(2, &quot;Tom&quot;); linkedHashMap.put(&quot;tt&quot;, 546); linkedHashMap.put(6, 324); linkedHashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(linkedHashMap); // &#123;2=Tom, tt=546, 6=324, 564=Tom&#125; // 修改 linkedHashMap.put(2, &quot;Jack&quot;); System.out.println(linkedHashMap); // &#123;2=Jack, tt=546, 6=324, 564=Tom&#125; &#125; TreeMap ==保证按照添加的key-value对进行排序，实现遍历。此时考虑key的自然和定制排序==。==底层使用红黑树存储==。 向TreeMap中添加key-value，==要求key必须是由同一个类创建的对象==，因为要按照key进行自然排序、定制排序。 排序类似于之前的TreeSet。 ———&gt; ==同一个treeMap中的key的类型必须一致，意味着只能有仅只有一个类型的数据== ==TreeMap判断两个key相等的标准==：两个key通过compareTo()方法或者compare()方法返回0。———&gt; 因此涉及到了方法的重写 12345678910111213141516171819202122@Test public void TreeMapTest()&#123; TreeMap treeMap = new TreeMap(); treeMap.put(&quot;fsad&quot;, 453); treeMap.put(&quot;2&quot;, &quot;sad&quot;); treeMap.put(&quot;J&quot;, 435); System.out.println(treeMap); // &#123;2=sad, J=435, fsad=453&#125; treeMap.put(&quot;2&quot;, &quot;happy&quot;); System.out.println(treeMap); // &#123;2=happy, J=435, fsad=453&#125; //key的类型不一致，故而抛出异常 /** * java.lang.ClassCastException: class java.lang. * String cannot be cast to class java.lang.Integer (java.lang.String * and java.lang.Integer are in module java.base of loader &#x27;bootstrap&#x27;) */ Object put = treeMap.put(3, 342); System.out.println(put); &#125; Hashtable 作为Map古老的实现类(jdk1.0)；线程安全的，效率低；不能存储null的key和value。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序。 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Properties Properties 类是 Hashtable 的子类，常用来处理配置文件。key和value都是Sting类型。 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。 ==Collections工具类==概述 Collections 是一个操作 Set、List 和 Map 等集合的工具类。 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 ==常用方法== ==排序操作：(均为非static方法)== reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 ==查找、替换== Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package chapter_11;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @author Justry * @Description * @date 2020-11-28 11:52 上午 */public class CollectionsTest &#123; @Test public void Test1()&#123; ArrayList arrayList = new ArrayList(); arrayList.add(&quot;Tom&quot;); arrayList.add(546); arrayList.add(324); arrayList.add(&quot;Jack&quot;); System.out.println(arrayList); // [Tom, 546, 324, Jack] // reverse Collections.reverse(arrayList); System.out.println(arrayList); // [Jack, 324, 546, Tom] // swap Collections.swap(arrayList, 0, 2); System.out.println(arrayList); // [546, 324, Jack, Tom] //copy List&lt;Object&gt; arrayList1 = Arrays.asList(new Object[arrayList.size()]); System.out.println(arrayList1); // [null, null, null, null] Collections.copy(arrayList1, arrayList); System.out.println(arrayList1); // [546, 324, Jack, Tom] &#125;&#125; ==同步控制==： Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。 12// synchronizedXxx() List list = Collections.synchronizedList(arrayList); // 返回的list为线程安全的 补充：Enumeration Enumeration 接口是 Iterator 迭代器的 “古老版本”。 hasMoreElements() nextElement() 12345Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;);while(stringEnum.hasMoreElements())&#123; Object obj = stringEnum.nextElement(); System.out.println(obj);&#125; ==面试题==：Collection 和 Collections的区别？","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十二章 泛型","slug":"Java基础/第十二章 泛型","date":"2020-11-26T14:23:19.245Z","updated":"2020-12-10T13:19:07.252Z","comments":true,"path":"undefined/95b4.html","link":"","permalink":"https://asteroidcs.github.io/undefined/95b4.html","excerpt":"","text":"范型的理解为什么要有泛型? 解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。 什么是范型？ 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 泛型的引入背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。 在集合中使用泛型​ ==使用范型的时候，这个范型指的是基本数据类型，即&lt;&gt;中不能放int、double、float等，应该放它们的包装类== 使用 使用范型之前的情况 12345678910111213141516@Test public void test1() &#123; ArrayList list = new ArrayList();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //问题一：；类型不安全// list.add(&quot;Tom&quot;); for (Object score : list) &#123; //问题二：强转时，可能会出现类型异常ClassCastException int stuScore = (Integer) score; System.out.println(stuScore); &#125; &#125; 使用范型的情况：以ArrayList为例 1234567891011121314151617181920212223@Test public void test2() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //编译时，就会进行类型检查，保证数据安全// list.add(&quot;Tom&quot;); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;// System.out.println(stuScore);// &#125; //方式二：Iterator Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; 使用泛型的情况：以HashMap为例 12345678910111213141516171819202122@Test public void test3() &#123;// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk新特性：类型推断 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;, 87); map.put(&quot;Jerry&quot;, 90); map.put(&quot;Jack&quot;, 66);// map.put(123,&quot;ABC&quot;); //泛型嵌套 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;--&gt;&quot; + value); &#125; &#125;： ==总结== 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型 比如：add(E e) —&gt;实例化以后：add(Integer e) ==注意点==：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型 自定义泛型类、泛型接口、泛型方法 范型的声明 12interface List&lt;T&gt; 和 class GenTest&lt;K,V&gt;其中，T，K，V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写 范型的实例化 12345//一定要在类名后面指定类型参数的值（类型）。如List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator();//T只能是累，不能用基本数据类型填充。但可以使用包装类填充//把一个集合中的内容限制为一个制定的数据类型，这就是generics背后的核心思想 泛型类 使用 12345678910111213141516171819202122232425public class Order&lt;T&gt; &#123; String OrderName; int orderId; //类的内部结构就可以使用类的范型 T orderT; //这里的T目前不确定什么类型，实例化的时候才会确定 public Order()&#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; OrderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125;&#125; 123456789101112@Test public void test4() &#123; //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;abc&quot;); //建议：实例化时指明类的泛型 Order&lt;String&gt; stringOrder = new Order&lt;String&gt;(&quot;orderAA&quot;, 1001, &quot;order:AA&quot;); stringOrder.setOrderT(&quot;AA:hello&quot;); &#125; ==细节== 范型类可能有多个参数，此时应该将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 范型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass(){} 实例话后，操作原来范型位置的结构必须与指定的范型类型一致 范型不同的引用不能相互赋值 尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中 范型如果不指定，将被擦除，范型对应的类型均按照Object处理，但不等价于Object。经验：范型要使用一路都用。要不用，一路都不要用 如果范型结构是一个接口或抽象类，则不创建范型类的对象 Jdk1.7，范型的简化操作：ArrayList flist = new ArrayList&lt;&gt;() 范型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的范型，在本类或本接口中即代表某种类型，可以作为静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的范型 异常类不能是范型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capcity]； 参考：ArrayList源码中声明：Object[] elementData，而非范型参数类型数组 父类有范型，子类可以选择保留泛型也可以选择指定泛型类型 子类不保留父类的泛型：按需实现 自类保留父类的泛型：泛型子类 ==总结==： 类的内部结构就可以使用类的范型 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 泛型方法 方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型，与类的泛型类没有任何关系 泛型方法的格式 1[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常 泛型方法声明泛型时也可以指定上限 泛型在继承上的体现 泛型在继承方面的体现* * 虽然类A是类B的父类，但是G 和*G二者不具备子父类关系，二者是并列关系。 * 补充：类A是类B的父类，A 是 B 的父类 通配符 使用类型==通配符:?== 比如:List ，Map List&lt;?&gt;是List、List等各种泛型List的父类 读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object 对于List&lt;?&gt;不能向其内部添加数据——&gt;因为我们不知道c的元素类型，我们不能向其中添加对象 唯一的例外是null，它是所有类型的成员 将任意元素加入到其中不是类型安全的 12Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); // 编译时错误 可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。 注意点 不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用 不能用在泛型类的声明上 不能用在创建对象上，右边属于创建集合对象 有限制条件的通配符 通配符指定上限：上限extends:使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 12? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 通配符指定下限：下限super:使用时指定的类型不能小于操作的类，即&gt;= 12? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 举例 12345678&lt;? extends Number&gt;//只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt;//只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt;//只允许泛型为实现Comparable接口的实现类的引用调用","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"贪吃蛇","slug":"小游戏/贪吃蛇","date":"2020-08-11T16:00:00.000Z","updated":"2020-12-10T13:24:03.651Z","comments":true,"path":"undefined/43fa.html","link":"","permalink":"https://asteroidcs.github.io/undefined/43fa.html","excerpt":"","text":"Java：贪吃蛇游戏笔记分析 创建一个窗体，用于游戏界面显示 ——&gt; 继承Java中的JFrame窗体类，设置自定义的参数 创建游戏棋盘，用于Snake移动 ——&gt; JPanel类的实例化，并且重写其中的 paint() 方法 采用链表的方式创建蛇身，移动以增删节点表示，头插法增加节点，方向采用头节点的横纵坐标加1添加节点 方向的改变用KeyListener来实现，每移动一次都需要重新绘制棋盘 蛇的运动采用timer调用timer task来反复执行蛇的移动 蛇撞墙：蛇头的横纵坐标超过了窗体的边界 蛇追尾：蛇头的坐标与其身体的任意节点坐标相等 创建窗体 创建一个MainFrame类继承JFrame，表示主窗口 定义窗体的空参构造器，初始化窗体参数 初始化窗体参数的方法 12345678public class MainFrame extends JFrame &#123; //定义窗体的空参构造器，初始化窗体参数 public MainFrame() throws HeadlessException &#123; //初始化窗体参数的方法 initFrame(); &#125;&#125; MainFrame类中写一个initFrame方法，初始化窗体参数： 窗体标题：setTitle() 窗体尺寸：setSize() 窗体固定显示位置：setLocation() 窗体大小能否改变：setResizable() 窗体关闭按钮的作用：setDefaultCloseOperation() 123456789101112private void initFrame() &#123; //窗体标题 setTitle(&quot;贪吃蛇&quot;); //窗体尺寸 setSize(610, 640); //固定窗体显示位置 setLocation(600, 200); //设置窗体大小不能改变 setResizable(false); //设置窗体关闭按钮的作用（退出程序） setDefaultCloseOperation(EXIT_ON_CLOSE); &#125; 在MainFrame中添加一个main方法，创建窗体并运行，就可以看到窗口了 窗体类实例化 显示窗体 123456public static void main(String[] args) &#123; //窗体类实例化 MainFrame mainFrame = new MainFrame(); //显示窗体 mainFrame.setVisible(true); &#125; 创建游戏棋盘 在JFrame类中写一个initGamePanel方法，初始化游戏棋盘 JPanel类实例化，并重写其中的paint方法 ——&gt; paint是用来绘制面板中的内容—棋盘格 设置画笔的颜色：setColor（） 绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（） 绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（） 将棋盘添加到窗体中：add( ) 123456789101112131415161718192021222324private void initGamePanel() &#123; //JPanel实例化，并重写其中的paint方法 JPanel jPanel = new JPanel() &#123; //paint是用来绘制面板中的内容 @Override public void paint(Graphics g) &#123; //g 相当于一个画笔，用于绘制 //设置画笔的颜色 g.setColor(Color.BLACK); //绘制棋盘 //绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标） for (int i = 0; i &lt;= 40; i++) &#123; g.drawLine(0, i * 15, 600, i * 15); &#125; //绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标） for (int j = 0; j &lt;= 40; j++) &#123; g.drawLine(j * 15, 0, j * 15, 600); &#125; &#125; &#125;; //将棋盘添加到窗体中 add(jPanel); &#125; 创建蛇的节点：用于构建蛇与食物 创建节点类： 在棋盘上以横纵坐标创建一个节点 随机生成节点位置：用于随机生成食物 random()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Node &#123; private int x; // 横坐标 private int y; // 纵坐标 // 空参构造器 public Node() &#123; &#125; // 带参构造器 public Node(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; //随机生成位置：用于随机生成食物 public void random() &#123; //创建Random对象 Random random = new Random(); //随机生成横坐标 this.x = random.nextInt(40); //随机生成纵坐标 this.y = random.nextInt(40); &#125;&#125; 创建蛇身：采用链表的方式构建蛇 多个节点构成蛇身 1234567891011121314151617181920212223242526public class Snake &#123; //蛇的身体 private LinkedList&lt;Node&gt; snakeBody; public Snake() &#123; //初始化蛇身 initSnake(); &#125; //初始化蛇身 private void initSnake() &#123; //创建集合 snakeBody = new LinkedList&lt;&gt;(); //创建节点，添加到集合中 snakeBody.add(new Node(16, 20)); snakeBody.add(new Node(17, 20)); snakeBody.add(new Node(18, 20)); snakeBody.add(new Node(19, 20)); snakeBody.add(new Node(20, 20)); &#125; public LinkedList&lt;Node&gt; getSnakeBody() &#123; return snakeBody; &#125;&#125; 把🐍绘制到棋盘上 在MainFrame类中实现Snake类对象化 123456private Snake snake; //蛇//初始化蛇 private void initSnake() &#123; snake = new Snake(); &#125; 在MainFrame类中的initGamePanel方法中写入绘制蛇身的代码 绘制蛇身：fillRect（）——&gt; 绘制节点的方法 12345//绘制蛇LinkedList&lt;Node&gt; body = snake.getSnakeBody();for (Node node : body) &#123; g.fillRect(node.getX() * 15, node.getY() * 15, 15, 15);&#125; 让蛇移动 定义枚举类Direction，存放蛇移动的方向 123public enum Direction &#123; UP, DOWN, LEFT, RIGHT&#125; 在Snake类中定义direction属性，用于控制蛇的运动方向，默认向左 12//蛇的运动方向：默认向左 private Direction direction = Direction.LEFT; 在Snake类中写一个move（）方法，控制蛇移动 蛇会沿着蛇头的方向移动 控制蛇移动：蛇头添加节点，蛇尾删除节点 1234567891011121314151617181920212223242526//蛇会沿着蛇头的方向移动 //控制蛇移动：蛇头添加节点，蛇尾删除节点 public void move() &#123; ////获取蛇头 Node head = snakeBody.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 snakeBody.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 snakeBody.removeLast(); &#125; 采用定时器，在指定时间内调用蛇移动 每次移动后都需要重新绘制棋盘 123456789101112131415161718192021222324252627282930313233public class MainFrame extends JFrame &#123; ... private Timer timer; //定时器，在指定时间内调用蛇移动的方法 public MainFrame() throws HeadlessException &#123; ... //初始化定时器 initTimer(); &#125; private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; //蛇移动 snake.move(); //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; &#125; 添加键盘监听 设置键盘监听，让蛇随着上下左右移动，addKeyListener（） 蛇的运动方向不能与当前方向相反 每次按下方向键都会改变蛇的运动方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainFrame extends JFrame &#123; ... public MainFrame() throws HeadlessException &#123; ... //设置键盘监听，让蛇随着上下左右移动 setKeyListener(); &#125; private void setKeyListener() &#123; addKeyListener(new KeyAdapter() &#123; //当键盘按下时会自动调用此方法 @Override public void keyPressed(KeyEvent e) &#123; //键盘中每一个键都有一个编号 switch (e.getKeyCode()) &#123; case KeyEvent.VK_UP: // 上键 //修改蛇的运动方向不能与当前方向相反 if (snake.getDirection() != Direction.DOWN) &#123; //修改蛇的运动方向 snake.setDirection(Direction.UP); &#125; break; case KeyEvent.VK_DOWN: // 下键 if (snake.getDirection() != Direction.UP) &#123; snake.setDirection(Direction.DOWN); &#125; break; case KeyEvent.VK_LEFT: //左键 if (snake.getDirection() != Direction.RIGHT) &#123; snake.setDirection(Direction.LEFT); &#125; break; case KeyEvent.VK_RIGHT: // 右键 if (snake.getDirection() != Direction.LEFT) &#123; snake.setDirection(Direction.RIGHT); &#125; break; &#125;a &#125; &#125;); &#125;&#125; 添加边界处理 当蛇移动到边界处就游戏结束，把标记改为false 123456public class Snake &#123; ... //定义一个标记true表示蛇还活着，可以运动 private boolean isLiving = true;&#125; 判断蛇是否撞墙：头节点的坐标是否越界 12345//判断蛇是否撞墙head = body.getFirst();if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false;&#125; 判断蛇是否碰到自己的身体：头节点坐标与任意身体节点的坐标一致 123456for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125;&#125; 优化move( )代码 1234567891011121314151617181920212223242526272829303132333435363738394041public void move() &#123; if (isLiving) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 body.removeLast(); //判断蛇是否撞墙 head = body.getFirst(); if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false; &#125; //判断蛇是否碰到自己的身体 for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125; &#125; &#125; &#125; 把食物绘制到棋盘上 此处的食物就是节点 12345678910111213141516171819202122public class MainFrame extends JFrame &#123; ... private Node food; //食物 public MainFrame() throws HeadlessException &#123; ... //初始化食物 initFood(); &#125; private void initFood() &#123; food = new Node(); food.random(); // food随机出现 &#125; private void initGamePanel() &#123; ... //绘制食物 g.fillRect(food.getX() * 15, food.getY() * 15, 15, 15); &#125;&#125; 吃食物 吃食物：沿着蛇头的移动方向添加节点 1234567891011121314151617181920212223//吃食物：沿着蛇头的移动方向添加节点 public void eat(Node food) &#123; //获取蛇头 Node head = snakeBody.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 snakeBody.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; &#125; 吃食物：判断蛇头是否和食物重合，即头节点坐标与食物坐标一致 12345678910111213141516171819202122232425private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; snake.move(); //吃食物：判断蛇头是否和食物重合 Node head = snake.getSnakeBody().getFirst(); if (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123; snake.eat(food); food.random(); &#125; //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; 完整代码MainFrame类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package Snake;import javax.swing.*;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.util.LinkedList;import java.util.Timer;import java.util.TimerTask;/** * @author Justry * @Description 窗体设置 * @date 2020-12-07 7:31 下午 *///java中有准备好的窗体类，继承即可public class MainFrame extends JFrame &#123; private Snake snake; //蛇 private JPanel jPanel; //游戏棋盘 private Timer timer; //定时器，在指定时间内调用蛇移动的方法 private Node food; //食物 //构造器 public MainFrame() throws HeadlessException &#123; //初始化窗体参数 this.initFrame(); //初始化游戏棋盘 this.initGamePanel(); //初始化蛇 this.initSnake(); //初始化食物 initFood(); //初始化定时器 initTimer(); //设置键盘监听，让蛇随着上下左右移动 setKeyListener(); &#125; public static void main(String[] args) &#123; //创建窗体对象，并显示 MainFrame mainFrame = new MainFrame(); mainFrame.setVisible(true); &#125; private void initFood() &#123; food = new Node(); food.random(); &#125; private void setKeyListener() &#123; addKeyListener(new KeyAdapter() &#123; //当键盘按下时会自动调用此方法 @Override public void keyPressed(KeyEvent e) &#123; //键盘中每一个键都有一个编号 switch (e.getKeyCode()) &#123; case KeyEvent.VK_UP: // 上键 //修改蛇的运动方向不能与当前方向相反 if (snake.getDirection() != Direction.DOWN) &#123; //修改蛇的运动方向 snake.setDirection(Direction.UP); &#125; break; case KeyEvent.VK_DOWN: // 下键 if (snake.getDirection() != Direction.UP) &#123; snake.setDirection(Direction.DOWN); &#125; break; case KeyEvent.VK_LEFT: //左键 if (snake.getDirection() != Direction.RIGHT) &#123; snake.setDirection(Direction.LEFT); &#125; break; case KeyEvent.VK_RIGHT: // 右键 if (snake.getDirection() != Direction.LEFT) &#123; snake.setDirection(Direction.RIGHT); &#125; break; &#125; &#125; &#125;); &#125; private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; snake.move(); //吃食物：判断蛇头是否和食物重合 Node head = snake.getBody().getFirst(); if (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123; snake.eat(food); food.random(); &#125; //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; //初始化蛇 private void initSnake() &#123; snake = new Snake(); &#125; //初始化游戏棋盘 private void initGamePanel() &#123; //匿名内部类 jPanel = new JPanel() &#123; @Override public void paint(Graphics g) &#123; //清空棋盘 g.clearRect(0, 0, 600, 600); //Graphics g 相当于一个画笔，用于绘制 //绘制横线 for (int i = 0; i &lt;= 40; i++) &#123; g.drawLine(0, i * 15, 600, i * 15); &#125; //绘制竖线 for (int j = 0; j &lt;= 40; j++) &#123; g.drawLine(j * 15, 0, j * 15, 600); &#125; //绘制蛇 LinkedList&lt;Node&gt; body = snake.getBody(); for (Node node : body) &#123; g.fillRect(node.getX() * 15, node.getY() * 15, 15, 15); &#125; //绘制食物 g.fillRect(food.getX() * 15, food.getY() * 15, 15, 15); &#125; &#125;; //把棋盘添加到窗体中 this.add(jPanel); &#125; //初始化窗体参数 private void initFrame() &#123; //设置窗体标题 this.setTitle(&quot;贪吃蛇&quot;); //设置窗体宽高 this.setSize(600, 615); //设置窗体位置 this.setLocation(600, 200); //设置关闭按钮的作用（退出程序） this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置窗体大小不可变 this.setResizable(false); &#125;&#125; Node类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package Snake;import java.util.Random;/** * @author Justry * @Description 节点类：每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置 * @date 2020-12-07 8:14 下午 */public class Node &#123; private int x; private int y; public Node() &#123; &#125; public Node(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; //随机生成位置 public void random() &#123; //创建Random对象 Random random = new Random(); //随机生成横坐标 this.x = random.nextInt(40); //随机生成纵坐标 this.y = random.nextInt(40); &#125;&#125; Snake类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package Snake;import java.util.LinkedList;/** * @author Justry * @Description 每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置，采用链表的方式构建蛇 * @date 2020-12-07 8:25 下午 */public class Snake &#123; //蛇的身体 private LinkedList&lt;Node&gt; body; //蛇的运动方向：默认向左 private Direction direction = Direction.LEFT; //蛇是否活着 private boolean isLiving = true; //构造方法，在创建Snake对象时执行 public Snake() &#123; //初始化蛇身 initSnake(); &#125; //初始化蛇身 private void initSnake() &#123; //创建集合 body = new LinkedList&lt;&gt;(); //创建节点，添加到集合中 body.add(new Node(16, 20)); body.add(new Node(17, 20)); body.add(new Node(18, 20)); body.add(new Node(19, 20)); body.add(new Node(20, 20)); &#125; public LinkedList&lt;Node&gt; getBody() &#123; return body; &#125; //蛇会沿着蛇头的方向移动 //控制蛇移动：蛇头添加节点，蛇尾删除节点 public void move() &#123; if (isLiving) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 body.removeLast(); //判断蛇是否撞墙 head = body.getFirst(); if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false; &#125; //判断蛇是否碰到自己的身体 for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125; &#125; &#125; &#125; public Direction getDirection() &#123; return direction; &#125; public void setDirection(Direction direction) &#123; this.direction = direction; &#125; //吃食物：沿着蛇头的移动方向添加节点 public void eat(Node food) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; &#125;&#125; Direction类12345678910package Snake;/** * @author Justry * @Description 枚举 * @date 2020-12-07 8:53 下午 */public enum Direction &#123; UP, DOWN, LEFT, RIGHT&#125; 游戏界面","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"game","slug":"Java/game","permalink":"https://asteroidcs.github.io/categories/Java/game/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"},{"name":"游戏","slug":"游戏","permalink":"https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"第一章 Java语言概述","slug":"Java基础/第一章 Java语言概述","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:17:28.105Z","comments":true,"path":"undefined/e28.html","link":"","permalink":"https://asteroidcs.github.io/undefined/e28.html","excerpt":"","text":"基础知识图解 软件开发介绍基础常识 软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件 系统软件：Windows，Mac os，linux，unix，android，iOS… 应用软件：word，ppt，画图板… 人机交互方式：图形化界面 vs 命令行方式 应用程序 = 算法 ➕ 数据结构 常用的DOS指令 dir：列出当前目录下的文件以及文件夹 md：创建目录 rd；删除目录 cd：进入目录 cd..：返回到上一级目录 cd\\：退回到根目录 del：删除文件 exit：推出dos命令行 ech javase&gt;：创建文件，如：ech javase&gt;1.doc，ech javase &gt; 1.jpg 常用快捷键 ⬅️ ➡️：移动光标 ⬆️ ⬇️：调阅历史操作命令 Delete 和 Backspace：删除字符 计算机语言的发展迭代史 第一代：机器语言：指令以二进制代码形式存在 第二代：汇编语言：使用助记符表示一条机器指令 第三代：高级语言： 面向过程：C、Pascal、Fortran 面向对象：Java、JS、Python、Scala… Java语言应用的领域 Java Web开发：后台开发 大数据开发： Android应用程序开发：客户端开发 Java语言特点 面向对象性： 两个要素：类、对象 三个特征：封装、继承、多态 健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏 跨平台型：write once，run anywhere：一次编译，到处运行 原理：只需要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM JAVA Virtual Machine）即可。由JVM来负责Java程序在该系统中的运行。 Java核心机制Java虚拟机 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器 对于不同的平台，由不同的虚拟机 只有某平台提供了对应的java虚拟机，java程序才可在此平台运行 java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” 垃圾回收 不再使用的内存空间应回收——垃圾回收 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预 Java程序==还会出现内存泄漏和内存溢出问题== Java语言的环境搭建什么是JDK，JRE JDK(Java Development Kit Java开发工具包) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了 JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等 RE(Java Runtime Environment Java运行环境) 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等， 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 Java语言的环境搭建:JDK、JRE、JVM关系 开发体验— HelloWorld 注释(Comment)Java中的注释类型 //单行注释 /* 多行注释 */ /** 文档注释（Java特有） **/ 单行和多行注释的作用 对所写程序进行解释说明，增强可读性，方便自己和别人。 调试所写代码（注释掉不需要运行部分）。 特点：单行和多行注释掉的内容不参与编译，编译以后生成的.class文件中不包含注释掉的信息。 文档注释的使用 注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。 操作方式 &gt;javadoc -d [生成文件名] -author -version [解析文件名.java]（-author和-version分别为注释当中@author和@version后面的内容） 注意：多行注释不能嵌套使用 第1个Java代码12345public class Hello&#123; public static void main(String[] args)&#123;//arguments参数 System.out.println(&quot;Hello World !&quot;); &#125; &#125; 对第一个Java程序总结 java程序的编写-编译-运行的过程 编写：我们将编写的java代码保存在以“.java”结尾的源文件中 编译：使用javac.exe来编译我们的java源文件。格式：javac 源文件名.java 运行：使用java.exe解释运行我们的字节码文件（.class)。格式：java 类名 在一个java源文件中可以声明多个类（class），但是只能有一个类声明为public的，而且要求声明为public的类的类名必须与源文件名必须相同。 程序的入口是main()方法，格式是固定的。可以写成：public static void main(String[] args)或public static void main(String[] a)或public static void main(String a[]) 输出语句 System.out.println()：输出后换行，无内容则只换行 System.out.print()：输出后不换行 每一个执行语句都以分号结尾，每个执行语句只要以分号隔开即使不换行也不影响执行 编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。 知识点： java语言的特点是什么？ 123面向对象性：两个基本概念：类、对象；三大特性：封装、继承、多态健壮性：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” System.out.println()和System.out.print()有什么区别？ 1前者输出内容后换行，后者输出后不换行。 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 1答：可以。但最多只有一个类名声明为public，与文件名相同。 JDK,JRE和JVM的关系是什么？以及JDK、JRE包含的主要结构有哪些？ 123关系：JDK包含JRE，JRE包含JVMJDK = JRE + Java开发工具（javac.exe、java.exe、javadoc.exe）JRD = JVM + Java核心类库","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第三章 数组","slug":"Java基础/第三章 数组","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:19:12.677Z","comments":true,"path":"undefined/4fb4.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4fb4.html","excerpt":"","text":"数组的概述 数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。 数组的常见概念 数组名 标（或索引） 元素 数组的长度：元素的个数 特点 数组是有序排列的； 数组属于引用数据类型，但是数组的元素既可以是基本数据类型，也可以是引用数据类型； 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址； 数组的长度一旦确定，就不能修改； 可以通过下标（或索引）的方式调用指定位置的元素，速度很快。 数组的分类 按照维数：一维数组、二维数组…… 按照数组元素类型分类：基本数据类型元素的素组、引用数据类型元素的数组。 数据结构 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多 数据的存储结构： 线性表：顺序表（比如：数组）、链表、栈、队列 树形结构：二叉树 图形结构： 算法 排序算法 搜（检索）索算法 一维数组的使用一维数组的声明和初始化 声明：int[] ins; 静态初始化：数组的初始化和数组的赋值操作同时进行。 int ids = new int[]&#123;1001,1002,1003,1004&#125;; 动态初始化：数组的初始化和数组的赋值操作分开进行 String[] names = new String[5]; 错误写法 int[] arr1 = new int[]; int[5] arr2 = new int[5]; int [] arr3 = new int[3]&#123;1,2,3&#125;; 总结：数组一旦初始化完成，其长度就确定了。 数组的基本操作 如何调用数组指定函数指定位置的函数 通过索引（角标）的方式调用，索引（角标）从0开始，直到数组的长度-1结束 如何获取数组的长度 属性：length 使用：names.length 遍历数组 for(int i = 0; i &lt; names.length; i++)&#123;&#125; 数组元素的默认初始化值 数组的内存解析 栈（stack）：存放局部变量 堆（heap)：存放new出来的结构（对象数组） 方法区：常量池、静态域 内存的简化结构 解析 栈中的所有地址为Java虚拟机计算出来的哈希地址，并非真正的内存地址 多维数组的使用二维数组 理解：对于二维数组的理解，可以看成是一维数组array1的元素而存在。从数组底层的运行机制来看，其实没有多维数组。 二维数组的使用 123456789int[][] arr1 = new int[][]&#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;;//静态初始化String[][] arr2 = new String[3][2];//动态初始化1String[][] arr3 = new String[3][];//动态初始化2//错误情况String[][] arr4 = new String[][4];String[4][3] arr5 = new String[][];int[][] arr6 = new int[4][3]&#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; Tips：中括号（[]）的位置可以放在类名或者变量名后面；或者类名后面放一个，变量名后面放一个（二维数组）。 类型推断：int[][] arr7 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; //省略new int[][] 数组的基本操作 如何调用数组指定位置的函数 arry[i][j]; //第i行第j列的元素 如何获取数组长度 arr4.length; arr4[0].length; 如何遍历数组 12345for(int i = 0; a &lt;= arr4.length; i++)&#123; for(int j = 0; j &lt;= arr4[i].length)&#123; //执行语句 &#125;&#125; 数组元素的默认初始化值 规定：二维数组分为外层数组的元素和内层数组的元素 int[][] arr = new int[4][3]; 外层元素：arr[0]，arr[1]等； 内层元素：arr[0][0]，arr[1][2]等； 初始化方式一：int[][] arr = new int[4][3]; 外层元素的初始化值为：地址值 内层元素的初始化值：与一维数组初始化情况相同 初始化方式二：int[][] arr = new int[4][]; 外层元素的初始化值为：null 内层元素的初始化值为：不能调用，否则报错 数组中涉及到的常见算法 数组元素的赋值（杨辉三角、回形书等）（面试常考） 求数值型数组中元素的最大值、最小值、平均数、总数等 1234567891011121314151617181920212223242526272829303132333435363738package com.dawnlee.arrayex;/** * * @Description 求数值型数组中元素的最大值、最小值、平均数、总和等 * @author DawnLee * @version 1.0 * @data 2020-7-27 22:14:07 * */public class NumArray &#123; public static void main(String[] args) &#123; int[] array = new int[10]; int maxValue = 0; int minValue = 0; int avg = 0; int sum = 0; for(int i = 0;i &lt; array.length;i++) &#123; array[i] = (int)(Math.random() * (99 - 10 + 1) + 10); System.out.print(array[i] + &quot; &quot;); if(array[i] &gt; maxValue) &#123; maxValue = array[i]; &#125; sum += array[i]; &#125; minValue = array[0]; for(int i = 0;i &lt; array.length;i++) &#123; if(array[i] &lt; minValue) &#123; minValue = array[i]; &#125; &#125; avg = sum / array.length; System.out.println(&quot;\\n最大值为：&quot; + maxValue); System.out.println(&quot;最小值为：&quot; + minValue); System.out.println(&quot;平均数为：&quot; + avg); System.out.println(&quot;总和为：&quot; + sum); &#125;&#125; 数组的复制、反转、查找（线性查找、二分法查找）（面试会考） 复制：通过遍历元素的方式进行复制操作，赋值只能使得新数组值相同一块内存区域，修改其中一个，原数组就得一起改变，相当于Linux中的硬链接 反转：通过中间变量实现反转 查找 线性查找 123456789101112String dest = &quot;BB&quot;;boolean isFind = false;for(i = 0;i &lt; arr.length;i++)&#123; if(dest.equals(arr[i]))&#123; System.out.println(&quot;找到了指定元素，位置为：&quot; + i); isFind = true; break; &#125;&#125;if(isFind == false)&#123; System.out.println(&quot;没找到！&quot;);&#125; 二分法查找 123456789101112131415161718192021//所有要查找的数组必须有序int[] arr2 = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int dest1 = -34;int head = 0;//初始首索引int end = arr2.length - 1;//初始末索引boolean isFind = false;while(head &lt;= end)&#123; int mid = (head + end)/2; if(dest1 == arr2[mid])&#123; System.out.println(&quot;找到了指定的元素，位置为：&quot; + mid); isFind = true; break; &#125;else if(arr2[mid] &gt; dest1)&#123; end = mid - 1; &#125;else&#123; head = mid + 1; &#125;&#125;if(isFind == false)&#123; System.out.println(&quot;很遗憾，没有找到！&quot; );&#125; 数组元素的排序算法（面试最常考） 排序：假设含有n个记录的序列为(R1, R2,…, Rn)，其相应的关键字序列为(K1, K2,…, Kn)。将这些记录重新排序为(Ri1, Ri2,…, Rin)，使得相应的关键字满足条件Ki1 &lt;= Ki2 &lt;=…&lt;= Kin，这样的一种操作成为排序。 通常来说，排序的目的是快速查找。 衡量排序算法的优劣 时间复杂度：分析关键字的比较次数和记录的移动次数。 空间复杂度：分析排序算法中徐需要多少辅助内存。 稳定性：若两个记录A和B的关键字值相等，但排序后A、B先后次序保持不变，则称这种排序算法是稳定的。 排序算法分类 内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。 十大内部排序算法（和具体语言无关），前八种较常用 (数据结构与算法中学) 各种排序算法的比较 从平均时间而言：快速排序最佳，但在最坏的情况下，时间性能不如堆排序和归并排序。 从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。 从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序。 从待排序的记录数n的大小看：n较小时，宜采用简单排序；而n较大时，宜采用改进排序。 排序算法的选择 若n较小（如n≤50），可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。 若文件初始状态基本有序（正序），则应选用直接插入、冒泡或随机的快速排序为宜。 若n较大，则应采用时间复杂度为O（nlgn）的排序方法：快速排序、堆排序或归并排序 算法五大特征 Arrays工具类的使用 java.util.Arrays类即为操作数组的工具类，它包含了用来操作数组（比如排序和搜索）的各种方法。 12345678910111213141516171819202122232425262728293031323334353637383940package com.dawnlee.arrayex;import java.util.Arrays;/** * * @Description java.util.Arrays：操作数组的共工具类，里面定义了很多操作数组的方法 * @author DawnLee * @version 1.0 * @data 2020-7-28 16:56:11 * */public class ArraysTest &#123; public static void main(String[] args) &#123; //1.boolean equals(int[] a,int[] b):判断两个数组是否相等 int[] arr1 = new int[] &#123;1,2,3,4&#125;; int[] arr2 = new int[] &#123;1,3,2,4&#125;; boolean isEquals = Arrays.equals(arr1,arr2); System.out.println(isEquals); //2.String toString(int[] a):输出数组信息 System.out.println(Arrays.toString(arr1)); //3.void fill(int[] a,int val):将指定的值填充到数组中 Arrays.fill(arr1,10); System.out.println(Arrays.toString(arr1)); //4.void sort(int[] a):对数组进行排序 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //5.int binarySearch(int[] a,int key):对排序后的数组进行二分法检索指定的值 int[] arr3 = new int[] &#123;-98,-34,2,34,54,66,79,105,210,333&#125;; int index = Arrays.binarySearch(arr3, 333); if(index &gt;= 0) &#123; System.out.println(index); &#125;else &#123; System.out.println(&quot;未找到&quot;); &#125; &#125; &#125; 数组中常见的一异常 注意：编译时不会报错","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第二章 Java基本语法","slug":"Java基础/第二章 基本语法","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:19:19.938Z","comments":true,"path":"undefined/2136.html","link":"","permalink":"https://asteroidcs.github.io/undefined/2136.html","excerpt":"","text":"关键字与保留字关键字（keyword） 定义：被Java语言赋予特殊含义，用作专门用途的字符（单词）。 特点：关键字中所有字母都为小写。 官方地址：https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html 保留字（reserved word） ava保留字:现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const 标识符（Identifier）标识符 ava对各种变量、方法和类等要素命名时使用的字符序列称为标识符。 比如：类名、变量名、方法名、接口名、包名…… 技巧：凡是自己可以取名字的地方都叫标识符。 定义合法标识符规则（必须遵守） 由26个英文字母大小写，0-9，_或$组成； 数字不可开头； 不可以使用关键字和保留字，但可以包含关键字和保留字； Java中严格区分大小写，长度无限制； 标识符不能包含空格。 Java中名称命名规范（建议遵守） 包名：多单词组成时所有字母都小写：xxxyyyzzz； 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ； 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz； 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ； 注意 注意1：在取名字时，为提高阅读性，要尽量有意义（见名知意） 注意2：Java采用unicode字符集，因此标识符也可以使用汉字声明，但不建议使用 变量变量的概念 内存中的一个存储区域； 该区域的数据可在同一类型范围内不断变化； 变量是程序中最基本的存储单元。包含变量类型（强类型：必须先声明）、变量名和存储的值。 定义变量的格式：数据类型 变量名 = 变量值 例：int myAge = 18; 变量的作用 ava中每个变量必须先声明，后使用； 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了。“一对{}”即为一个作用域； 同一个作用域内，不能声明两个同名的变量。 Java定义的数据类型（按数据类型分）：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间 变量的分类 按数据类型：对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间。 (1) 数值型 整数类型 byte 占用存储空间：1字节 = 8bit位 表数范围：-128~127（27），最高位为符号位（0正1负），故为7次方 short 占用存储空间：2字节 表数范围：-215~215-1 int 占用存储空间：4字节 表数范围：-231~231-1（约21亿） long 占用存储空间：8字节 表数范围：-263~263-1 ==注意== Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性 Java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’ Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long 浮点类型 单精度float 占用存储空间：4字节 表数范围：-3.403E38~3.403E38 双精度double 占用存储空间：8字节 表数范围：-1.798E308~1.798E308 注意：与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响 浮点型常量有两种表示形式 十进制数形式：如：5.12、512.0f、.512 (必须有小数点） 科学计数法形式:如：5.12e2、512E2、100E-2 float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求 double：双精度，精度是float的两倍。通常采用此类型 Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’ float表示的数值范围比long还大，是因为它使用科学计数法来计数，但是精度不够 (2) 字符型 char 1字符 = 2字节 声明或定义char型变量，通常使用一对单引号（’’），内部只能写一个字符 转义字符（例如：换行符\\n、制表符\\t、unicode编号等） 布尔型 boolean 只能取两个值之一：true、false 常用于判断、循环结构 boolean类型数据只允许取值true和false，无null 不可以使用0或非 0 的整数替代false和true，这点和C语言不同 Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替：true用1表示，false用0表示 引用数据类型（reference type） 类（class） 接口（interface） 数组（[]） 基本数据类型之间的运算规则前提 这里只讨论7种基本数据类型变量间的运算，不包含boolean类型的。 自动类型提升 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为: 多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。 byte、char、short三种类型变量做运算时，结果为int类型，即这三个变量之间的运算结果至少要拿一个int型去接收。原因：可能是防止溢出，并且整形常量默认类型为int型，运算时如果直接加减数字的话编译不通过。 boolean类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。 字符串类型:String String不是基本数据类型，属于引用数据类型 使用方式与基本数据类型一致。例如:String str = “abcd”; 一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据 强制类型转换 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。 使用时要加上强制转换符:()，但可能造成精度降低或溢出,格外要注意 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。 boolean类型不可以转换为其它的数据类型。 进制（了解内容） 所有数字在计算机底层都以二进制形式存在 整数的四种表示方式 二进制(binary)：0,1 ，满2进1，以0b或0B开头； 十进制(decimal)：0-9 ，满10进1； 八进制(octal)：0-7 ，满8进1，以数字0开头表示； 十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0。 二进制 Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位 二进制的整数有如下三种形式： 原码：直接将一个数值换成二进制数。最高位是符号位。 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 计算机以二进制补码的形式存所有的整数。 正数的原码、反码、补码都相同 负数的补码是其反码+1 运算符 概念：运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等 算术运算符 整形数相除后默认结果为整形 需要精确结果进行运算前需要先进行类型转换（自动转换或者强制类型转换） 取模（余）运算（%） 结果符号与被模（除）数相同 自增（减） （前）++：先自增1，后运算 （后）++：先运算，后自增1 自减（略） 注意：自增（减）不会改变变量本身数据类型 赋值运算符（=） 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理 支持连续赋值 int i1, j1; i1 = j1 = 10; 比较（关系）运算符 比较运算符的运算结果都是boolean型，也就是要么是true，要么false 区分“=”和“==” 逻辑运算符 区分逻辑与（&amp;）和短路与（&amp;&amp;） 相同点：运算结果相同；党符号左边为true时，都会执行符号右边的内容 不同点：当左边为false时，&amp;&amp;不会执行符号右边的运算（短路） 开发中优先使用短路与（&amp;&amp;） 区分逻辑或（|）和短路或（||） 相同点：运算结果相同；当符号右边为false时，二者都会执行符号右边的内容 不同点：当符号左边为true时，|| 不会执行符号右边的运算（短路） 开发中优先使用短路或（||） 逻辑非（!） 逻辑异或（^） 相同为true，不同为false 位运算符（用得较少） 位运算符细节： 位运算符是直接对整数的二进制进行的运算 位运算符操作的都是整形的数据 &lt;&lt;：在一定范围内，每向左移n位，相当于*2n &gt;&gt;：在一定范围内，每向右移n位，相当于/2n 面试题：如何最高效的计算2*8？ 2 &lt;&lt; 3 或 8 &lt;&lt; 1 注意：无&lt;&lt;&lt; &amp;、|、^运算 三元运算符 格式： 条件表达式的结果为boolean类型 表达式1和表达式2为同种类型 三元运算符可嵌套使用 三元运算符与if-else的联系与区别 三元运算符可简化if-else语句，因此能用三元运算符的地方尽量用三元运算符 三元运算符要求必须返回一个结果 if后的代码块可有多个语句 凡是可以使用三元运算符的地方都可以改写成if-else，反之则不一定行 练习：获取3个数中的最大值 12int max1 = (a &gt; b)? a : b;int max2 = (max1 &gt; c)? max1 : c; 运算符的优先等级 运算符有不同优先级，所谓优先级就是表达式 运算中的运算顺序 只有单目运算符、三元运算符、赋值运算符是从右向左运算的 流程控制概念 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块 如何从键盘/控制台获取不同类型的变量：需要使用Scanner类 导包：import java.util.Scanner; Scanner的实例化：Scanner scan = new Scanner(System.in); 调用Scanner的相关方法，来获取指定类型的变量。 对于char类型的获取，Scanner没有提供相关的方法，只能获取一个字符串。 如果一定要获取char类型，可用charAt(0)获取字符串索引为0位置上的字符。 注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配，则出现异常：InputMisMatchException，导致程序中断。容量小的可自动提升； 如何获取随机数 double value = Math.random()：返回一个[0.0, 1.0)之间的double型的值。 1获取[a,b]之间的int型随机数：(int)(Math.random() * (b - a + 1) + a) 流程控制方式结构化程序设计中规定的三种基本流程结构 顺序结构 程序从上到下逐行执行，中间没有任何判断和跳转 分支结构 根据条件，选择性地执行某段代码 有if-else和switch-case两种分支语句 循环结构 根据循环条件，重复性地执行某段代码 有while、do…while、for三种循环语句 注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素 分支语句if-else结构 第一种 12345if(条件表达式)&#123;执行表达式&#125; 二选一 123456789if(条件表达式)&#123;执行表达式1&#125;else&#123;执行表达式2&#125; 多选一 12345678910111213141516171819if(条件表达式1)&#123;执行表达式1&#125;if(条件表达式2)&#123;执行表达式2&#125;……else&#123;执行表达式n&#125; 使用说明 条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。 语句块只有一条执行语句时，一对{}可以省略，但建议保留 if-else语句结构，根据需要可以嵌套使用（一般不超过3层，超过3层未解决则停下来想其他办法）。 当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。 当多个条件是“包含”关系时，“小上大下 /子上父下”。 if (80 &lt; core &lt;= 99)报错原因：前面的(80 &lt; core)的结果为一个boolean类型，boolean类型不能与int类型做大小关系对比。 针对于条件表达式： 如果多个表达式之间是”互斥“关系（或没有交集的关系），判断和执行语句的上下顺序不影响。 如果多个表达式之间有交集的关系，则需要根据实际情况来决定哪个声明在上面。 如果多个表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则范围小的就没机会执行了。 就近原则 123456789101112if (x &gt; 2) if(y &gt; 2) 执行语句1;else 执行语句2;//上述语句相当于：if (x &gt; 2) if(y &gt; 2) 执行语句1; else 执行语句2;//以上误判源于省略了单行执行语句的&#123;&#125;，所以尽量不要省略&#123;&#125; switch-case结构 说明： 根据switch表达式中的值，依次匹配各个case中的常量。一旦配成功，则进入相应的case结构中，调用其执行语句，当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。 switch结构中的表达式，只能是如下六种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。 case之后只能声明常量，尤其不能是一个范围。 break关键字是可选的。 default：相当于if-else中的else，也是可选的，且default位置是可选的，一般还是写在末尾。 如果switch-case结构中多个case的执行语句相同，则可以考虑进行合并，即写完多行执行语句相同的case以后只写1行执行语句。 凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。 写分支结构时，如果既可以使用if-else，又可以使用switch-case（switch中表达式的取值情况不太多），优先选择使用switch-case。原因：switch-case执行效率稍高。 示例：输入日期，返回日期是那一年的第几天。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;class CountDays&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print(&quot;请输入年份：&quot;); int year = input.nextInt(); System.out.print(&quot;\\n请输入月份：&quot;); int month = input.nextInt(); System.out.print(&quot;\\n请输入日期：&quot;); int day = input.nextInt(); int days = 0; switch (month)&#123; case 12: days += 30; case 11: days += 31; case 10: days += 30; case 9: days += 31; case 8: days += 31; case 7: days += 30; case 6: days += 31; case 5: days += 30; case 4: days += 31; case 3: if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)&#123; days += 29; &#125;else&#123; days += 28; &#125; case 2: days += 31; case 1: days += day; System.out.println(&quot;\\n&quot; + year +&quot;年&quot; + month + &quot;月&quot; + day + &quot;号是&quot; + year + &quot;年的第&quot; + days + &quot;天。&quot;); break; default: System.out.println(&quot;\\n输入有误！&quot;); &#125; &#125;&#125; 循环结构 在某些条件满足得情况下，反复执行特定代码的功能 循环语句的四个组成部分 初始化部分（init_statement） 循环条件部分（test_exp）–&gt; boolean类型 循环体部分（body_statement） 迭代部分（alter_statement） 通常情况下，循环结束都是因为②中循环条件返回了false 循环语句分类 for循环 结构 for(① ; ② ; ④){ ③ } 执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt; 直到②不再返回true，跳出循环 例题：遍历100以内的偶数，输出所有偶数的和，输出所有偶数的个数。 1234567891011121314class ErgodicEvenNum&#123; public static void main(String[] args)&#123; int count = 0; int sum = 0; for (int i = 0; i &lt;= 100; i++)&#123; if (i % 2 == 0)&#123; sum += i; count += 1; &#125; &#125; System.out.println(&quot;0-100内偶数有&quot; + count + &quot;个，它们的和为：&quot; + sum); &#125;&#125;//i在for循环内有效，出了for循环就失效了 例题：输入两个正整数m和n，求其最大公约数和最小公倍数。比如，12和20的最大公约数是4，最小公倍数是60。 说明break的作用：跳出循环体 123456789101112131415161718192021222324import java.util.Scanner;class GetGcdLcm&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;请输入第一个整数：&quot;); int m = scan.nextInt(); System.out.print(&quot;\\n请输入第二个整数：&quot;); int n = scan.nextInt(); int min = (m &lt;= n)? m : n; for (int i = min; i &gt; 0; i--)&#123; if (m % i == 0 &amp;&amp; n % i == 0)&#123; System.out.print(&quot;\\n&quot; + m + &quot;和&quot; + n + &quot;的最大公约数为&quot; + i + &quot;，&quot;); break; &#125; &#125; int max = (m &gt;= n)? m : n; for (int i = max; i &lt;= m * n; i++)&#123; if (i % m == 0 &amp;&amp; i % n == 0)&#123; System.out.println(&quot;最小公倍数为&quot; + i + &quot;。&quot;); break; &#125; &#125; &#125;&#125; while循环 结构 ①初始化部分 while(②循环条件部分)&#123; ③循环体部分; ④迭代部分; &#125; 执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt;② 说明 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。 for循环和while循环可以相互转换 for循环和while循环初始化条件的作用范围不同。 i 出了while循环后可以继续使用，原因：①初始化部分在循环外。 do-while 结构 ① do&#123; ③； ④； &#125;while(②)； 执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② …… -&gt;② 特点 先执行再判断，至少执行一次循环体。 开发中较少使用do-while，for和while使用较多。 循环语句综合题：从键盘输入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时，结束程序。 1234567891011121314151617181920import java.util.Scanner;class CirCom&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int posNum = 0; int negNum = 0; while(true)&#123; int alter = scan.nextInt(); if (alter &gt; 0)&#123; posNum += 1; &#125;else if (alter &lt; 0)&#123; negNum += 1; &#125;else&#123; break; &#125; &#125; System.out.println(&quot;输入的正数个数为：&quot; + posNum); System.out.println(&quot;输入的负数个数为：&quot; + negNum); &#125;&#125; 说明： while(true)就相当于for(;;) 结束循环的几种方式 循环条件部分返回false； 在循环体中执行break。 嵌套循环 嵌套循环的使用 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环。 外层循环：循环结构B。 内层循环：循环结构A。 说明 内层循环结构遍历一遍，只相当于外层循环结构循环一次。 假设外层循环需要执行m次，内层循环需要执行n次，此时内存层循环的循环体需要执行m*n次。 技巧：外层循环控制行数，内层循环控制列数。 例题1：九九乘法表 1234567891011121314import java.util.Scanner;class MultiTable&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印几行？（1-9）&quot;); int line = scan.nextInt(); for (int i = 1; i &lt;= line; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; System.out.print(i + &quot;x&quot; + j + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 例题2：100以内所有质数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;class PriNum&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印多少以内的质数？&quot;); int limtNum = scan.nextInt(); System.out.println(&quot;*********结果*********&quot;); boolean isPriNum = true; for (int i = 2; i &lt;= limtNum; i++)&#123; for (int j = 2; j &lt; i; j++) &#123; if (i % j ==0)&#123; isPriNum = false; &#125; &#125; if (isPriNum)&#123; System.out.println(i); &#125; isPriNum = true; &#125; &#125;&#125;//优化import java.util.Scanner;class PriNum&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印多少以内的质数？&quot;); int limtNum = scan.nextInt(); System.out.println(&quot;*********结果*********&quot;); long start = System.currentTimeMillis();//获取当前时间距1970-01-01 00:00:00的毫秒数（long型） boolean isPriNum = true; int count = 0; for (int i = 2; i &lt;= limtNum; i++)&#123; //for (int j = 2; j &lt; i; j++)&#123; for (int j = 2; j &lt;= Math.sqrt(i); j++)&#123;//优化二：一个数如果在2到它本身开方的范围内没有商，则为质数 if (i % j ==0)&#123; isPriNum = false; break;//优化一：只对本身非质数的自然数是有效的。加break前后对比：20181ms/2174ms = 9.28 &#125; &#125; if (isPriNum)&#123; count += 1; &#125; isPriNum = true; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;质数的个数：&quot; + count); System.out.println(&quot;所花费的时间：&quot; + (start - end)); //优化前：17916ms 优化一：1629ms 优化二：16ms &#125;&#125; 特殊关键字的使用 break 使用范围：switch-case、循环结构中 循环中使用的作用：结束当前循环 默认跳出包裹此关键字最近的一层循环 结束指定标识的一层循环结构 1234567label:for (int i = 1; i &lt;= 4; i++)&#123; for (int j = 1; j &lt;= 10; j++)&#123; if (j % 4 == 0)&#123; break label; &#125; &#125;&#125; continue 使用范围：循环结构中 循环中使用的作用：结束当次循环 结束指定标识的一层循环结构的当次循环 countinue label; 注意：以上两个关键字后面不能声明执行语句 return 并非专门用于结束循环的，它的的功能是结束一个方法。当一个方法执行到一个return时，这个方法将被结束。 与break、continue不同的是吗，return直接结束整个方法，不管这个return处于多少层循环之内。 补充：衡量一个功能代码的优劣 正确性 可读性 健壮性 高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第四章 面向对象（中）","slug":"Java基础/第五章 面向对象（中）","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-11T02:55:42.222Z","comments":true,"path":"undefined/df1b.html","link":"","permalink":"https://asteroidcs.github.io/undefined/df1b.html","excerpt":"","text":"OOP特征二：继承性继承性的好处 减少代码冗余，提高了代码的复用性； 便于功能的扩展； 为之后多态性的使用，提供了前提。 继承性的格式：class A extends B{} A：子类、派生类、subclass B：父类、超类、基类、superclass 体现：一旦子类A继承父类B后，子类A就获取了父类B中所有的属性和方法。 特别地：父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展，扩展。 Java中关于继承性的规定 一个类可以被多个子类继承； Java中类的单继承性：一个类只能有一个父类； 子类是相对概念； 子类直接继承的父类称为直接父类，间接继承的父类称为间接父类； 子类继承父类以后就获取了直接父类以及所有间接父类声明的属性和方法。 java.lang.Object类的理解 如果没有显式地声明一个类的父类的话，则此类继承于java.lang.Object类； 所有的Java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类； 意味着，所有的Java类具java.lang.Object类声明的功能。 Debug（调试）如何调试程序 System.out.println()； Eclipse - Debug 设置断点（可设置多个断点） debug as java application 常用操作 操作 作用 step into 跳入（F5） 进入当前所调用的方法中 step over 跳过（F6） 执行完当前语句进入下一行 step return 跳回（F7） 执行完当前所在方法，进入下一行 drop to frame 回到当前行所在方法的第一行 resume 恢复 执行完当前所在断点的所有代码，进入下一个断点，如果没有就结束 Terminate 终止 停止JVM，后面的程序不会再执行 方法的重写（override/overwrite）概念及使用 重写：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在执行程序时，子类的方法将覆盖父类的方法。 重写以后，当创建子类对象以后，通过子类对象调用父类中的同名参数的方法时，实际执行的是子类重写父类的方法。 方法的声明： 123权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型&#123; //方法体&#125; 重写规定： 约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法 重写与被重写方法名以及形参列表相同 重写重写方法的权限修饰符必须不小于被重写方法的权限修饰符 特殊情况：子类不能重写父类中权限为private的方法 返回值类型： 父类被重写方法的返回值类型是void，则子类重写方法的返回值类型只能是void； 父类被重写方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类； 父类被重写方法的返回值类型是基本数据类型（比如double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）； 子类重新写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。（具体放到异常处理再讲） ==子类和父类中同名同参数的要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写）== 实例：12345678910111213141516171819202122232425262728package top.triabin.override;/** * * @Description 方法重写练习--父类 * @author DawnLee * @version 1.0 * @data 2020-8-14 15:19:55 * */public class Person &#123; String name; int age; public Person() &#123; //空参构造器 &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; public void walk(int distance) &#123; System.out.println(&quot;走路，走的距离是&quot; + distance + &quot;公里。&quot;); &#125;&#125; 123456789101112131415161718192021222324252627package top.triabin.override;/** * * @Description 方法重写练习--子类 * @author DawnLee * @version 1.0 * @data 2020-8-14 15:24:49 * */public class Student extends Person &#123; String major; public Student() &#123; &#125; public Student(String major) &#123; this.major = major; &#125; public void study() &#123; System.out.println(&quot;学习。专业是：&quot; + major); &#125; //对父类中的eat()方法重写 public void eat() &#123; System.out.println(&quot;学生应该多吃有营养的事食物&quot;); &#125;&#125; 1234567891011121314151617181920package top.triabin.override;/** * * @Description 方法重写练习--测试类 * @author DawnLee * @version 1.0 * @data 2020-8-14 15:28:22 * */public class PersonTest &#123; public static void main(String[] args) &#123; Student s = new Student(&quot;计算机科学与技术&quot;); s.eat(); s.walk(10); s.study(); Person p1 = new Person(); p1.eat(); &#125;&#125; 面试题：​ 区分方法的重载与重写 (高频题) ? 二者概念： 重载和重写的具体规则： 重载不表现为多态性，重写表现为多态性。 四种访问权限修饰符 Java权限修饰符public、protected、 (缺省)、 private置于==类的成员==定义前，用来限定对象对该类成员的访问权限 对于class的权限修饰只可以用public和default(缺省) public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 访问控制举例 创建一个Order类： 123456789101112131415161718192021222324252627282930313233343536373839404142package top.triabin.fourpermissionmodifiers;/** * * @Description 体会4种不同的权限修饰 * @author DawnLee * @version 1.0 * @data 2020-8-14 18:23:20 * */public class Order &#123; @SuppressWarnings(&quot;unused&quot;) private int orderPrivate; int orderDefault; protected int orderProtected; public int orderPublic; @SuppressWarnings(&quot;unused&quot;) private void methodPrivate() &#123; orderPrivate = 1; orderDefault = 1; orderProtected = 1; orderPublic = 1; &#125; void methodDefault() &#123; orderPrivate = 2; orderDefault = 2; orderProtected = 2; orderPublic = 2; &#125; protected void methodProtected() &#123; orderPrivate = 3; orderDefault = 3; orderProtected = 3; orderPublic = 3; &#125; public void methodPublic() &#123; orderPrivate = 4; orderDefault = 4; orderProtected = 4; orderPublic = 4; &#125;&#125; 同一个包中的其他类，不可以调用Order类中私有的属性、方法 1234567891011121314151617181920212223242526package top.triabin.fourpermissionmodifiers;/** * * @Description 4种不同的权限修饰测试类 * @author DawnLee * @version 1.0 * @data 2020-8-14 18:30:38 * */public class OrderTest &#123; public static void main(String[] args) &#123; Order order = new Order(); order.orderDefault = 2; order.orderProtected = 3; order.orderPublic = 4; order.methodDefault(); order.methodProtected(); order.methodPublic(); // 同一个包中的其他类，不可以调用Order类中私有的属性、方法// order.orderPrivate = 1;// order.methodPrivate(); &#125;&#125; 在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法 1234567891011121314151617181920package top.triabin.fourpermissionmodifiers.suborder;import top.triabin.fourpermissionmodifiers.Order;public class SubOrder extends Order &#123; public void method() &#123; orderProtected = 1; orderPublic = 2; methodProtected(); methodPublic(); // 在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法。// orderDefault = 3;// orderPrivate = 4;// // methodDefault();// methodPrivate(); &#125;&#125; 不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法 1234567891011121314151617181920package top.triabin.fourpermissionmodifiers.suborder;import top.triabin.fourpermissionmodifiers.Order;public class OrderTest &#123; public static void main(String[] args) &#123; Order order = new Order(); order.orderPublic = 1; order.methodPublic(); // 不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法。// order.orderPrivate = 2;// order.orderDefault = 3;// order.orderProtected = 4;// // order.methodPrivate();// order.methodDefault();// order.methodProtected(); &#125;&#125; 关键字：supersuper关键字的使用 super理解为：父类 super可以用来调用：属性、方法、构造器； super的使用：调用属性和方法 我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”； 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须是显示的使用“super.属性”的方式，表明调用的是父类中声明的属性； 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须是显示的使用“super.方法”的方式，表明调用的是父类中被重写的方法。 uper的使用：调用构造器 我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的构造器； “super(形参列表)”的使用，必须声明在子类构造器的首行； 我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现 在子类构造器的首行，没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用父类中空参的构造器：super()； 在类的多个构造器中，至少有一个类的构造器中是用来了“super(形参列表)”，调用父类中的构造器。 super关键字举例 父类Person 1234567891011121314151617181920212223public class Person &#123; String name; int age; int id = 1001;//身份证号 public Person() &#123; System.out.println(&quot;在构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用父类中空参的构造器：super()。&quot;); &#125; public Person(String name) &#123; this.name = name; &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void eat() &#123; System.out.println(&quot;人：吃饭&quot;); &#125; public void walk() &#123; System.out.println(&quot;人：走路&quot;); &#125;&#125; 子类Student 1234567891011121314151617181920212223242526272829303132public class Student extends Person &#123; String major; int id = 1002;//学号 public Student() &#123; &#125; public Student(String major) &#123; this.major = major; &#125; public Student(String name,int age,String major) &#123;// this.name = name;// this.age = age; super(name,age);//调用父类中形参列表相同的构造器 this.major = major; &#125; @Override public void eat() &#123; System.out.println(&quot;学生：多吃有营养的食物&quot;); &#125; public void study() &#123; System.out.println(&quot;学生：学习知识&quot;); this.eat(); super.eat(); &#125; public void show() &#123; System.out.println(&quot;name = &quot; + this.name + &quot;,age = &quot; + super.age); System.out.println(&quot;id = &quot; + this.id); System.out.println(&quot;id = &quot; + super.id); &#125;&#125; 测试类SuperTest 123456789101112131415161718public class SuperTest &#123; public static void main(String[] args) &#123; Student s = new Student(); s.show(); System.out.println(); s.study(); Student s1 = new Student(&quot;Triabin&quot;,18,&quot;IT&quot;); s1.show(); System.out.println(&quot;****************************&quot;); @SuppressWarnings(&quot;unused&quot;) Student s2 = new Student(); &#125;&#125; 结果 this和super的区别 子类对象实例化过程 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性和方法； 创建的子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 但我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象才可以调用。 明确：虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象。 OOP特征三：多态性基本概念和规则 理解多态性：可以理解为事物的多种形态。 何为多态： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用） 多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译器期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。 多态性使用前提： 要有类的继承关系； 要有方法的重写。 对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边） 应用举例举例一：基本概念的使用 Person类 12345678910111213public class Person &#123; String name; int age; int id = 1001; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; public void walk() &#123; System.out.println(&quot;走路&quot;); &#125;&#125; Man类 123456789101112131415public class Man extends Person &#123; boolean isSmoking; int id = 1002; public void earnMoney() &#123; System.out.println(&quot;男人负责赚钱养家&quot;); &#125; public void eat() &#123; System.out.println(&quot;多吃肉，长肌肉&quot;); &#125; public void walk() &#123; System.out.println(&quot;霸气地走路&quot;); &#125;&#125; Woman类 123456789101112131415package top.triabin.polymorphism;public class Woman extends Person &#123; boolean isBeauty; public void goShopping() &#123; System.out.println(&quot;购物&quot;); &#125; public void eat() &#123; System.out.println(&quot;减肥&quot;); &#125; public void walk() &#123; System.out.println(&quot;优雅&quot;); &#125;&#125; PersonTest类 123456789101112131415161718192021222324252627282930313233343536373839package top.triabin.polymorphism;/* * 面向对象特征之三：多态性 * * 1.理解多态性：可以理解为事物的多种形态 * 2.何为多态： * 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用） * 3.多态的使用：虚拟方法调用 * 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 * 总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。 * 4.多态性使用前提：①要有类的继承关系；②要有方法的重写。 * * 5.对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边） * */public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.age = 18; man.earnMoney(); System.out.println(&quot;\\n*****************************&quot;); //对象的多态性：父类的引用指向子类的对象 Person p2 = new Man();// Person p3 = new Woman();// 多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用 p2.eat(); p2.walk(); // p2.earnMoney(); System.out.println(); System.out.println(p2.id);//1001 对象的多态性，只适用于方法，不适用于属性。 &#125;&#125; 运行结果 应用举例二：虚拟方法调用 AnimalTest类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.triabin.polymorphism;//多态性的使用举例一：public class AnimalTest &#123; public static void main(String[] args) &#123; AnimalTest test = new AnimalTest(); test.func(new Dog()); test.func(new Cat()); &#125; public void func(Animal animal) &#123;//Animal animal = new Dog(); animal.eat(); animal.shout(); &#125;&#125;class Animal&#123; public void eat() &#123; System.out.println(&quot;动物：进食&quot;); &#125; public void shout() &#123; System.out.println(&quot;动物：叫&quot;); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; public void shout() &#123; System.out.println(&quot;汪！汪！汪！&quot;); &#125;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public void shout() &#123; System.out.println(&quot;喵！喵！喵！&quot;); &#125;&#125; 从编译和运行的角度看重载与重写 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。==它们的调用地址在编译期就绑定了==。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”。 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 instanceof操作符​ 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特有的属性和方法？ 向下转型：使用强制类型转换符 例 Man m1 = (Man)p2; 使用强转时，可能出现ClassCastException异常。引入instanceof关键字： instanceof关键字的使用： a instanceof A:判断对象a是否是类A的实例。如果是，返回true，如果不是返回false。 使用场景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型前，先进行instanceof判断，一旦返回true，就进行向下转型；如果返回false，不进行向下转型。 如果a instanceof A返回true，则a instanceof B也返回true，那么B是A的父类。 应用举例：将上面应用举例一中的PersonTest类修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package top.triabin.polymorphism;/* * 面向对象特征之三：多态性 * * 1.理解多态性：可以理解为事物的多种形态 * 2.何为多态： * 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用） * 3.多态的使用：虚拟方法调用 * 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 * 总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。 * 4.多态性使用前提：①要有类的继承关系；②要有方法的重写。 * * 5.对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边） * */public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.age = 18; man.earnMoney(); System.out.println(&quot;\\n*****************************&quot;); //对象的多态性：父类的引用指向子类的对象 Person p2 = new Man();// Person p3 = new Woman();// 多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用 p2.eat(); p2.walk(); // p2.earnMoney();//无法调用子类所特有的方法，编译时认为p2是一个Person类，Person中无earnMoney方法。// p2.isSmoking = true; System.out.println(); System.out.println(p2.id);//1001--对象的多态性，只适用于方法，不适用于属性。 System.out.println(); System.out.println(&quot;***************instanceof关键字的使用*****************&quot;);// 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类// 类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 // 如何才能调用子类特有的属性和方法？ Man m1 = (Man)p2;//向下转型：使用强制类型转换符。 m1.earnMoney(); m1.isSmoking = true; // 使用强转时，可能出现ClassCastException异常。// Woman w1 = (Woman)p1;// w1.goShopping(); /* instanceof关键字的使用： * * a instanceof A:判断对象a是否是类A的实例。如果是，返回true，如果不是返回false。 * * 使用情景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型前，先进 * 行instanceof判断，一旦返回true，就进行向下转型；如果返回false，不进行向下转型。 * * 如果a instanceof A返回true，则a instanceof B也返回true，那么B是A的父类。 */ if(p2 instanceof Woman) &#123; Woman w1 = (Woman)p2; w1.goShopping(); System.out.println(&quot;强转成功&quot;); &#125;else &#123; System.out.println(&quot;p2不是类Woman的实例，强转失败！&quot;); &#125; if(p2 instanceof Man) &#123; System.out.println(&quot;p2是类Man的实例，可以强转！&quot;); &#125;else &#123; System.out.println(&quot;p2不是类Man的实例，强转失败！&quot;); &#125; System.out.println(); if(p2 instanceof Person) &#123; System.out.println(&quot;p2是类Person的实例！&quot;); &#125; if(p2 instanceof Object) &#123; System.out.println(&quot;p2也是类Object的实例！&quot;); &#125; System.out.println();// 练习： //问题一：编译时通过，运行时不通过// Person p3 = new Woman();// Man m3 = (Man)p3; //举例一：// Person p3 = new Woman();// Man m3 = (Man)p3; //举例二：// Person p4 = new Person();// Man m4 = (Man)p4; //问题二：编译通过，运行也通过// Object obj = new Woman();// Person p = (Person)obj; //问题三：编译不通过// Man m5 = new Woman(); &#125;&#125; Object类的使用java.lang.Object类 Object类是所有Java类的根父类。 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类。 Object类中的功能（属性、方法）具有通用性。 属性：无 方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait()、notify()、notifyAll() Object类只声明了一个空参的构造器。 Object类中的主要结构 equals()方法​ 面试题：==和equals()的区别？ 回顾==的使用： ==：运算符 可以使用在基本数据类型变量和引用数据类型变量中； 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一 个对象实体。 equals()方法的使用： 是一个方法，而非运算符； 只能适用于引用数据类型； Object类中equals()的定义： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; ​ 说明：Object类中equals()和==的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。 像String、Date、File、包装类等都重写了Object类中的equals()方法，重写之后，比较的不再是两个对象的“实体内容”是否相同； 通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的“实体内容”是否相同。那么我们就需要对Object类中的equals()方法进行重写。 重写原则：比较两个对象的实体内容（即：name和age）是否相同。 代码实例 Customer类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package top.triabin.classobject;public class Customer &#123; private String name; private int age; public Customer(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Customer() &#123; super(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// 重写原则：比较两个对象的实体内容（即：name和age）是否相同// 手动实现equals()的重写：// @Override// public boolean equals(Object obj) &#123;// if(this == obj) &#123;// return true;// &#125;// if(obj instanceof Customer) &#123;// Customer cust = (Customer)obj;// //比较两个对象的每个属性是否都相同// return this.age == cust.age &amp;&amp; this.name.equals(cust.name);// &#125;// return false;// &#125;// 自动生成equals()的重写：=&gt; Alt+Shift+S / Source =&gt; Generate hashCode() and equals() @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125;&#125; EqualsTest类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package top.triabin.classobject;import java.sql.Date;/* * 面试题：==和equals()的区别？ * * 一、回顾 == 的使用： * ==：运算符 * 1. 可以使用在基本数据类型变量和引用数据类型变量中； * 2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） * 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一 * 个对象实体。 * * 二、equals()方法的使用： * 1. 是一个方法，而非运算符； * 2. 只能适用于引用数据类型； * 3. Object类中equals()的定义： * public boolean equals(Object obj) &#123; return (this == obj); &#125; * 说明：Object类中equals()和==的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体 * * 4. 像String、Date、File、包装类等都重写了Object类中的equals()方法，重写之后，比较的不再是两个对象的“实体内容” * 是否相同。 * 5. 通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的“实体内容”是否相同。那么我们就 * 需要对Object类中的equals()方法进行重写。 * 重写原则：比较两个对象的实体内容（即：name和age）是否相同。 */public class EqualsTest &#123; public static void main(String[] args) &#123;// 基本数据类型 int i = 10; int j = 10; double d = 10.0; System.out.println(i == j);//true System.out.println(i == d);//true // boolean b = true;// System.out.println(i == b);//报错 char c = 10; System.out.println(i == c);//true char c1 = &#x27;A&#x27;; char c2 = 65; System.out.println(c1 == c2);//true // 引用数据类型 Customer cust1 = new Customer(&quot;Tom&quot;,21); Customer cust2 = new Customer(&quot;Tom&quot;,21); System.out.println(cust1 == cust2);//false String str1 = new String(&quot;Triabin&quot;); String str2 = new String(&quot;Triabin&quot;); System.out.println(str1 == str2);//false System.out.println(&quot;**********equals()方法的使用**********&quot;); System.out.println(cust1.equals(cust2));//false =&gt; Object类中的equals()方法，比较的是地址，修改相应的equals()方法后变为true，详情见Customer类 System.out.println(str1.equals(str2));//true =&gt; String类中的equals()方法，比较的是“实体内容”，而非地址 Date date1 = new Date(32432525324L); Date date2 = new Date(32432525324L); System.out.println(date1.equals(date2));//true =&gt; Date类中的equals()方法，比较的是“实体内容”，而非地址 &#125;&#125; 运行结果 重写equals()方法的原则： 对称性：如果x.equals(y)返回的是“true”，那么y.equals(x)也应该返回是“true”。 自反性：x.equals(x)必须返回是“true”。 传递性：如果x.equals(y)返回是“true”，而且x.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 一致性：如果x.equals(y)返回是”true“，只要x和y内容一直不变，不管重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”； x.equals(和x不同类型的对象)永远返回是“false”。 toString方法 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()； Object类中toString()的定义： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()方法时，返回“实体内容”信息； 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。 代码实例： 在equals()代码实例的包下创建类ToStringTest类 12345678910111213141516171819202122232425262728293031package top.triabin.classobject;import java.sql.Date;/* * Object类中toString()的使用 * * 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()； * * 2. Object类中toString()的定义： * public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; * * 3. 像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()方法 * 时，返回“实体内容”信息； * 4. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。 */public class ToStringTest &#123; public static void main(String[] args) &#123; Customer cust1 = new Customer(&quot;Triabin&quot;,22); System.out.println(cust1.toString());//top.triabin.classobject.Customer@15db9742 重写toString()方法后：Customer[name = Triabin,age = 22] System.out.println(cust1);//top.triabin.classobject.Customer@15db9742 重写toString()方法后：Customer[name = Triabin,age = 22] String str = new String(&quot;MM&quot;); System.out.println(str);//MM Date date = new Date(4534534534543L); System.out.println(date.toString());//2113-09-11 &#125;&#125; 在Customer类中重写toString()方法： 1234567891011// 手动实现toString()方法的重写：// @Override// public String toString() &#123;// return &quot;Customer[name = &quot; + name + &quot;,age = &quot; + age + &quot;]&quot;;// &#125; // 自动实现： @Override public String toString() &#123; return &quot;Customer [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; 运行结果 包装类(Wrapper)的使用知识点 针对八种基本数据类型定义相应的引用类型—包装类（封装类） 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 基本数据类型包装成包装类的实例 —— ==装箱== 通过包装类的构造器实现： 1int i = 500; Integer t = new Integer(i); 通过字符串参数构造包装类对象： 123Float f = new Float(“4.56”);Long l = new Long(“asdf”); //NumberFormatException 获得包装类对象中包装的基本类型变量 —— ==拆箱== 调用包装类的.xxxValue()方法： 1boolean b = bObj.booleanValue(); JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。 字符串转换成基本数据类型 通过包装类的构造器实现： 1int i = new Integer(“12”); 通过包装类的parseXxx(String s)静态方法： 1Float f = Float.parseFloat(“12.1”); 基本数据类型转换成字符串 调用字符串重载的valueOf()方法： 1String fstr = String.valueOf(2.34f); 更直接的方式： 1String intStr = 5 + “” 基本类型、包装类与String类间的转换 包装类用法举例12345678int i = 500;Integer t = new Integer(i);装箱：包装类使得一个基本数据类型的数据变成了类。有了类的特点，可以调用类中的方法。String s = t.toString(); // s = “500“,t是类，有toString方法String s1 = Integer.toString(314); // s1= “314“ 将数字转换成字符串。String s2=“4.56”;double ds=Double.parseDouble(s2); //将字符串转换成数字 拆箱：将数字包装类中内容变为基本数据类型。 1int j = t.intValue(); // j = 500，intValue取出包装类中的数据 包装类在实际开发中用的最多的在于字符串变为基本数据类型。 1234String str1 = &quot;30&quot; ;String str2 = &quot;30.3&quot; ;int x = Integer.parseInt(str1) ; // 将字符串变为int型float f = Float.parseFloat(str2) ; // 将字符串变为int型 单元测试（JUnit） 选中当前工程 -&gt; 右键 -&gt; build path -&gt; add libraries -&gt; JUnit 4 -&gt; 下一步 创建一个Java类进行单元测试 此时的Java类要求：① 此类是public的； ② 此类提供公共的无参的构造器 此类中声明单元测试方法 此时的单元测试方法：方法的权限是public，没有返回值，没有形参 此单元测试方法上需要声明注释：@Test，并在单元测试类中导入：import org.junit.Test； 声明好单元测试方法以后，就可以在方法体内测试相关代码； 写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test 说明： 如果执行结果没有异常：绿条 如果执行结果出现异常：红条 代码示例12345678910111213141516171819202122232425262728public class JUnitTest &#123; int num = 10; @Test public void testEquals() &#123; String s1 = &quot;MM&quot;; String s2 = &quot;MM&quot;; System.out.println(s1.equals(s2)); //ClassCastException的异常// Object obj = new String(&quot;GG&quot;);// Date date = (Date)obj; System.out.println(num); show(); &#125; public void show() &#123; num = 20; System.out.println(&quot;show()...&quot;); &#125; @Test public void testToString() &#123; String s2 = &quot;MM&quot;; System.out.println(s2.toString()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第四章 面向对象（上）","slug":"Java基础/第四章 面向对象（上）","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:18:28.428Z","comments":true,"path":"undefined/df1b.html","link":"","permalink":"https://asteroidcs.github.io/undefined/df1b.html","excerpt":"","text":"Java面对对象学习的三条主线 Java类及类的成员：属性、方法、构造器；代码块、内部类； 面向对象的三大特征：封装性、继承性、多态性（、抽样性）； 其他关键字：this、super、final、abstract、interface、package、import等。 面向过程与面向对象面向过程与面向对象区别 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。 面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 面对对象的三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 面对对象的思想概述 程序员从面向过程的执行者转化成了面向对象的指挥者。 面对对象分析问题的思路和步骤： 根据问题需要，选择问题所针对的现实世界中的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。 Java基本元素：类和对象面对对象的思想概述 类（Class）和对象（Object）是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例（instance） 万物皆对象 面对对象程序设计的重点是类的设计 类的设计，其实就是类的成员的设计 Java类及类的成员 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多不同功能的类构成的。 现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质……那么，Java中用类来描述事物也是如此。常见类的成员有： 属性：对应类中的成员变量 行为：对应类中的成员方法 对象的创建和使用面对对象思想的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package io.github.dawn333.oop;/** * * @Description 一、类和对象的使用（面对对象思想落地的实现）： * 1、创建类，设计类的成员 * 2、创建类的对象 * 3、通过“对象.属性”或“对象.方法”调用对象的结构 * * 二、如果创建了多个对象，则每个对象都独立的拥有一套属性。（非static） * 意味着，如果改一个对象的属性a，不影响另一个对象属性a的值。 * @author DawnLee * @version 1.0 * @data 2020-7-30 16:32:18 * */public class PersonTest &#123; public static void main(String[] args) &#123; //创建Person类的对象、 Person p1 = new Person(); //调用对象的结构：属性、方法 //调用属性：对象.属性 p1.name = &quot;Tom&quot;; p1.isMale = true; System.out.println(p1.name); //调用方法：对象.方法 p1.eat(); p1.sleep(); p1.talk(&quot;Chinese&quot;); //************************ Person p2 = new Person(); System.out.println(p2.name);//null //************************ Person p3 = p1; //将p1变量保存的地址赋给p3，导致p1和p3指向了堆空间中的同一个对象实体。 System.out.println(p3.name);//Tom p3.age = 10; System.out.println(p1.age);//10 &#125;&#125;class Person&#123; //属性 String name; int age; boolean isMale; //方法 public void eat() &#123; System.out.println(&quot;人可以吃饭&quot;); &#125; public void sleep() &#123; System.out.println(&quot;人可以睡觉&quot;); &#125; public void talk(String language) &#123; System.out.println(&quot;人可以说话，使用的语言是：&quot; + language); &#125;&#125; 内存解析 堆（heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 通常所说的栈（stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（bolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。 方法区（method area），用于存储已被虚拟机加载类信息、常量、静态变量、即时编译器编译后的代码等数据。 对象内存解析 内存解析的说明 引用类型的变量，只可能存储两类值：null或地址值（含变量的类型） 对象数组的内存解析 JVM内存结构 关注书籍：《JVM规范》 虚拟机栈即为平时提到的栈结构，我们将局部变量存储在栈结构中。 堆，我们将new出来的结构（比如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中。 理解“万事万物皆对象” 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。 Scanner，String等 文件：File 网络资源：URL 涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 匿名对象的使用 理解：我们创建的对象没有显示的赋给一个变量名， 即为匿名对象。 特征：匿名对象只能代用一次。 使用：如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package io.github.triabin.oop;/** * * @Description 匿名对象的使用 * @author DawnLee * @version 1.0 * @data 2020-8-6 16:04:02 * */public class InstanceTest &#123; public static void main(String[] args) &#123; Phone p = new Phone(); System.out.println(&quot;正常调用：&quot;); p.sendEmail(); p.playGame(); //匿名 System.out.println(&quot;\\n匿名对象：&quot;); new Phone().sendEmail(); new Phone().playGame(); System.out.println(&quot;\\n匿名对象只能代用一次：&quot;); new Phone().price = 1999; new Phone().showPrice(); System.out.println(&quot;\\n匿名对象的使用：&quot;); PhoneMall mall = new PhoneMall();// mall.show(p); mall.show(new Phone()); &#125;&#125;class PhoneMall&#123; public void show(Phone phone) &#123; phone.sendEmail(); phone.playGame(); &#125;&#125;class Phone&#123; double price;//价格 public void sendEmail() &#123; System.out.println(&quot;发送邮件&quot;); &#125; public void playGame() &#123; System.out.println(&quot;玩游戏&quot;); &#125; public void showPrice() &#123; System.out.println(&quot;手机的价格为：&quot; + price); &#125;&#125; 类的成员之一：属性类中属性的使用 语法格式: 说明： 说明1: 修饰符 常用的权限修饰符有:private、缺省、protected、public 其他修饰符:static、final (暂不考虑) 说明2:数据类型 任何基本数据类型(如int、Boolean) 或 任何引用数据类型。 说明3:属性名 属于标识符，符合命名规则和规范即可。 举例 123public class Person&#123;private int age; //声明private变量 agepublic String name = “Lila”; //声明public变量 name &#125; 变量的分类:成员变量与局部变量 成员变量：在方法体外，类体内声明的变量。 局部变量：在方法体内部声明的变量称。 注意:二者在初始化值方面的异同**:** 同:都有生命周期 异:局部变量除形参外，均需显式初始化。 区别： 代码示例： 12345678910111213141516171819202122232425262728293031323334package io.github.triabin.oop;/** * * @Description 类中属性的使用 * @author DawnLee * @version 1.0 * @data 2020-8-5 14:49:47 * */public class UserTest &#123; public static void main(String[] args) &#123; User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); u1.talk(&quot;日语&quot;);//特别的 &#125;&#125;class User&#123; //属性（或成员变量） String name; int age; boolean isMale; public void talk(String language) &#123;//形参，也是局部变量 System.out.println(&quot;我们使用&quot; + language +&quot;进行交流。&quot;); &#125; public void eat() &#123; String food = &quot;烙饼&quot;;//局部变量 System.out.println(&quot;北方人喜欢吃&quot; + food); &#125;&#125; 类的成员之二: 方法(method) 方法：描述类具有的功能。比如：Math类：sqrt()\\random()\\…… Scanner类：nextXxx()…… Arrarys类：sort()\\binarySearch()\\toString()\\equals()\\…… 类中方法的声明和使用 举例 public void eat(){}（void：没有返回值） public void sleep(int hour){} public String getNmae() {}（String：返回一个String类型的数据） public String getNation(String nation){} 方法的声明： 注意：static、final、abstract来修饰的方法 说明： 关于权限修饰符：目前默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private、public、缺省、protected —&gt; 封装性再细说 返回值类型：有返回值 or 无返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中必须使用return关键字来返回指定类型的变量或常量。例如下列代码实例方法中的getName()方法。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不使用return。但是，如果使用的话，只能“return;”，表示结束此方法。 方法名：属于标识符，遵循表示符的规则和命名规范，“见名知意”。 形参列表：方法可以声明0个，1个或多个形参。 格式：数据类型1 形参1,数据类型2 形参2,… 方法体：方法功能的体现。 return关键字的使用： 使用范围：使用在方法体中。 作用：①结束方法；②针对于有返回值的方法，使用“return 数据;”方法返回所要的数据。 ==注意：return关键字后面不可以声明执行语句== 方法的使用中可以调用当前类的属性或方法 特别地：方法A中调用方法A：递归方法。 方法中不能再定义方法。 代码实例1234567891011121314151617181920212223242526272829303132333435package io.github.triabin.oop;public class CustomarTest &#123;&#125;//客户类class Customar&#123; //属性: String name; int age; boolean isMale; //方法： public void eat()&#123; System.out.println(&quot;客户吃饭&quot;); &#125; public void sleep(int hour) &#123; System.out.println(&quot;休息了&quot; + hour + &quot;小时&quot;); &#125; public String getNmae() &#123; if(age &gt; 18) &#123; return name; &#125;else &#123;//没有else则报错，必须要有一个返回值。 return &quot;Tom&quot;; &#125; &#125; public String getNation(String nation) &#123; String info = &quot;我的国籍是：&quot; + nation; return info; &#125;&#125; 方法的分类（按照是否有形参及返回值） 再谈方法方法的重载 定义： 在同一个类中，允许存在一个以上的同名方法，只要它们的==参数个数== ==或者== ==参数类型==不同即可。 “两同一不同”：同一个类、相同的方法名；参数列表不同：参数个数不同、参数类型不同 特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。 示例 Arrays类中重载的sort() / binarySearch() 12345678910111213141516171819202122232425262728293031public class OverLoadTest &#123; public static void main(String[] args) &#123; OverLoadTest test = new OverLoadTest(); test.getSum(1,2); &#125; //如下4个方法构成了重载 public void getSum(int i,int j) &#123; System.out.println(&quot;1&quot;); &#125; public void getSum(double d1, double d2) &#123; System.out.println(&quot;2&quot;); &#125; public void getSum(String s, int i) &#123; System.out.println(&quot;3&quot;); &#125; public void getSum(int i,String s) &#123; System.out.println(&quot;4&quot;); &#125; // public int getSum(int i,int j) &#123;// return 0;// &#125; // public void getSum(int m,int n) &#123;// // &#125;&#125; 注意：支持自动类型提升，例如，如果形参为double型，但是输入的形参为int型，则自动将int型转换为double型。 判断是否是重载 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系，==只看形参数目和类型== 通过对象调用方法时，如何确定某一个指定的方法： 方法名 —&gt; 参数列表 练习题 编写程序，定义三个重载方法并调用。方法名为mOL。 三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果、相乘并输出结果、输出字符串信息。 在主类的main方法中分别用参数区别调用三个方法。 1234567891011121314151617181920public class OverLoadEx1 &#123; public static void main(String[] args) &#123; OverLoadEx1 m = new OverLoadEx1(); m.mOL(2); m.mOL(2, 5); m.mOL(&quot;字符串&quot;); &#125; public void mOL(int i) &#123; System.out.println(i * i); &#125; public void mOL(int i,int j) &#123; System.out.println(i * j); &#125; public void mOL(String s) &#123; System.out.println(s); &#125;&#125; 定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，分别调用三个方法。 123456789101112131415161718public class OverLoadEx2 &#123; public static void main(String[] args) &#123; OverLoadEx2 test = new OverLoadEx2(); test.max(1, 3); test.max(1.5, 3.5); test.max(1.5, 3.5, 7.5); &#125; public void max(int i,int j) &#123; System.out.println(&quot;第一个方法求得最大值为：&quot; + ((i &gt; j)? i : j)); &#125; public void max(double i,double j) &#123; System.out.println(&quot;第二个方法求得最大值为：&quot; + ((i &gt; j)? i : j)); &#125; public void max(double i,double j,double k) &#123; System.out.println(&quot;第三个方法求得最大值为：&quot; + ((((i &gt; j)? i : j) &gt; k)? ((i &gt; j)? i : j) : k)); &#125;&#125; 可变个数的形参 JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量 public static void test(int a,String[] books); JDK 5.0：采用可变个数形参来定义方法，传入多个同一类型变量 public static void test(int a,String...books); 具体使用： 可变个数形参的格式：数据类型 … 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0个、1个、2个…… 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。 ==可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不够成重载（即二者不能共存）。== 可变个数形参在方法的形参列表中，==必须声明在末尾==。 可变个数形参在方法的形参列表中，==最多只能声明一个可变形参==。 示例 1234567891011121314151617181920212223242526272829303132public class VarAgu &#123; public static void main(String[] args) &#123; VarAgu test = new VarAgu(); test.show(12); test.show(&quot;Hello&quot;); test.show(&quot;Hello&quot;,&quot;world&quot;); test.show(); // test.show(new String[] &#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量,JDK 5.0向前兼容,所以(String ... strs)同样可以用此方法传入形参 test.show(&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;); &#125; public void show(int i) &#123; System.out.println(&quot;show(int i)&quot;); &#125; public void show(String s) &#123; System.out.println(&quot;show(String)&quot;); &#125; public void show(String ... strs) &#123; System.out.println(&quot;show(String ... strs)&quot;); //调用 for(int i = 0;i &lt; strs.length;i++) &#123; System.out.println(strs[i]); &#125; &#125; // public void show(String[] strs) &#123;//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量// System.out.println(&quot;show(String[] strs)&quot;);// &#125;&#125; ==方法参数的值传递机制==变量的值传递机制 关于变量的赋值： 如果是基本数据类型，此时赋值的是变量所保存的数据值； 如果变量是引用数据类型，此时，赋值的是变量所保存的数据的地址值。 示例 12345678910111213141516171819202122public class ValueTransfer &#123; public static void main(String[] args) &#123; System.out.println(&quot;******基本数据类型的值传递情况******&quot;); int m = 10; int n = m; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); System.out.println(&quot;******引用数据类型的值传递情况******&quot;); Order o1 = new Order(); o1.orderID = 1001; Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。 System.out.println(&quot;o1.orderID = &quot; + o1.orderID + &quot;, o2.orderID = &quot; + o2.orderID); o2.orderID = 1002; System.out.println(&quot;o1.orderID = &quot; + o1.orderID + &quot;, o2.orderID = &quot; + o2.orderID); &#125;&#125;class Order&#123; int orderID;&#125; 方法的形参传递机制：值传递 形参：方法定义时，声明的小括号内的参数。 实参：调用方法时实际传递给形参的数据。 值传递机制： 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值; 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。 示例1 123456789101112131415161718192021public class ValueTransfer01 &#123; public static void main(String[] args) &#123; int m = 10; int n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); //交换两个变量值的操作// int temp = m;// m = n;// n = temp; ValueTransfer01 test = new ValueTransfer01(); test.swap(m, n);//未能交换，原因看内存解析。 System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); &#125; public void swap(int m,int n) &#123; int temp = m; m = n; n = temp; &#125;&#125; 结果： 内存解析（交换失败原因） 示例2 12345678910111213141516171819202122232425262728public class ValueTransfer02 &#123; public static void main(String[] args) &#123; Data data = new Data(); data.m = 10; data.n = 20; System.out.println(&quot;m = &quot; + data.m + &quot;,n = &quot; + data.n); //交换m和n的值// int temp = data.m;// data.m = data.n;// data.n = temp; ValueTransfer02 test = new ValueTransfer02(); test.swap(data); System.out.println(&quot;m = &quot; + data.m + &quot;,n = &quot; + data.n); &#125; public void swap(Data data) &#123; int temp = data.m; data.m = data.n; data.n = temp; &#125;&#125;class Data&#123; int m; int n;&#125; 运行结果 内存解析 练习题例题一：方法的参数传递123456789101112131415161718192021222324252627282930public class ValueTransferEx01 &#123; public static void main(String[] args) &#123; ValueTransferEx01 test = new ValueTransferEx01(); test.first(); &#125; public void first()&#123; int i = 5; Value v = new Value(); v.i = 25; second(v,i); System.out.println(v.i); &#125; public void second(Value v,int i)&#123; i = 0; v.i = 20; Value val = new Value(); v = val; System.out.println(v.i + &quot; &quot; + i); &#125;&#125;class Value&#123; int i = 15;&#125;//result15 020 内存解析 递归（recursion）方法 递归方法：一个方法体内调用自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 示例 123456789101112131415161718192021222324252627282930313233343536373839public class RecursionIns &#123; public static void main(String[] args) &#123; //计算1-100内所有数的和 //方式一 int sum1 = 0; for(int i = 1;i &lt;= 100;i++) &#123; sum1 += i; &#125; System.out.println(&quot;方式一：&quot; + sum1); //方式二（递归）： RecursionIns test = new RecursionIns(); int sum2 = test.getSum(100); System.out.println(&quot;方式二：&quot; + sum2); //计算阶乘 int n = 5; int fac = test.getFac(n); System.out.println(n + &quot;的阶乘为：&quot; + fac); &#125; //计算1-100内所有数的和的方法 public int getSum(int n) &#123; if(n == 1) &#123; return n; &#125;else &#123; return n + getSum(n - 1); &#125; &#125; //计算1-n之间的乘积：n! public int getFac(int n) &#123; if(n == 1) &#123; return n; &#125;else &#123; return n * getFac(n - 1); &#125; &#125;&#125; 练习题 已知有一个数列：f(0) = 1，f(1) = 4，f(n+2) = 2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。 12345678910111213141516public class RecursionEx01 &#123; public static void main(String[] args) &#123; RecursionEx01 test = new RecursionEx01(); System.out.println(&quot;f(10) = &quot; + test.f(10)); &#125; public int f(int n) &#123; if(n == 0) &#123; return 1; &#125;else if(n == 1) &#123; return 4; &#125;else &#123; return 2*f(n - 1) + f(n - 2); &#125; &#125;&#125; 斐波那契数列（Fibonacci）: 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值1 1 2 3 5 8 13 21 34 55。 规律：一个数等于前两个数之和。 要求：计算斐波那契数列的第n个值，并将整个数列打印出来。 1234567891011121314151617181920212223public class RecursionEx02 &#123; public static void main(String[] args) &#123; RecursionEx02 test = new RecursionEx02(); Scanner input = new Scanner(System.in); System.out.println(&quot;要打印斐波那契数列前几位？（输入任意大于0的整数）&quot;); int n = input.nextInt(); for(int i = 1;i &lt;= n;i++) &#123; System.out.print(test.f(i) + &quot; &quot;); &#125; System.out.println(); input.close(); &#125; public int f(int n) &#123; if(n == 1) &#123; return 1; &#125;else if(n == 2) &#123; return 1; &#125;else &#123; return f(n - 1) + f(n - 2); &#125; &#125;&#125; OOP特征一：封装与隐藏 OOP，即Object oriented programming，面向对象编程。 引入 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗？有必要碰电动机吗? 我要开车…… 我们程序设计追求==“高内聚，低耦合”==。 高内聚：类的内部操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 信息的封装和隐藏 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值的操作要受属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们需要给属性赋值加入额外的条件。这个条件就不能再属性声明时体现，我们只能通过方法进行限制条件的添加。（比如，示例中的setLegs()方法）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private）。 –&gt; 此时，针对属性就体现了封装性。 封装性的体现：我们讲类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。 拓展：封装性的体现 ①如上 ②不对外暴露的私有的方法 ③单例模式 … 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class InsAnimal &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.name = &quot;大黄&quot;; //a.age = 1;//age属性私有后无法赋值，通过setAge()方法来赋值 a.setAge(1); //a.legs = 4;//The field Animal.legs is not visible（不可见） a.setLegs(4); a.show(); System.out.println(); a.setLegs(6); a.show(); System.out.println(); a.setLegs(-2); a.show(); &#125;&#125;class Animal&#123; String name; private int age; private int legs;//私有权限修饰符，使得外界不能直接调用legs这个参数，只能通过规定的方式（setLegs()）来设置legs属性的值 //筛选合理赋值 public void setLegs(int l) &#123; if(l &gt;= 0 &amp;&amp; l % 2 == 0) &#123; legs = l; &#125;else&#123; legs = 0; //抛出一个异常（暂时没有讲） &#125; &#125; //legs被私有化以后用它来获取当前legs属性 public int getLegs() &#123; return legs; &#125; public void eat() &#123; System.out.println(&quot;动物进食&quot;); &#125; public void show() &#123; System.out.println(&quot;name:&quot; + name + &quot;，age:&quot; + age + &quot;， legs:&quot; + legs); &#125; //提供属性age的get和set方法 public int getAge() &#123; return age; &#125; public void setAge(int n) &#123; age = n; &#125;&#125; 四种访问权限修饰符 封装性的体现，需要权限修饰符来配合 Java规定的种权限（从小到大排列）：private、缺省、protected、public Java的权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类成员的访问权限。 4种权限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类。 具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类只能用default（缺省）、public。 总结封装性： Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构的在被调用时的可见性大小。 类的成员之三：构造器（或构造方法）构造器的作用 创建对象 初始化对象的信息 示例： 1234567891011121314151617181920212223242526272829303132public class PersonTest &#123; public static void main(String[] args) &#123; //创建类的对象：new + 构造器 Person p = new Person(); p.eat(); Person p1 = new Person(&quot;Tom&quot;); System.out.println(p1.name); &#125;&#125;class Person&#123; //属性 String name; int age; //构造器 public Person() &#123; System.out.println(&quot;Person()....&quot;); &#125; public Person(String n) &#123; name = n; &#125; //方法 public void eat() &#123; System.out.println(&quot;人吃饭&quot;); &#125; public void study() &#123; System.out.println(&quot;人可以学习&quot;); &#125;&#125; 说明 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){}。 一个类中定义多个构造器，彼此构成重载。 一旦我们显式定义了构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 总结：属性赋值的先后顺序 默认初始化 显式初始化 构造器中初始化 通过”对象.方法”的方式赋值 扩展知识扩展知识一：JavaBean JavaBean是一种Java语言写成的可重用组件。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 用户可以使用JavaBean将功能、处理。值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 扩展知识二：UML类图 +表示public类型，-表示private类型，#表示protected类型。 方法的写法： 方法的类型（+、-） 方法名(参数名:参数类型):返回值类型 ==关键字：this==this关键字的使用 his可以用来修饰：属性、方法、构造器。 this修饰属性和方法：this可理解为当前对象（方法中）或当前正在创建的对象（构造器中） 在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用“this.属性”或”this.方法“的方式，调用当前属性或方法。但是通常情况下，我们都选择省略”this.“。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。、 this调用构造器 我们在类的构造器中，可以显式的使用“this(形参列表)”的方式，调用本类中指定的其他构造器。 构造器中不能通过“this(形参列表)”的方式调用自己。 如果有n个构造器，最多有n-1个个构造器中使用了“this(形参列表)” 规定：“this(形参列表)”必须声明在当前构造器的首行 构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他构造器。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setAge(18); System.out.println(p1.getAge()); Person p2 = new Person(&quot;Triabin&quot;,20); System.out.println(p2.getAge() + &quot;\\t&quot; + p2.getName()); &#125;&#125;class Person&#123; private String name; private int age; public Person() &#123; &#125; //构造器中使用:理解为当前正在创建的对象（Person） public Person(String name) &#123; this.name = name; &#125; public Person(int age) &#123; this.age = age; &#125; public Person(String name,int age) &#123;// this(name);//调用其他构造器// this.age = age; this(name); this.age = age; &#125; //方法中使用:理解为当前对象（Person） public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age; &#125;&#125; 关键字：package、importpackagepackage关键字的使用 为了更好的实现项目中类的管理，提供包的概念。 使用package来声明类或接口所属的包，声明在源文件首行。 包，属于标识符，遵循标识符的命名规则、规范（全小写）、见名知意。 每“.”一次，就代表一层文件目录。 同一个包下，不能命名同名的接口、类。 JDK中主要的包介绍 java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System 和 Thread，提供常用功能。 java.net—-包含执行与网络相关的操作的类和接口。 java.io—-包含能提供多种输入/输出功能的类。 java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text—-包含了Java进行JDBC数据库编程的相关类/接口。 java.sql—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 MVC设计模式 MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。 模型层：model，主要处理数据。 数据对象封装 model.bean/domain 数据库操作类 model.dao 数据库 model.db 控制层：controller，处理业务逻辑。 应用界面相关 controller.activity 存放fragment controller.fragment 显示列表的适配器 controller.adapter 服务相关的 controller.service 抽取的基类 controller.base 视图层：view，显示数据。 相关工具类 view.utils 自定义view view.ui importimport关键字的使用 在源文件显式的使用import结构导入指定包下的类、接口。 声明在包的声明和类的声明之间。 如果需要导入多个包，则并列写出即可。 可以使用“xxx.*”的方式导入xxx包下所有结构。 如果使用的类或接口是java.lang包下定义的，则可以省略import结构。 如果使用的类或接口是本包下定义的，则可以省略import结构。 如果再源文件中使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 如果使用“xxx.*”的方式表明可以调用xxx包下所有结构。但如果使用的是xxx子包下的结构，仍需要显示导入。 import static：导入指定类或接口中的静态结构。 静态结构：属性或方法 面试题面向对象面向对象的三大特征说明 面向对象有三大特点：封装、继承、多态。(如果要回答四个，可加上抽象性这一特点) 继承性 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装性 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 多态性 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 抽象性 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 作用域public、private、protected及默认不写时的区别？ public：修饰的结构在同一个工程(Project)中的结构都可调用； protected：同一个工程中不同包的子类、同一个包以内都可调用； 不写(缺省)：同一个包中的结构都可调用； private：只在其所在类内部可以调用。 找错123456public class Something &#123; void doSomething () &#123; private String s = &quot;&quot;; int l = s.length(); &#125;&#125; 答案：错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。 Java的内存管理之垃圾回收（了解） 分配：由JVM自动为其分配相应的内存空间 释放：由JVM提供垃圾回收机制自动的释放内存空间 垃圾回收机制（GC：Garbage Collection）：将垃圾对象所占用的堆内存进行回收。Java的垃圾回收机制是JVM提供的能力，由单独的系统级垃圾回收线程在空闲时间以不定时的方式动态回收。 垃圾对象：不再被任何引用指向的对象。 简答 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十七章 Java9&10&11新特性","slug":"Java基础/第十七章 Java9&10&11新特性","date":"2020-06-11T16:00:00.000Z","updated":"2020-12-10T13:18:55.024Z","comments":true,"path":"undefined/1e12.html","link":"","permalink":"https://asteroidcs.github.io/undefined/1e12.html","excerpt":"","text":"Java 9 的新特性 JDK 和 JRE 目录结构的改变 JDK 8 的目录结构 JDK 9 的目录结构 模块化系统: Jigsaw ——&gt; Modularity 用模块来管理各个package，通过声明某个package 暴露，==模块(module)的概念==，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。 实现目标 模块化的主要目的在于减少内存的开销 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护 改进 Java SE 平台，使其可以适应不同大小的计算设备 改进其安全性，可维护性，提高性能 模块将由通常的类和新的模块声明文件(module-info.java)组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。 要想在java9demo模块中调用java9test模块下包中的结构： 需要在java9test的module-info.java中声明: 对应在java 9demo 模块的src 下创建module-info.java文件: Java的REPL工具：jShell命令 调出jShell 获取帮助 基本使用 导入指定的包 默认已经导入如下的所有包：(包含java.lang包) ==Tips==：在 JShell 环境下，语句末尾的“;” 是可选的。但推荐还是最好加上。提高代码可读 性。 只需按下 Tab 键，就能自动补全代码 列出当前 session 里所有有效的代码片段 查看当前 session 下所有创建过的变量 查看当前 session 下所有创建过的方法 Tips：我们还可以重新定义相同方法名和参数列表的方法，即为对现有方法的修改(或 覆盖)。 使用/open命令调用: 没有受检异常(编译时异常) 退出jShell 语法改进接口的私有方法 Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。 12345678910111213141516171819202122232425package lesson;/** * @author Justry * @Description * @date 2020-12-06 10:28 上午 */public interface MyInterface &#123; //如下三个方法放入权限修饰符都是public void methodAbstract(); static void methodStatic()&#123; System.out.println(&quot;我是接口中的静态方法&quot;); &#125; default void methodDefault()&#123; System.out.println(&quot;我是接口中的默认方法&quot;); &#125; //Java 8中此处报错，在java 9中就不会出现问题 private void methodPrivate()&#123; System.out.println(&quot;我是接口中的私有方法&quot;); &#125;&#125; 在Java 9中，接口更加的灵活和强大，==连方法的访问权限修饰符都可 以声明为private的了==，此时方法将不会成为你对外暴露的API的一部分 1234567891011121314151617181920212223242526272829303132package lesson;/** * @author Justry * @Description * @date 2020-12-06 10:34 上午 */public class MyInterfaceImp implements MyInterface&#123; @Override public void methodAbstract() &#123; &#125; @Override public void methodDefault() &#123; System.out.println(&quot;重写的默认方法&quot;); &#125; public static void main(String[] args) &#123; //接口中的静态方法只能由接口自己调用 MyInterface.methodStatic(); //可以调用默认方法 MyInterfaceImp imp = new MyInterfaceImp(); imp.methodDefault(); //无法调用私有方法，只能接口自己用 //imp.methodPrivate(); &#125;&#125; 钻石操作符使用升级 能够与匿名实现类共同使用钻石操作符(diamond operator) 在Java 8中如下的操作是会报错的: Java 9中如下操作可以正常执行通过: try语句 Java 8 中，可以实现资源的==自动关闭==，但是==要求执行后必须关闭的所有资源必须在try子句中初始化==，否则编译不通过。如下例所示： Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package lesson;import java.io.IOException;import java.io.InputStreamReader;/** * @author Justry * @Description * @date 2020-12-06 11:06 上午 */public class Java9Test &#123; public static void main(String[] args) &#123; //java 8之前的资源关闭操作 InputStreamReader reader = null; try &#123; reader = new InputStreamReader(System.in); char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //java 8中的资源关闭操作:自动关闭 //要求自动关闭的资源的初始化必须放在try的一对小括号中 try (InputStreamReader reader = new InputStreamReader(System.in)) &#123; char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //java 9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一对小括号外 //此时的资源属性是常量，声明为final，不可修改 InputStreamReader reader = new InputStreamReader(System.in); try (reader) &#123; char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; String存储结构变更 String 再也不用 char[] 来存储，改成了 byte[] 加上编码标记，节约 了一些空间。 那StringBuffer 和 StringBuilder 是否仍无动于衷呢? 集合工厂方法：快速创建只读集合 以前要创建一个==只读、不可改变==的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。 Java 9因此引入了方便的方法，这使得类似的事情更容易表达。 调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的:在 创建后，继续添加元素到这些集合会导致“UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。 InputStream 加强 InputStream 终于有了一个非常有用的方法：==transferTo==，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。 增强的 Stream API Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。 在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法: takeWhile dropWhile, ofNullable iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。 takeWhile()的使用 用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，==takeWhile 返回从开头开始的尽量多的元素==。 123456789@Test public void test1() &#123; // takeWhile 返回从开头开始的按照指定规则尽量多的元素 List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list.stream().takeWhile(x -&gt; x &lt; 50).forEach(System.out::println); // 45 43 System.out.println(); list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); list.stream().takeWhile(x -&gt; x &lt; 5).forEach(System.out::println); // 1 2 3 4 &#125; dropWhile()的使用 dropWhile 的行为与 takeWhile 相反，返回剩余的元素。 12345678910@Test public void test2() &#123; List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list.stream().dropWhile(x -&gt; x &lt; 50).forEach(System.out::println); System.out.println(); list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); list.stream().dropWhile(x -&gt; x &lt; 5).forEach(System.out::println); &#125; ofNullable()的使用 Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。 123456789101112131415161718192021222324@Test public void test3() &#123; // 报NullPointerException，of()参数不能存储单个null值 // Stream&lt;Object&gt; stream1 = Stream.of(null); // System.out.println(stream1.count()); // 不报异常，允许通过 Stream&lt;String&gt; stringStream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, null); System.out.println(stringStream.count()); // 3 // 不报异常，允许通过 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;AA&quot;); list.add(null); System.out.println(list.stream().count()); // 2 // ofNullable():允许值为null Stream&lt;Object&gt; stream1 = Stream.ofNullable(null); System.out.println(stream1.count());// 0 Stream&lt;String&gt; stream = Stream.ofNullable(&quot;hello world&quot;); System.out.println(stream.count()); // 1 &#125; iterate()重载的使用 这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。 12345678@Test public void test4() &#123; // 原来的控制终止方式: Stream.iterate(1, i -&gt; i + 1).limit(10).forEach(System.out::println); // 现在的终止方式: Stream.iterate(1, i -&gt; i &lt; 100, i -&gt; i + 1).forEach(System.out::println); &#125; Optional获取Stream的方法 Optional类中stream()的使用 123456789101112@Test public void test6() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Tom&quot;); list.add(&quot;Jerry&quot;); list.add(&quot;Tim&quot;); Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list); Stream&lt;List&lt;String&gt;&gt; stream = optional.stream(); stream.flatMap(x -&gt; x.stream()).forEach(System.out::println); &#125; Javascript引擎升级：Nashorn Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。 Java 10 新特性局部变量类型推断 好处：减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！ 举例如下： 场景一：类实例化时：作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第 一次用于声明变量类型，第二次用于构造器。 1LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); 场景二：返回值类型含复杂泛型结构：变量的声明类型书写复杂且较长，尤其是加上泛型的使用 1Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator(); 场景三： 我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如： 1234URL url = new URL(&quot;http://www.atguigu.com&quot;);URLConnection connection = url.openConnection();Reader reader = new BufferedReader(newInputStreamReader(connection.getInputStream())); 适用于以下情况： 局部变量的初始化 1var list = new ArrayList&lt;&gt;(); 增强for循环中的索引 123for(var v : list) &#123;System.out.println(v);&#125; 传统for循环中 123for(var i = 0;i &lt; 100;i++) &#123;System.out.println(i);&#125; 在局部变量中使用时，如下情况不适用： 初始值为null Lambda表达式 方法引用 为数组静态初始化 不适用以下的结构中： ==工作原理== 在处理 var时，==编译器先是查看表达式右边部分==，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。 ==注 意== var不是一个关键字 这不是JavaScript，var并不会改变Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码： 集合新增创建不可变集合的方法 自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合。 示例1和2代码基本一致，为什么一个为true,一个为false? 结论：copyOf(Xxx coll)：如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前coll；如果参数coll不是只读集合，则copyOf返回一个新的只读集合，这个集合只读。 Java 11 新特性新增了一系列字符串处理方法 Optional 加强 可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。 123456789101112131415161718@Test public void test() &#123; Optional&lt;Object&gt; op = Optional.empty(); System.out.println(op.isPresent()); System.out.println(op.isEmpty()); op = Optional.of(&quot;abc&quot;); Object o = op.orElseThrow(); System.out.println(o); Optional&lt;String&gt; op1 = Optional.of(&quot;hello&quot;); // op = Optional.empty(); //or:value非空，返回对应的Optional；value为空，返回形参封装的Optional Optional&lt;Object&gt; op2 = op.or(() -&gt; op1); System.out.println(op2); &#125; 局部变量类型推断升级 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样=的语法。 12345678910@Test public void test2() &#123; //错误的形式: 必须要有类型, 可以加上var //Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase()); //正确的形式: //使用var的好处是在使用lambda表达式时给参数加上注解。 Consumer&lt;String&gt; con2 = (@Deprecated var t) -&gt; System.out.println(t.toUpperCase()); &#125; 全新的 HTTP 客户端 API 更简化的编译运行程序 ZGC 优势： GC暂停时间不会超过10ms 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG) 和G1相比, 应用吞吐能力不会下降超过15% 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础 初始只支持64位系统 ==ZGC的设计目标是==：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。 其它新特性","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十六章 Java8的其他新特性","slug":"Java基础/第十六章 Java8的其他新特性","date":"2020-05-11T16:00:00.000Z","updated":"2020-12-10T13:19:01.501Z","comments":true,"path":"undefined/1e12.html","link":"","permalink":"https://asteroidcs.github.io/undefined/1e12.html","excerpt":"","text":"优点： 速度更快 代码更少(增加了新的语法:Lambda 表达式)  强大的 Stream API 便于并行 最大化减少空指针异常:Optional Nashorn引擎，允许在JVM上运行JS应用 并行流与串行流 并行流：就是把一个内容分成多个数据块，并用不同的线程分别处理每个数 据块的流。 相比较串行的流，并行的流可以很大程度上提高程序的执行效率。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流 之间进行切换 Lambda表达式为什么使用 Lambda 表达式1Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以 传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 从匿名类到 Lambda 的转换举例1 12345678910111213141516171819202122232425262728293031package lesson1;import org.junit.jupiter.api.Test;/** * @author Justry * @Description * @date 2020-12-02 11:02 上午 */public class LambdaTest &#123; @Test public void test1() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱吃红烧肉！&quot;); &#125; &#125;; runnable.run(); System.out.println(&quot;******************************&quot;); Runnable runnable1 = () -&gt; System.out.println(&quot;我爱喝排骨汤！&quot;); runnable1.run(); &#125;&#125; 从匿名类到 Lambda 的转换举例2 123456789101112131415161718192021@Test public void test2() &#123; Comparator&lt;Integer&gt; integerComparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125; &#125;; int compare = integerComparator.compare(12, 21); System.out.println(compare); System.out.println(&quot;******************************&quot;); Comparator&lt;Integer&gt; integerComparator1 = (o1, o2) -&gt; Integer.compare(o1, o2); //Comparator&lt;Integer&gt; integerComparator1 = Integer :: compare; int compare1 = integerComparator.compare(12, 21); System.out.println(compare1); &#125; Lambda 表达式：语法 Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分： 左侧:指定了 Lambda 表达式需要的参数列表（其实就是接口中的抽象方法的形参列表） 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。 Lambda 表达式的使用（分6种情况） 语法格式一:无参，无返回值 语法格式二：:Lambda 需要一个参数，但是没有返回值。 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 总结： 左边：Lambda形参列表的参数类型可以省略（类型推断），若Lambda形参列表只有一个参数，其中一对（）也可以省略 右边：Lambda体应该用一对{}包裹；如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return 类型推断​ 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序 的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于 上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。 函数式(Functional)接口什么是函数式(Functional)接口 只包含==一个抽象方法==的接口，称为==函数式接口==。 可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda 表达式抛出一个受检异常(即:非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。 可以在一个接口上使用 ==@FunctionalInterface==注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 在java.util.function包下定义了Java 8 的丰富的函数式接口 如何理解函数式接口 java 不但可以支持OOP还 可以支持OOF (面向函数编程) 在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。 在Java8中，==Lambda表达式就是一个函数式接口的实例==。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。 ==以前用匿名实现类表示的现在都可以用Lambda表达式来写。== Java 内置四大核心函数式接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package lesson1;import org.junit.jupiter.api.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;/** * @author Justry * @Description * @date 2020-12-02 11:57 上午 */public class LambdaTest1 &#123; @Test public void test1()&#123; happyTime(500, new Consumer&lt;Double&gt;() &#123; @Override public void accept(Double aDouble) &#123; System.out.println(&quot;购物花了&quot; + aDouble); &#125; &#125;); System.out.println(&quot;******************************&quot;); happyTime(400, money -&gt; System.out.println(&quot;购物花了&quot; + money)); &#125; public void happyTime(double money, Consumer&lt;Double&gt; consumer)&#123; consumer.accept(money); &#125; @Test public void test2()&#123; List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;, &quot;南京&quot;, &quot;天津&quot;, &quot;东京&quot;, &quot;西京&quot;); List&lt;String&gt; filterString = filterString(list, new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(&quot;京&quot;); &#125; &#125;); System.out.println(filterString); System.out.println(&quot;******************************&quot;); List&lt;String&gt; filterString1 = filterString(list, s -&gt; s.contains(&quot;京&quot;)); System.out.println(filterString1); &#125; //根据给定规则，过滤集合中的字符串。此规则由Predicate的方法决定 public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;(); for (String s : list)&#123; if (pre.test(s))&#123; filterList.add(s); &#125; &#125; return filterList; &#125;&#125; 方法引用与构造器引用方法引用(Method References) 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用! 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。 ==要求==：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致! ==格式==：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。 如下三种主要使用情况： 对象：：实例方法名 类：：静态方法名 类：：实例方法名 ==注意==：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时:ClassName::methodName 1234567891011121314//情况三：类：：实例方法 //Comparator中的int compare(T t1, T t2) //String中的int t1.compareTo(t2) @Test public void test2()&#123; Comparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.compareTo(s2); System.out.println(comparator.compare(&quot;abc&quot;, &quot;abd&quot;)); System.out.println(&quot;**************************************&quot;); Comparator&lt;String&gt; comparator1 = String::compareTo; System.out.println(comparator1.compare(&quot;abc&quot;, &quot;abm&quot;)); &#125; 构造器引用 格式:：ClassName：：new 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型 数组引用 格式: type[] :: new 可以把数组看作是一个特殊的类，则写法与构造器引用一致 Stream API Java8中有两大最为重要的改变。第一个是：Lambda 表达式，另外一个则是：Stream API。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。 为什么要使用Stream API 实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。 Stream 和 Collection 集合的区别： Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。 前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。 什么是 Stream 数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。 “集合讲的是数据，Stream讲的是计算！” 注意： Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream 的操作三个步骤 步骤： 创建 Stream：一个数据源(如:集合、数组)，获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 创建 Stream方式 方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流 的方法: 方式二：通过数组 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流: 12345678910public class StreamAPITest &#123; @Test public void test1() &#123; int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; IntStream stream = Arrays.stream(arr); &#125;&#125; 方式三:通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。 12345@Test public void test2() &#123; Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6); &#125; 方式四：创建无限流（用的较少，了解即可） 12345678@Test public void test3() &#123; // 遍历前10个偶数 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out :: println); Stream.generate(Math::random).limit(10).forEach(System.out :: println); &#125; Stream 的中间操作​ 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则==中间操作不会执行任何的处理!而在终止操作时一次性全 部处理，称为“惰性求值”== 筛选与切片 映 射 123456@Test public void test1() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;); list.stream().map(str -&gt; str.toCharArray()).forEach(System.out::println); &#125; 排序 Stream 的终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如:List、Integer，甚至是 void 。 流进行了终止操作后，不能再次使用。 匹配与查找 归约 123456@Test public void test1() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list.stream().reduce(0, Integer::sum); System.out.println(sum); &#125; 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名 收集 ​ Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map) Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表： Optional类 Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 Optional类的Javadoc描述如下:这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 创建Optional类对象的方法: 判断Optional容器中是否包含对象： 获取Optional容器的对象: 12345678910111213@Test public void test1() &#123; Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); // 如果女朋友存在就打印女朋友的信息 opt.ifPresent(System.out::println); &#125; @Test public void test2() &#123; Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); // 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了 Girl girl = opt.orElse(new Girl(&quot;嫦娥&quot;)); System.out.println(&quot;他的女朋友是:&quot; + girl.getName()); &#125; 123456789101112131415@Test public void test3() &#123; Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888)); //判断opt中员工对象是否满足条件，如果满足就保留，否则返回空 Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000); System.out.println(emp); &#125; @Test public void test4() &#123; Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888)); //如果opt中员工对象不为空，就涨薪10% Optional&lt;Employee&gt; emp = opt.map(e -&gt; &#123; e.setSalary(e.getSalary() % 1.1); return e; &#125;); System.out.println(emp); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十五章 反射机制","slug":"Java基础/第十五章 反射","date":"2020-01-11T16:00:00.000Z","updated":"2020-12-10T13:18:38.276Z","comments":true,"path":"undefined/a7d1.html","link":"","permalink":"https://asteroidcs.github.io/undefined/a7d1.html","excerpt":"","text":"重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构概述Java Reflection Reflection(反射)**是被视为$\\color{red}{动态语言}$**的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 补充：动态语言 vs 静态语言 动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。 Java不是动态语言，但Java可以称之为$\\color{yellow}{“准动态语言”}$。即Java有一定的动态性，可以利用$\\color{red}{反射机制、字节码操作}$获得类似动态语言的特性。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。 $\\color{red}{我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，故形象的称之为：反射}$ Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射相关的主要API java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 举例Person1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package lesson;/** * @author Justry * @Description * @date 2020-12-01 12:00 下午 */public class Person &#123; public int age; private String name; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; private Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show() &#123; System.out.println(&quot;你好，我是一个人！&quot;); &#125; private String showNation(String nation) &#123; System.out.println(&quot;我的国籍是：&quot; + nation); return nation; &#125;&#125; 反射前对于类的操作12345678910111213141516//反射前对于类的操作@Testpublic void test1() &#123; //1.创建Person类的实例化 Person p1 = new Person(&quot;Tom&quot;, 12); //2.通过对象，调用其内部的属性、方法 p1.age = 10; System.out.println(p1); p1.show(); //在Person类的外部，不可以通过Person类的对象调用其内部私有结构&#125; 反射后对于类的操作123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; Class&lt;Person&gt; personClass = Person.class; //1.通过反射，创建Person类的对象 Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); Person person = constructor.newInstance(&quot;Tom&quot;, 12); System.out.println(person); //2.通过反射，调用对象指定的属性、方法 //调属性 Field age = personClass.getDeclaredField(&quot;age&quot;); age.set(person, 10); System.out.println(person); //调方法 Method show = personClass.getDeclaredMethod(&quot;show&quot;); show.invoke(person); System.out.println(&quot;*************************************************&quot;); //通过反射，可以调用Person类的私有结构。如：私有的构造器、方法、属性 //调用私有的构造器 Constructor&lt;Person&gt; constructor1 = personClass.getDeclaredConstructor(String.class); constructor1.setAccessible(true); Person person1 = constructor1.newInstance(&quot;Jerry&quot;); System.out.println(person1); //调用私有的属性 Field name = personClass.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(person1, &quot;Tom&quot;); System.out.println(person1); //调用私有的方法 Method showNation = personClass.getDeclaredMethod(&quot;showNation&quot;, String.class); showNation.setAccessible(true); Object nation = showNation.invoke(person1, &quot;中国&quot;);// 相当于p1.showNation(&quot;中国&quot;） System.out.println(nation); &#125; 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？12建议直接用new的方式//什么时候用：放射的方式。————&gt; 反射的特征：动态性 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？理解Class类 并 获取Class的实例Class 类 类的加载过程 程序经过Java.exe命令以后，会生成一个或多个字节码文件(.class结尾) 接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存。此过程就称为类的加载。加载到内存中的类，就称为运行时的类，此时运行时的类就作为C lass的一个实例 换句话说，Class的实例就对应着一个运行时类 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 在Object类中定义了以下的方法，此方法将被所有子类继承 public final Class getClass() 以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class类的常用方法 获取Class类的实例(四种方法) 前提:若已知具体的类，通过类的class属性获取，该方法最为安全可靠， 程序性能最高 1Class clazz = String.class; 前提:已知某个类的实例，调用该实例的getClass()方法获取Class对象 1Class clazz = “www.atguigu.com”.getClass(); 前提:已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException 1Class clazz = Class.forName(“java.lang.String”) 其他方式(不做要求) 1ClassLoader cl = this.getClass().getClassLoader(); Class clazz4 = cl.loadClass(“类的全类名”); 12345678910111213141516171819202122//获取Class的实例方式 @Test public void test3() throws ClassNotFoundException &#123; //方式一：调用运行时类的属性：.class Class clazz1 = Person.class; System.out.println(clazz1); // class lesson.Person //方式二：通过运行时类的对象 Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); // class lesson.Person //方式三：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(&quot;lesson.Person&quot;); System.out.println(clazz3); // class lesson.Person //方式四：使用类的加载器：ClassLoader ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;lesson.Person&quot;); System.out.println(clazz4); // class lesson.Person &#125; 哪些类型可以有Class对象? 12345678Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = int.class;Class c8 = void.class;Class c9 = Class.class;int[] a = new int[10];int[] b = new int[100];Class c10 = a.getClass();Class c11 = b.getClass();// 只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11); 类的加载 与 ClassLoader的理解类的加载过程（了解）​ 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据$\\color{yellow}{转换成方法区的运行时数据结构}$，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象 ClassLoader(了解) 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。 创建运行时类的对象有了Class对象，能做什么? 创建类的对象：调用Class对象的newInstance()方法。要求： 类必须有一个无参数的构造器。 类的构造器的访问权限需要足够，通常设置为public 1234567891011121314public class NewInstanceTest &#123; @Test public void test1() throws IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; /* newInstance():调用此方法，创建对应的运行时类的对象 */ Person obj = clazz.newInstance(); System.out.println(obj); &#125;&#125; 在javabean中要求提供一个public的空参构造器。原因： 便于通过反射，创建运行时类的对象 便于子类继承次运行时类时，默认调用super()时，保证父类有此构造器 难道没有无参的构造器就不能创建对象了吗? ————&gt; NO，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下: 通过Class类的$\\color{red}{getDeclaredConstructor(Class … parameterTypes)}$取得本类的指定形参类 型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象。 1234567891011121314151617181920212223242526272829303132333435363738//体现反射的动态性@Test public void test2()&#123; int num = new Random().nextInt(3); String classPath = &quot;&quot;; switch (num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;lesson.Person&quot;; break; &#125; try &#123; Object instance = getInstance(classPath); System.out.println(instance); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; /* 创建一个指定类的对象 */ public Object getInstance(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName(classPath); return clazz.newInstance(); &#125;&#125; 获取运行时类的完整结构 使用反射可以取得: 实现的全部接口：确定此对象所表示的类或接口实现的接口。 1public Class&lt;?&gt;[] getInterfaces() 所继承的父类：返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class 1public Class&lt;? Super T&gt; getSuperclass() 全部的构造器 返回此 Class 对象所表示的类的所有public构造方法。 1public Constructor&lt;T&gt;[] getConstructors() 返回此 Class 对象表示的类声明的所有构造方法。 1public Constructor&lt;T&gt;[] getDeclaredConstructors() Constructor类中: 取得修饰符: 1public int getModifiers(); 取得方法名称: 1public String getName(); 取得参数的类型: 1public Class&lt;?&gt;[] getParameterTypes(); 全部的方法 返回此Class对象所表示的类或接口的全部方法 1public Method[] getDeclaredMethods() 返回此Class对象所表示的类或接口的public的方法 1public Method[] getMethods() Method类中: 取得全部的返回值 1public Class&lt;?&gt; getReturnType() 取得全部的参数 1public Class&lt;?&gt;[] getParameterTypes() 取得修饰符 1public int getModifiers() 取得异常信息 1public Class&lt;?&gt;[] getExceptionTypes() 全部的Field 返回此Class对象所表示的类或接口的public的Field。 1public Field[] getFields() 返回此Class对象所表示的类或接口的全部Field。 1public Field[] getDeclaredFields() Field方法中: 以整数形式返回此Field的修饰符 1public int getModifiers() 得到Field的属性类型 1public Class&lt;?&gt; getType() 返回Field的名称。 1public String getName() 1234567891011121314151617181920212223242526272829303132333435363738394041public class FieldTest &#123; @Test public void test1()&#123; Class&lt;Person&gt; clazz = Person.class; //获取属性结构： //getFields():能够获取当前运行时类及其所有父类当中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields)&#123; System.out.println(f); &#125; System.out.println(&quot;***************************************&quot;); //getDeclaredFields():获取当前运行时类中声明的所有属性，不包含父类中声明的属性 Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; System.out.println(f); &#125; &#125; @Test public void test2()&#123; Class&lt;Person&gt; clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; //1.权限修饰符 int modifier = f.getModifiers(); System.out.print(Modifier.toString(modifier) + &quot;\\t&quot;); //2.数据类型 Class&lt;?&gt; type = f.getType(); System.out.print(type.getName() + &quot;\\t&quot;); //3.变量名 String name = f.getName(); System.out.println(name); &#125; &#125;&#125; Annotation相关 12get Annotation(Class&lt;T&gt; annotationClass) getDeclaredAnnotations() 泛型相关 获取父类泛型类型 1Type getGenericSuperclass() 泛型类型 1ParameterizedType 获取实际的泛型类型参数数组 1getActualTypeArguments() 类所在的包 1Package getPackage() 总结： 在实际的操作中，取得类的信息的操作代码，并不会经常开发。 一定要熟悉java.lang.reflect包的作用，反射机制。 如何取得属性、方法、构造器的名称，修饰符等。 调用运行时类的指定结构调用指定方法​ 通过反射，调用类中的方法，通过Method类完成。步骤: 通过Class类的 ==getMethod(String name,Class…parameterTypes)== 方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用 ==Object invoke(Object obj, Object[] args)== 进行调用，并向方法中 传递要设置的obj对象的参数信息。 Object invoke(Object obj, Object … args)，说明： Object 对应原方法的返回值，若原方法无返回值，此时返回null 若原方法若为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args为null 若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ReflectionTest &#123; @Test public void testField() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; //创建运行时类的对象 Person person = clazz.newInstance(); //获取指定属性 Field id = clazz.getField(&quot;id&quot;); id.set(person, 1001); Object o = id.get(person); System.out.println(o); System.out.println(person); Field age = clazz.getDeclaredField(&quot;age&quot;); age.setAccessible(true); age.set(person, 18); Object o1 = age.get(person); System.out.println(o1); System.out.println(person); &#125; @Test public void testMethod() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;Person&gt; clazz = Person.class; // 创建运行时类的对象 Person person = clazz.newInstance(); // 获取指定的某个方法 //getDeclaredMethod(): 参数1：指明获取的方法的名称 参数2：指明获取的方法形参列表 Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); //保证当前方法时可访问的 show.setAccessible(true); //调用invoke()方法：参数1：方法的调用者 参数2：给方法形参赋值的实参 //invoke()的返回值即为对应类中调用的方法的返回值 Object o = show.invoke(person, &quot;中国&quot;); System.out.println(o); System.out.println(&quot;*************调用静态方法***************&quot;); Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); showDesc.invoke(null); &#125;&#125; 调用指定属性​ 在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。 关于setAccessible方法的使用 1234567891011121314151617181920212223242526public class ReflectionTest &#123; @Test public void testField() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; //创建运行时类的对象 Person person = clazz.newInstance(); //获取指定属性 Field id = clazz.getField(&quot;id&quot;); id.set(person, 1001); Object o = id.get(person); System.out.println(o); System.out.println(person); Field age = clazz.getDeclaredField(&quot;age&quot;); age.setAccessible(true); age.set(person, 18); Object o1 = age.get(person); System.out.println(o1); System.out.println(person); &#125;&#125; 反射的应用：动态代理 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上 静态代理：特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package lesson;/** * @author Justry * @Description 静态代理 * @date 2020-12-02 9:20 上午 */interface ClothFactory &#123; void produceCloth();&#125;//代理类class ProxyClothFactory implements ClothFactory &#123; private final ClothFactory factory; // 用被代理的对象进行实例化 public ProxyClothFactory(ClothFactory factory) &#123; this.factory = factory; &#125; @Override public void produceCloth() &#123; System.out.println(&quot;代理工厂做一些准备工作&quot;); factory.produceCloth(); System.out.println(&quot;代理工厂做一些后续的收尾工作&quot;); &#125;&#125;//被代理类class NikeClothFactory implements ClothFactory&#123; @Override public void produceCloth() &#123; System.out.println(&quot;Nike工厂生产一批运动服&quot;); &#125;&#125;public class StaticProxyTest &#123; public static void main(String[] args) &#123; //创建被代理类的对象 NikeClothFactory nike = new NikeClothFactory(); //创建代理类的对象 ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); proxyClothFactory.produceCloth(); &#125;&#125; 动态代理：是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理使用场合： 调试 远程方法调用 动态代理相比于静态代理的优点： 抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。 Java动态代理相关API Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。 供用于创建动态代理类和动态代理对象的静态方法 创建一个动态代理类所对应的Class对象 1static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 直接创建一个动态代理对象 1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h) 动态代理步骤 创建一个实现接口. InvocationHandler. 的类，它必须实现invoke方法，以完成代理的具体操作。 创建被代理的类以及接口 通过Proxy的静态方法 通过 Subject代理调用RealSubject实现类的方法 栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package lesson;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author Justry * @Description 动态代理的举例 * @date 2020-12-02 9:30 上午 */interface Human &#123; void getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human &#123; @Override public void getBelief() &#123; System.out.println(&quot;I believe I can fly!&quot;); &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法 */class ProxyFactory &#123; //调用此方法返回一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; // obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj; // 赋值时，需要使用被代理类的对象进行赋值 public void bind(Object obj) &#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj, args); // 反射 //上述方法的返回值就作为当前类中invoke(）的返回值 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance：代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法 proxyInstance.getBelief(); proxyInstance.eat(&quot;麻辣香锅&quot;); System.out.println(&quot;**************************************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125; 动态代理与AOP(Aspect Orient Programming) 前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制 改进后的说明:代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和 一个特定的方法A耦合了!最理想的效果是:代码块1、2、3既可以执行方法A，又无须在程序 中以硬编码的方式直接调用深色代码的方法 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异: ==AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package lesson;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author Justry * @Description 动态代理的举例 * @date 2020-12-02 9:30 上午 */interface Human &#123; void getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human &#123; @Override public void getBelief() &#123; System.out.println(&quot;I believe I can fly!&quot;); &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;class HumanUtil &#123; public void method1() &#123; System.out.println(&quot;===================通用方法一===================&quot;); &#125; public void method2() &#123; System.out.println(&quot;===================通用方法二===================&quot;); &#125;&#125;/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法 */class ProxyFactory &#123; //调用此方法返回一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; // obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj; // 赋值时，需要使用被代理类的对象进行赋值 public void bind(Object obj) &#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj, args); // 反射 util.method2(); //上述方法的返回值就作为当前类中invoke(）的返回值 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance：代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法 proxyInstance.getBelief(); proxyInstance.eat(&quot;麻辣香锅&quot;); System.out.println(&quot;***********************************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"},{"name":"game","slug":"Java/game","permalink":"https://asteroidcs.github.io/categories/Java/game/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"},{"name":"游戏","slug":"游戏","permalink":"https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"}]}