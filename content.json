{"meta":{"title":"Asteroid","subtitle":"","description":"学而思，思而行","author":"Komorebi","url":"https://asteroidcs.github.io","root":"/"},"pages":[{"title":"about","date":"2020-11-25T10:24:48.000Z","updated":"2020-11-26T04:33:22.397Z","comments":false,"path":"about/index.html","permalink":"https://asteroidcs.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-25T10:14:53.000Z","updated":"2020-12-01T02:09:11.467Z","comments":true,"path":"categories/index.html","permalink":"https://asteroidcs.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-25T11:24:28.000Z","updated":"2020-12-01T02:11:25.713Z","comments":true,"path":"link/index.html","permalink":"https://asteroidcs.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-25T10:21:58.000Z","updated":"2020-12-01T02:10:23.419Z","comments":true,"path":"tags/index.html","permalink":"https://asteroidcs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"第五章 面向对象（中）","date":"2020-12-10T13:04:21.100Z","updated":"2020-12-10T13:26:43.897Z","comments":true,"path":"undefined/0.html","link":"","permalink":"https://asteroidcs.github.io/undefined/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第十四章 网络编程","slug":"第十四章 网络编程","date":"2020-11-30T04:25:18.289Z","updated":"2020-12-10T13:18:44.225Z","comments":true,"path":"undefined/ce7e.html","link":"","permalink":"https://asteroidcs.github.io/undefined/ce7e.html","excerpt":"","text":"网络基础计算机网络​ 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。 网络编程的目的​ 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有两个主要的问题 如何准确地定位网络上一台或多台主机;定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信要素概述如何实现网络中的主机互相通信 通信双方地址 IP 端口号 一定的规则(即:网络通信协议。有两套参考模型) OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广 ==TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。== 数据传输视图 ==通信要素1: IP和端口号==IP 地址:InetAddress 唯一的标识 Internet 上的计算机(通信实体) 本地回环地址(hostAddress):127.0.0.1 主机名(hostName):localhost IP地址分类方式1:IPV4 和 IPV6 PV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1 IPV6:128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984 IP地址分类方式2:==公网地址(万维网使用)==和==私有地址(局域网使用)==。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用 特点:不易记忆 ==端口号==：标识正在计算机上运行的进程(程序) ==不同的进程有不同的端口号== 被规定为一个 16 位的整数 0~65535 端口分类: 公认端口:0~1023。被预先定义的服务通信占用(如:HTTP占用端口 80，FTP占用端口21，Telnet占用端口23) 注册端口:1024~49151。分配给用户进程或应用程序。(如:Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等) 动态/私有端口:49152~65535 ==端口号与IP地址的组合得出一个网络套接字：Socket。== InetAddress类 Internet上的主机有两种方式表示地址: 域名(hostName): www.atguigu.com P 地址(hostAddress): 202.108.35.210 123456789101112public class InternetAddressTest&#123; public static void main(String[] args) &#123; try &#123; InetAddress address = InetAddress.getByName(&quot;www.atguigu.com&quot;); System.out.println(address); // www.atguigu.com/58.215.145.106 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; InetAddress类主要表示IP地址，两个子类:Inet4Address、Inet6Address InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: www.atguigu.com 和 202.108.35.210 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS) 负责将域名转化成IP地址，这样才能和主机建立连接。———==域名解析== InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) InetAddress提供了如下几个常用的方法 public String getHostAddress(): 返回 IP 地址字符串(以文本表现形式) public String getHostName(): 获取此 IP 地址的主机名 public boolean isReachable(int timeout): 测试是否可以达到该地址 ==通信要素2：网络协议== 网络通信协议 ​ 计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代 码结构、传输控制步骤、出错控制等制定标准。 问题:网络协议太复杂 ​ 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩，解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢? 通信协议分层的思想 ​ 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。 TCP/IP协议簇 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol) ==TCP/IP 以其两个主要协议==：==传输控制协议(TCP)==和==网络互联协议(IP)==而得 名，实际上是一组协议，包括多个具有不同功能且互为关联的协议 ==IP(Internet Protocol)协议==是网络层的主要协议，支持网间互连的数据通信 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理链路层==、==IP层==、==传输层==和==应用层==。 TCP 和 UDP TCP协议: 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用==“三次握手”==方式，点对点通信，==是可靠的== TCP协议进行通信的两个应用进程:客户端、服务端。 在连接中可==进行大数据量的传输== 传输完毕，==需释放已建立的连接，效率低== UDP协议: 将数据、源、目的封装成数据包，==不需要建立连接== 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的  可以广播发送 发送数据结束时==无需释放资源，开销小，速度快== Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。 ==网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字== 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。  一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类: 流套接字(stream socket):使用TCP提供可依赖的字节流服务 数据报套接字(datagram socket):使用UDP提供“尽力而为”的数据报服务 TCP网络编程基于Socket的TCP编程 Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模 型如图所示 ==客户端Socket的工作过程包含以下四个基本的步骤:== 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到 Socket 的输入/出流:：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输 按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 (但不能读取自己放入线路的信息)，通过输出流将信息写入线程。 关闭 Socket:：断开客户端到服务器的连接，释放线路 ==服务器程序的工作过程包含以下四个基本的步骤:== 调用 ServerSocket(int port) :创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept():监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。 调用 该Socket类对象的 getOutputStream() 和 getInputStream ():获取输出 流和输入流，开始网络数据的发送和接收。 关闭ServerSocket和Socket对象:客户端访问结束，关闭通信套接字 客户端创建Socket对象 客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是: Socket(String host,int port)throws UnknownHostException,IOException:向服务器(域名是 host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。 Socket(InetAddress address,int port)throws IOException:根据InetAddress对象所表示的 IP地址以及端口号port发起连接。 客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求 服务器建立 ServerSocket 对象 erverSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。 所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象 例题1：客户端发送内容给服务端，服务端将内容打印到控制台上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package lesson1;import org.junit.jupiter.api.Test;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * @author Justry * @Description 实现TCP的网络编程：客户端发送信息给服务器，服务端将数据显示在控制台上 * @date 2020-11-30 1:38 下午 */public class TCPTest1 &#123; //客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; InetAddress localHost = InetAddress.getLocalHost(); socket = new Socket(localHost, 8899); os = socket.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //服务端 @Test public void server() &#123; ServerSocket serverSocket = null; InputStream is = null; ByteArrayOutputStream baos = null; Socket socket = null; try &#123; serverSocket = new ServerSocket(8899); socket = serverSocket.accept(); is = socket.getInputStream(); baos = new ByteArrayOutputStream(); byte[] bytes = new byte[20]; int len; while ((len = is.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); &#125; System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (serverSocket != null) &#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 例题2：客户端发送文件给服务端，服务端将文件保存在本地例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给 客户端。并关闭相应的连接。 练习1：服务端读取图片并发送给客户端，客户端保存图片到本地练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端客户端—服务端 客户端: 自定义 浏览器 服务端: 自定义 Tomcat服务器 UDP网络编程 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，==系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达==。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。 ==UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样==。 常用方法 UDP网络通信 流程 DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送、接收方法 5. 关闭Socket 发送端与接收端是两个独立的运行程序 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package lesson1;import org.junit.jupiter.api.Test;import java.io.IOException;import java.net.*;/** * @author Justry * @Description * @date 2020-11-30 2:46 下午 */public class UDPTest &#123; @Test public void sender() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress localHost = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, localHost, 9090); socket.send(packet); socket.close(); &#125; @Test public void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] bytes = new byte[100]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); socket.receive(packet); System.out.println(new String(packet.getData(), 0, packet.getLength())); socket.close(); &#125;&#125; URL编程URL类 URL(Uniform Resource Locator):统一资源定位符，它表示 Internet 上某一 资源的地址 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate 这个资源 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 URL的基本结构由5部分组成: ==&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表== 例如: http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123 #片段名:即锚点，例如看小说，直接定位到章节 参数列表格式:参数名=参数值&amp;参数名=参数值…. 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象: URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。 一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的 方法来获取这些属性: 针对HTTP协议的URLConnection类 ==URL的方法 openStream():能从网络上读取数据== 若希望输出数据，例如向服务器端的 CGI (公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口)程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。 URLConnection:表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. URL netchinaren = new URL (“http://www.atguigu.com/index.shtml&quot;); URLConnectonn u = netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 ==URI、URL和URN的区别==12URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 ==总结== 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 ==客户端-服务器==是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。==端口号== 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。==套接字==用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。 Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段:主机名(String) 和 IP 地址(int)。 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端-服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。 类 URL 和 URLConnection 提供了最 高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十三章 IO流","slug":"第十三章 IO流","date":"2020-11-28T12:25:50.563Z","updated":"2020-12-10T13:18:49.626Z","comments":true,"path":"undefined/4554.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4554.html","excerpt":"","text":"==重点掌握==：节点流、缓冲流、转换流、对象流File类的使用概念 File类的一个对象，==代表一个文件或一个文件目录==（俗称：文件夹） java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是==Java程序中的一个File对象，可能没有一个真实存在的文件或目录== File对象可以作为参数传递给流的构造器 ==File类不涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流== 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点“ 路径分隔符 路径中的每级目录之间用一个路径分隔符隔开。 ==路径分隔符和系统有关==： ①windows和DOS系统默认使用“\\”来表示 ②UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用，为了解决这个隐患，File类提供了一个常量： ==public static final String separator。根据操作系统，动态的提供分隔符== 内存 常用构造器 ==public File(String pathname)==：以pathname为路径创建对象(绝对路径或相对路径)，==相对路径默认当前路径为系统属性user.dir==。 IDEA中： 如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下； 如果使用main()测试，相对路径即为当前的Project下。 Eclipse中：不管是单元测试方法还是main()测试，相对路径都是当前的Project下。 ==public File(String parent,String child)==：以parent为父路径，child为子路径创建File对象。 ==public File(File parent,String child)==：根据一个父File对象和子文件路径创建File对象。 12345678910111213141516171819// 构造器的使用 @Test public void test1()&#123; // 构造器1： File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;D:\\\\workspace_idea1\\\\JavaSenior&quot;); System.out.println(file1); System.out.println(file2); // 构造器2： File file3 = new File(&quot;D:\\\\workspace_idea1&quot;, &quot;JavaSenior&quot;); System.out.println(file1); // 构造器3： File file4 = new File(file3, &quot;Hello.txt&quot;); System.out.println(file4); &#125; 常用方法 File类的获取功能： public String getAbsolutePath()：获取绝对路径 public String getPath()：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度 public long lastModified() ：获取最后一次的修改时间，毫秒值 1234567891011121314@Test public void test2() &#123; File file1 = new File(&quot;Hello.txt&quot;); File file2 = new File(&quot;\\\\Users\\\\i-mamba\\\\Desktop\\\\IO\\\\hi.txt&quot;); System.out.println(file1.getAbsoluteFile()); // /Users/i-mamba/程序员技能学习/Java/Java基础入门/code/IDEA-workspace/JavaSenior/day08/Hello.txt System.out.println(file1.getPath()); // Hello.txt System.out.println(file1.getName()); // Hello.txt System.out.println(file1.getParent()); // null System.out.println(file1.length()); // 12 System.out.println(file1.lastModified()); // 1606614159235 System.out.println(new Date(file1.lastModified())); // Sun Nov 29 09:42:39 CST 2020 &#125; 下面两方法适用于文件目录： public String[] list()：获取指定目录下的所有文件或者文件目录的==名称==数组 public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File路径数组 File类的重命名功能 public boolean renameTo(File dest)：把文件重命名为指定的文件路径 比如file1.renameTo(file2)，要保证返回true，==需要file1在硬盘中存在且file2在硬盘中不存在==。修改可包括路径和文件内容。 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile()：判断是否是文件 public boolean exists()：判断是否存在 public boolean canRead()：判断是否可读 public boolean canWrite()：判断是否可写 public boolean isHidden()：判断是否隐藏 1234567891011@Test public void test4() &#123; File file = new File(&quot;/Users/i-mamba/程序员技能学习&quot;); System.out.println(file.isDirectory()); // true System.out.println(file.isFile()); // false System.out.println(file.exists()); // true System.out.println(file.canRead()); // true System.out.println(file.canWrite()); // true System.out.println(file.isHidden()); // false &#125; File类的创建功能 public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建——&gt; 创建多层文件目录 ==注意事项==：如果你创建文件或者文件目录没有写盘符路径，那么默认在项目路径下。 File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项： ==Java中的删除不走回收站==； ==要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录== 练习题12345671. 利用File构造器，new 一个文件目录file。 * 在其中创建多个文件和目录 * 编写方法，实现删除file中指定文件的操作2. 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称。3. 遍历指定目录所有文件名称，包括子文件目录中的文件。 * 拓展1：并计算指定目录占用空间的大小 * 拓展2：删除指定文件目录及其下的所有文件 IO流原理及流的分类Java IO原理 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 ==Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行的== java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 输入输出：进入内存即为输入(Input)，出内存即为输出(Output) 流的分类 按操作==数据单位==不同分为：==字节流(8 bit)==，==字符流(16 bit)==。 按数据流的==流向==不同分为：==输入流==，==输出流==。 按流的==角色==的不同分为：==节点流==，==处理流==。 ==(抽象基类)== 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java的IO流共涉及40多个类，实际上非常规则，都是从者4个类派生的，==由这4个类派生出来的子类名称都是以其父类名作为子类名后缀== IO流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 ==抽象基类== InputStream OutputStream Reader Writer ==访问文件== FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter ==缓冲流== BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 节点流和处理流 ==节点流==：直接从数据源或目的地读写数据 ==处理流==：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能 InputStream &amp; Reader ==InputStream和Reader是所有输入流的基类==。 InputStream（典型实现：FileInputStream） int read() int read(byte[] b) int read(byte[] b,int off,int len) Reader（典型实现：FileReader） int read() int read(byte[] b) int read(byte[] b,int off,int len) 程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader InputStream int read()：从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。 int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 Reader int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1。 int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 OutputStream &amp; Writer OutputStream 和 Writer 也非常相似： void write(int b/int c); void write(byte[] b/char[] cbuf); void write(byte[] b/char[] buff, int off, int len); void flush(); void close(); 需要先刷新，再关闭此流 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数 void write(String str); void write(String str, int off, int len); FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。 OutputStream void write(int b)：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b)：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 void write(byte[] b,int off,int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 Writer void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf)：写入字符数组。 void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符。 void write(String str)：写入字符串。 void write(String str,int off,int len)：写入字符串的某一部分。 void flush()：刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源 节点流(或文件流)通用步骤：123456* 实例化File类对象，指明要操作的文件* 提供具体的流* 数据的操作* 关闭资源 // 注意：异常处理 字符流FileReader 步骤： File类的实例化 FileReader流的实例化 读入的操作 资源关闭 说明点： read()的理解：返回读入的一个字符，如果到大文件末尾，返回-1。 异常处理：为了保证资源一定可以执行关闭操作。需要使用try-catch-finally处理。 读入文件一定要存在，否则就会报FileNotFoundException 基本操作 12345678910111213141516171819202122232425262728293031323334353637@Test public void FileReaderTest() &#123; FileReader fileReader = null; try &#123; //1.实例化File类的对象，指明要操作的文件 File file = new File(&quot;hello.txt&quot;); //2.提供具体的流 fileReader = new FileReader(file); //3.数据的读入 //read()：返回读入的一个字符。如果达到文件末尾，返回-1 //方式一：// int data = fileReader.read();// while (data != -1) &#123;// System.out.print((char) data);// //读取下一个字符// data = fileReader.read();// &#125; //方式二：语法上针对于方式一的修改 int data; while ((data = fileReader.read()) != -1) &#123; System.out.print((char) data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流的关闭操作 try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 对read()操作升级：使用read()的重载方法 1234567891011121314151617181920212223242526272829@Test public void FileReaderTest2() &#123; FileReader fileReader = null; try &#123; //1.File类的实例化 File file = new File(&quot;Hello.txt&quot;); //2.FileReader流的实例化 fileReader = new FileReader(file); //3.读入的操作 char[] cbuf = new char[5]; int len; while ((len = fileReader.read(cbuf)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileWriter 步骤： 创建File类的对象：指明读入和写出的文件 创建输入流和输出流的对象 数据的读入和写出操作 关闭流资源 ==说明点== 从内存中写出数据到硬盘的文件里 输出操作，对应的File可以不存在。 * 如果不存在，在输出过程中，会自动创建此文件 * 如果存在： * 使用的流构造器是: FileWriter(file,false) / FileWriter(file)，对原有文件覆盖 * 使用的流构造器是: FileWriter(file,true)，不会对原有文件覆盖，而是在原有文件的基础上 基本操作 12345678910111213141516171819202122232425262728293031323334353637383940@Test public void FileWriterTest1() &#123; FileReader fileReader = null; FileWriter fileWriter = null; try &#123; //1.创建File类的对象：指明读入和写出的文件 File file = new File(&quot;Hello.txt&quot;); File file1 = new File(&quot;Hello2.txt&quot;); //2.创建输入流和输出流的对象 fileReader = new FileReader(file); fileWriter = new FileWriter(file1); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len; // 记录每次读入到cbuf数组中的字符的个数 while ((len = fileReader.read(cbuf)) != -1) &#123; //每次写出len个字符 fileWriter.write(cbuf, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流资源 try &#123; if (fileWriter != null) &#123; fileWriter.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字节流FileInputStream ==注意点：使用字节流处理文本文件，可能出现乱码== 说明： 对于文本文件（.txt，.java，.c，.cpp），使用字符流处理 对于非文本文件，使用字节流处理 基本操作 1234567891011121314151617181920212223242526272829@Test public void fISStreamTest1() &#123; FileInputStream inputStream = null; try &#123; //造文件 File file = new File(&quot;cat.jpeg&quot;); //造流 inputStream = new FileInputStream(file); //读数据 int len; // 记录每次读取的字节的个数 byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(bytes[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 关闭流资源 if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 复制图片 123456789101112131415161718192021222324252627282930313233343536@Test public void fISStreamTest2() &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat2.jpeg&quot;); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通用操作：指定路径下的文件复制操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Test public void copyFile(String srcPath,String destPath) &#123; FileInputStream inputStream = null; FileOutputStream outputStream = null; try &#123; //构建File类对象 File file = new File(srcPath); File file1 = new File(destPath); //创建输入流和输出流的对象 inputStream = new FileInputStream(file); outputStream = new FileOutputStream(file1); //数据的读入和写出操作 int len; byte[] bytes = new byte[1024]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testCopyFile()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;文件路径&quot;; String destPath = &quot;复制路径&quot;; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;整个复制操作花费的时间为：&quot; + (end - start));//13031 //可以复制文本文件 &#125; &#125; 缓冲流 处理流的一种，“套接”在已有的流的基础上 缓冲流涉及到的类 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter ==作用==：提供流的读取、写入的速度 ==原因==：内部提供了一个缓冲区。默认情况下是8kb 说明： 先关闭外层流，再关闭内层流 ==关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略== 非文本文件的复制 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Test public void BfStreamTest1() &#123; BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try &#123; //1.造文件 File file = new File(&quot;cat.jpeg&quot;); File file1 = new File(&quot;cat3.jpeg&quot;); //2.造流 //2.1造节点流 FileInputStream inputStream = new FileInputStream(file); FileOutputStream outputStream = new FileOutputStream(file1); //2.2造处理流 bufferedInputStream = new BufferedInputStream(inputStream); bufferedOutputStream = new BufferedOutputStream(outputStream); //3.复制：数据的读入和写出操作 int len; byte[] bytes = new byte[5]; while ((len = bufferedInputStream.read(bytes)) != -1) &#123; bufferedOutputStream.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流资源 try &#123; if (bufferedOutputStream != null) bufferedOutputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if (bufferedInputStream != null) bufferedInputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 文本文件的复制，略，基本雷同 练习题 图片的加密 1234567891011121314151617181920212223242526272829303132333435363738394041public class PicTest &#123; /** * 图片的加密操作 */ @Test public void testEncrypt()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;cat.jpg&quot;); fos = new FileOutputStream(&quot;cat2.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; //核心 for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 图片的解密 对加密的文件做同样的异或操作 123456789101112131415161718192021222324252627282930313233343536373839/** * 图片的解密操作 */ @Test public void testDecode()&#123; FileInputStream fis = null;//文件类可省略，它会自动包装为文件类 FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;加密后的玛雅.jpg&quot;); fos = new FileOutputStream(&quot;解密后的玛雅.jpg&quot;); byte[] buffer = new byte[20]; int len; while((len = fis.read(buffer)) != -1)&#123; for (int i = 0; i &lt; len; i++) &#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 获取文本上每个字符出现的次数 1//提示：遍历文本每一个字符，字符及出现次数保存在Map中，将Map中数据写入文件。 转换流 转换流提供了在字节流和字符流之间的转换 ==Java API提供了两个转换流==: ==InputStreamReader==：将InputStream转换为Reader ==OutputStreamWriter==；将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来==处理文件乱码==问题。实现==编码==和== 解码==的功能 InputStreamReader ==实现将字节的输入流按指定字符集转换为字符的输入流== 需要和InputStream“套接” 构造器 public InputStreamReader(InputStream in) public InputSreamReader(InputStream in,String charsetName) OutputStreamWriter ==实现将字符的输出流按指定字符集转换为字节的输出流== 需要和OutputStream“套接” 构造器 public OutputStreamWriter(OutputStream out) public OutputSreamWriter(OutputStream out,String charsetName) 字符编码 编码:字符串字节数组 解码:字节数组字符串 转换流的编码应用 可以将字符按指定编码格式存储 可以对文本数据按指定编码格式来解读 指定编码表的动作由构造器完成 标准输入、输出流 ==System.in==和==System.out==分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是==InputStream==，直接以流的形式读取了 System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向:通过System类的setIn()，setOut()方法对默认设备进行改变 练习 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序 1234567891011121314151617181920212223242526272829303132public class OtherStreamTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) &#123; System.out.println(&quot;请输入字符串：&quot;); String data = br.readLine(); if (data.equalsIgnoreCase(&quot;e&quot;) || data.equalsIgnoreCase(&quot;exit&quot;)) &#123; System.out.println(&quot;程序结束！&quot;); break; &#125; String upperCase = data.toUpperCase(); System.out.println(upperCase); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印流 ==实现将基本数据类型的数据格式转化为字符串输出==，指定输入/输出的位置 打印流：==PrintStream==和==PrintWriter== 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 例子 12345678910111213PrintStream ps = null; try &#123;FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true);if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件System.setOut(ps); &#125;for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i);if (i % 50 == 0) &#123; // 每50个数据一行System.out.println(); // 换行 &#125;&#125;&#125; catch (FileNotFoundException e) &#123;e.printStackTrace(); &#125; finally &#123;if (ps != null) &#123; ps.close();&#125; &#125; 数据流 作用：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类:(==用于读取和写出基本数据类型、String类的数据==) ==DataInputStream== 和 ==DataOutputStream== 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream中的方法 boolean readBoolean() char readChar() double readDouble() long readLong() String readUTF() byte readByte() float readFloat() short readShort() int readInt() void readFully(byte[] b) DataOutputStream中的方法 ==将上述的方法的read改为相应的write即可== 练习 将内存中的字符串、基本数据类型变量写出到文件中 1234567891011DataOutputStream dos = null;try &#123; // 创建连接到指定文件的数据输出流对象dos = new DataOutputStream(new FileOutputStream(&quot;destData.dat&quot;)); dos.writeUTF(&quot;我爱北京天安门&quot;); // 写UTF字符串 dos.writeBoolean(false); // 写入布尔值dos.writeLong(1234567890L); // 写入长整数 System.out.println(&quot;写文件成功!&quot;);&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流对象try &#123;if (dos != null) &#123;// 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close();&#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125; 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中 12345678910111213DataInputStream dis = null; try &#123;dis = new DataInputStream(new FileInputStream(&quot;destData.dat&quot;)); String info = dis.readUTF();boolean flag = dis.readBoolean();long time = dis.readLong();System.out.println(info); System.out.println(flag); System.out.println(time);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123;if (dis != null) &#123;try &#123; dis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; &#125;&#125; ==注意==：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ 对象流基础概念 用于==存储==和==读取==基本数据类型数据或对象的处理流。它的强大之处就是==可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来== ==ObjectInputStream==和==OjbectOutputSteam== ==序列化==：用ObjectOutputStream类==保存==基本类型数据或对象的机制 ==反序列化==：用ObjectInputStream类==读取==基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream==不能序列化static和transient==修饰的成员变量 以下面的Person类为例 123456789101112public class Person implements Serializable &#123; public static final long serialVersionUID = 44353533453L; //将变量用static 和 transient修饰 private static String name; private transient int age;略 //此时的反序列化结果我爱北京天安门Person&#123;name=&#x27;null&#x27;, age=0&#125; //显然无法序列化这两个变量 对象的序列化 ==对象序列化机制==允许把内存中的Java对象转换成平台无关的==二进制流==，从 而允许把这种二进制流持久地==保存在磁盘上==，或通过网络将这种二进制流==传输到另一个网络节点==。//==当其它程序获取了这种二进制流，就可以恢复成原来的Java对象== ==序列化的好处==：在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI(Remote Method Invoke – 远程方法调用)过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此==序列化机制是 JavaEE 平台的基础== ==如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的==，==为了让某个类是可序列化的，该类必须实现如下两个接口之一==。 否则，会抛出NotSerializableException异常 $\\color{red}{Serializable}$ Externalizable ==凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量==: $\\color{red}{private static final long serialVersionUID}$; ==serialVersionUID==用来表明类的不同版本间的兼容性。简言之，其目的是==以序列化对象 进行版本控制，有关各版本反序列化时是否兼容==。 ==如果类没有显示定义这个静态常量==，它的值是==Java运行时环境根据类的内部细节自动生成==的。 若类的实例变量做了修改，serialVersionUID 可能发生变化。故==建议， 显式声明== ==Java的序列化机制==是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，==JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较==，如果相同就认为是==一致==的，==可以进行反序列化==，==否则就会出现序列化版本不一致的异 常。(InvalidCastException)== 使用对象流序列化对象序列化实现 ==若某个类实现了 Serializable 接口，该类的对象就是可序列化的:== 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 ==注意写出一次，操作flush()一次== 1234567891011121314151617181920//序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现@Testpublic void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反序列化实现 步骤 创建一个 ObjectInputStream 调用 readObject() 方法读取流中的对象 1234567891011121314151617181920212223//反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现@Testpublic void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 自定义类实现序列化 ==强调==：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是==可序列化的==，否则拥有该类型的 Field 的类也不能序列化 ==以Person类为例== 需要==实现接口==：Serializable 当前类==提供一个全局常量==：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化de 。(默认情况下，基本数据类型可序列化) package lesson; import org.junit.jupiter.api.Test; import java.io.*; /** * @author Justry * @Description 对象流的使用 * @date 2020-11-30 9:35 上午 */ public class ObiectIOStreamTest &#123; //序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现 @Test public void ObjectOStreamTest() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(&quot;我爱北京天安门&quot;); oos.flush(); oos.writeObject(new Person(&quot;如花&quot;, 60)); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现 @Test public void ObctIStreamTest() &#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); System.out.println(str); // 我爱北京天安门 System.out.println(p); // Person&#123;name=&#39;如花&#39;, age=60&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 123456789#### Q1. 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗?&#96;&#96;&#96;java实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。&#x2F;&#x2F;这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活 随机存取文件流RandomAccessFile 类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写，即可以作为输入/出流 实现图片的复制 123456789101112131415161718192021222324@Test public void test1() throws IOException &#123; RandomAccessFile r1 = null; RandomAccessFile r2 = null; try &#123; r1 = new RandomAccessFile(new File(&quot;cat.jpeg&quot;), &quot;r&quot;); r2 = new RandomAccessFile(new File(&quot;cat2.jpeg&quot;), &quot;rw&quot;); byte[] buffer = new byte[1024]; int len; while ((len = r1.read(buffer)) != -1) &#123; r2.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (r2 != null) r2.close(); if (r1 != null) r1.close(); &#125; &#125; RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 ==RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置== long getFilePointer():获取文件记录指针的当前位置 void seek(long pos):将文件记录指针定位到 pos 位置 1234567891011@Testpublic void test2() throws IOException &#123; RandomAccessFile rw = new RandomAccessFile(&quot;Hello.txt&quot;, &quot;rw&quot;); rw.seek(&quot;Hello.txt&quot;.length()); // 将指针指到末尾，追加内容 rw.write(&quot;xyz&quot;.getBytes()); rw.close();&#125; 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式 r；以只读方式打开 rw；打开以便读取和写入 rwd；打开以便读取和写入；同步文件内容的更新 rws；打开以便读取和写入；同步文件内容和元数据的更新 ==如果模式为只读r==。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 ==如果模式为rw读写==，如果文件不 存在则会去创建文件；如果存在则不会创建，写到文件时会对原有内容进行部分覆盖 应用：多线程断点下载 流的基本应用小节 流是用来处理数据的。 处理数据时，一定要先明确数据源，与数据目的地，数据源可以是文件，可以是键盘。 数据目的地可以是文件、显示器或者其他设备。 而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等 NIO.2中Path、 Paths、Files类的使用 NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。==NIO将以更加高效的方式进行文件的读写操作==。 Java API中提供了两套NIO：==一套是针对标准输入输出NIO==，==另一套就是网 络编程NIO== 实战总结： 一个流只能使用一次，不能重复使用，若想使用，必须重新创建流","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十一章 集合","slug":"第十一章 集合","date":"2020-11-27T01:12:32.106Z","updated":"2020-12-10T13:18:33.298Z","comments":true,"path":"undefined/f650.html","link":"","permalink":"https://asteroidcs.github.io/undefined/f650.html","excerpt":"","text":"Java集合框架集合与数组存储数据概述集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 数组存储的弊端 一旦初始化以后，其长度就不可以修改了，这就使得不便于扩展 数组中提供的方法非常有限，对于添加、删除、插入数据等操作不便，且效率不高 获取数组中实际元素的个数的需求，数组中没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。故无法满足对于无序、不可重复的需求 集合存储的优点集合的出现就是为了==解决数组存储数据方面的弊端== 集合框架结构：Java集合可分为==Collection==和==Map==两种体系 Collection接口：单列集合，用来存储一个一个的对象 List接口：==存储有序的、可重复的数据 ——&gt; “动态”数组== Set接口：==存储无序的、不可重复的数据== Collection接口继承树 Map接口：双列数据，==保存具有映射关系的“key-value”对的集合== Map接口继承树 Collection接口方法Collection接口 Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合——&gt; ==继承性的特点：可以调用父类的方法== ==JDK不提供Collection接口的任何直接实现，而是提供更具体的子接口(Set、List)实现== ——&gt; 意味着只能构造其子接口的对象，即ArrayList、LinkedList、Vector/LinkedHashSet、TreeSet等 在==Java5==之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；==从JDK 5.0增加了泛型以后==，Java集合可以记住容器中对象的数据类型。 $\\color{red}{注意：向Collection接口的实现类对象中添加数据obj时，要求obj所在类重写equals()方法}$ Collection接口常用方法 增加数据 add(Object e): 将元素e添加到集合coll中 addAll(Collection coll): 将coll集合中的元素添加到当前的集合中 123456789101112131415161718192021222324252627282930313233343536public class CollectionTest &#123; @Test public void addTest()&#123; //由于JDK不提供Collection接口的任何直接实现，所以这种写法是错误的 ---&gt; 只能用其子接口// Collection collection = new Collection(); //采用子接口实现 Collection collection1 = new ArrayList(); Collection collection2 = new ArrayList(); //add collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(new String(&quot;Tom&quot;)); System.out.println(collection1); // [123, 123, false, Tom] //addAll collection2.add(4324); collection2.add(&quot;555&quot;); collection2.add(&quot;123&quot;); collection2.add(new String(&quot;Jack&quot;)); collection2.add(true); System.out.println(collection2); // [4324, 555, 123, Jack, true] //将集合1加入集合2中 collection2.addAll(collection1); System.out.println(collection2); // [4324, 555, 123, Jack, true, 123, 123, false, Tom] &#125;&#125; ==从代码输出的结果可以看出：这里正好体现了List接口存放有序、可重复数据的特点== 删除数据 clear()：==清空==集合元素 remove(Object obj)：从当前集合中移除指定的obj元素 removeAll(Collection coll)：移除当前集合与另外的coll集合的==交集==中的元素 12345678910111213141516171819202122232425262728public void DeleteTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false, Tom] //remove collection1.remove(&quot;Tom&quot;); System.out.println(collection1); // [123, 123, false] // clear collection1.clear(); System.out.println(collection1); // [] //removeAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(123); collection1.removeAll(collection2); System.out.println(collection1); // [false, Tom] &#125; 查找数据 contains(Object obj)；判断当前集合中是否包含obj containsAll(Collection coll)：判断形参coll中所有元素是否都存在于当前集合中 123456789101112131415161718192021222324252627282930313233public void ContainsTest() &#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); // 其中false为Boolean型，包装类 collection1.add(&quot;Tom&quot;); //Contains boolean contains = collection1.contains(123); System.out.println(contains); // true boolean contains1 = collection1.contains(3543); System.out.println(contains1); // false /** * 此处调用的是String类中的equals，由于String重写了equals方法， * 故比较的是内容，而非地址，所以返回true， * 若自定义的类没有重写object的equals方法，则返回false */ System.out.println(collection1.contains(&quot;Tom&quot;)); // true //ContainsAll Collection collection2 = new ArrayList(); collection2.add(&quot;123&quot;); collection2.add(&quot;Tom&quot;); //集合collection2中的所有元素是否都存在于collection1中 boolean b = collection1.containsAll(collection2); System.out.println(b); // true &#125; 集合的长度 size(): 获取添加的元素个数 其他 isEmpty()：判断当前集合是否为空 retainAll(Collection coll): 交集，将当前集合修改为当前集合与coll的交集 equals(Object obj): 判断当前集合与形参集合的元素是否都相同 hashCode()：返回当前对象的哈希值 toArray()：集合转换成数组 1234567891011121314151617181920212223242526public void toArray()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Object[] array = collection1.toArray(); for (int i = 0; i &lt; array.length; i++) &#123; // 123 123 false Tom System.out.print(array[i] + &quot; &quot;); &#125; // 拓展：数组 ---&gt; 集合 List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] System.out.println(list); List arr = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(arr); // [[I@3ecd23d9] ---&gt; 识别为了一个元素 List arr1 = Arrays.asList(123, 456); System.out.println(arr1); //[123, 456] List arr2 = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(arr2); // [123, 456] &#125; 12// 拓展：数组 ---&gt; 集合 : 调用Arrays类的静态方法asList() List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); // [AA, BB, CC] iterator(): 返回Iterator接口的实例，用于遍历集合元素 $\\color{red}{在判断时会调用obj对象所在类的equals()方法}$ 集合的默认遍历方法（jdk8新特性）—&gt; ==forEach== 1234567891011@Testpublic void test5()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(343); coll.add(343); coll.forEach(System.out::println);//方法引用&#125; terator迭代器接口 ==Iterator仅用于遍历集合==，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合 12345678910111213public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + &quot; &quot;); // 123 123 false Tom &#125;&#125; ==集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前== 1234// 错误写法while (collection1.iterator().hasNext())&#123; // 每次产生一个全新的迭代器对象 System.out.println(collection1.iterator().next()); // 死循环 ---&gt; 不断输出第一个元素&#125; ==使用迭代器遍历集合一般使用的方式以及迭代器执行原理：== remove()方法 内部定义了remove方法，==Iterator可以删除集合的元素==，==区别集合的remove()方法和迭代器的remove()方法== 注意指针的位置，若调用remove()方法时指针位置为空，则报异常IllegalStateException。 1234567891011121314151617public void iteratorTest()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); Iterator iterator = collection1.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); if (&quot;Tom&quot;.equals(o))&#123; iterator.remove(); &#125; &#125; System.out.println(collection1); // [123, 123, false] &#125; foreach循环(增强for循环) Java 5.0 提供了foreach循环迭代访问Collection和数组 无需长度、索引 内部仍然调用了迭代器 ——&gt; ==底层：Iterator== 123for(元素类型 局部变量 : 数组/Collection对象)&#123; //对局部变量操作&#125; 123456789101112public void forEach()&#123; Collection collection1 = new ArrayList(); collection1.add(&quot;123&quot;); collection1.add(123); collection1.add(false); collection1.add(&quot;Tom&quot;); for (Object obj : collection1)&#123; System.out.print(obj + &quot; &quot;); // 123 123 false Tom &#125; &#125; $\\color{red}{注意：增强for循环是将值赋给局部变量，改变的是局部变量，不影响对象中的元素}$ 练习：判断输出结果为何？ 1234567891011public void testExer()&#123; String[] str = new String[5]; for(String myStr : str)&#123; myStr = &quot;atguigu&quot;; System.out.println(myStr); &#125;//5行&quot;atguigu&quot; for(int i = 0;i &lt; str.length;i++)&#123; System.out.println(str[i]); &#125;//5行null &#125; Collection子接口一：List 存储有序的、可重复的数据。==&gt; “动态”数组，替换原有的数组 —&gt; 避免了角标越界 理解：添加数据时，当原数组的存储空间不够时，会重新生成一个容量较大的新数组，将原数组中的元素放进新数组中，并添加新的数据 ———&gt; 占内存 List接口方法：除了从Collection集合继承的方法外，==List 集合里添加了一些根据索引来操作集合元素的方法== 增加数据 void add(int index,Object ele)：在index位置插入ele元素； boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来； 1234567891011121314151617181920212223242526272829@Test public void addTest()&#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //add //数组的第二个位置插入数据 list.add(2, 657); System.out.println(list); // [123, Tom, 657, false, 342] //addAll //将list1插入list的索引2位置 List list1 = new ArrayList(); list1.add(7868); list1.add(&quot;Jack&quot;); list1.add(true); list.addAll(2, list1); System.out.println(list); &#125; 删除数据 Object remove(int index)：移除指定index位置的元素，==并返回此元素== Object remove(Object obj)：移除指定的元素(若有多个，则只移除首位的元素)，==并返回true/false== 123456789101112131415161718192021222324@Test public void removeTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(false); list.add(342); System.out.println(list); // [123, Tom, false, 342] //remove(int index) Object o = list.remove(0); System.out.println(o); // 123 //remove(Object obj) boolean b = list.remove(&quot;Tom&quot;); System.out.println(b); // true boolean b1 = list.remove(&quot;Jack&quot;); System.out.println(b1); // false &#125; 查找 Object get(int index)：获取指定index位置的元素； int indexOf(Object obj)：返回obj在集合中首次出现的位置； int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置； List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合。 1234567891011121314151617181920212223242526272829@Test public void getTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.add(342); list.add(&quot;Tom&quot;); System.out.println(list); // [123, Tom, Jack, 342, Tom] // Object get(int index) Object o = list.get(2); System.out.println(o); // Jack // int indexOf(Object obj) int i = list.indexOf(&quot;Tom&quot;); System.out.println(i); // 1 // int lastIndexOf(Object obj) int i1 = list.lastIndexOf(&quot;Tom&quot;); System.out.println(i1); // 4 // List subList(int fromIndex, int toIndex) List list1 = list.subList(1, 4); System.out.println(list1); // [Tom, Jack, 342] &#125; 修改 Object set(int index, Object ele)：设置指定index位置的元素为ele； 123456789101112@Test public void setTest() &#123; List list = new ArrayList(); list.add(123); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.set(1, 5464); System.out.println(list); // [123, 5464, Jack] &#125; ArrayList​ ==作为List接口的主要实现类；由于是线程不安全的，故效率高；底层使用Object[] elementData存储。== ==源码分析==： 123456789101112//jdk7的情况下：ArrayList list = new ArrayList();//底层创建而来长度为10的Object[]数组elementData；list.add(123);//elementData[0] = new Integer(123);//...list.add(12);//如果此次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)//jdk8中ArrayList的变化：ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组。list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中。//后续的添加扩容操作与jdk7无异 ==小结==：jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8则类似于懒汉式，延迟了数组的创建，节省内存。 【面试题】 1234567891011121314151617@Testpublic void testListRemove()&#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list); // [1]&#125;private static void updateList(List list)&#123; /** * 考点：确定调用哪个remove， 两个remove()方法中index优先权大于Object，删除索引为2的元素 */ list.remove(2);//两个remove()方法中index优先权大于Object，删除索引为2的元素 list.remove(new Integer(2));//删除值为2的元素&#125; LinkedList 对于==频繁的插入和删除==操作，使用此类效率比ArrayList高；底层使用双向链表存储。 1234567891011121314JavaLinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node除了保存数据，还定义了两个变量： prev：记录前一个元素的位置 next：记录下一个元素的位置 新增方法： 123456void addFirst(Object obj)void addLast(Object obj)Object getFirst()Object getLast()Object removeFirst()Object removeLast() Vector 作为List接口的古老实现类(1.0)；线程安全的，效率低；底层使用Object[] elementData存储。 源码分析： jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍。 新增方法： 12345void addElement(Object obj)void insertElementAt(Object obj,int index)void setElementAt(Object obj,int index)void removeElement(Object obj)void removeAllElements() ==面试题==：请问ArrayList/LinkedList/Vector的异同？谈谈你的理解。ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? ArrayList和LinkedList的异同 12二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 1Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。 Collection子接口二：Set Set接口是Collection的子接口，==set接口没有提供额外的方法==。都是Collection中声明过的方法。 ==存储无序的、不可重复的数据== ==&gt; 高中数学中的“集合” Set判断两个对象是否相同不是使用 == 运算符，而是根据equals()方法 HashSet 作为Set接口的主要实现类；==是线程不安全的，可以存储null值==。 以HashSet为例说明：Set存储无序的、不可重复的数据: ==无序性==：==不等于随机性==。存储的数据在底层数组中并非按照数组索引的顺序添加，而是==根据数据的哈希值决定的== ==不可重复性==：保证添加的元素==按照equals()判断==时，不能返回true。即：相同的元素只能添加一个。—&gt; ==因此自定义类需要重写equals( )方法和hashCode( )方法，先比较hash值，再用equals( )比较== ==要求==： 向Set中添加元素所在类，其所在类一定要==重写hashCode()和equals()==； ==重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码== —&gt; 哈希值 ==重写两个方法的小技巧==：对象中用作equals()方法比较的Field，都应该用来计算hashCode值 1234567891011121314151617@Test public void addTest()&#123; HashSet set = new HashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [657, Tom, 123] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [AA, 657, Tom, 123, Jack] ---&gt; 无序性 &#125; ==添加元素的过程：以HashSet为例== 向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值 ==此哈希值接着通过某种算法，计算出在HashSet底层数组中的存放位置（即为：索引位置）== 判断数组此位置上是否已有元素： 没有其他元素==&gt;添加成功。==&gt;情况1 有其他元素b(或以链表形式存在的多个元素)，则比较元素a与b的哈希值: 哈希值不同==&gt;添加成功。==&gt;情况2 哈希值相同，进而调用元素a所在类的equals()方法： 返回false==&gt;添加成功。==&gt;情况3 返回true，则添加失败。 对于添加成功的情况2和3而言：元素a与已经存在指定索性位置上的数据以链表的方式存储。 jdk7：元素a放到数组中，指向原来的元素。（头插） jdk8：原来的元素在数组中指向a元素。（尾插） 总结：七上八下 ==HashSet底层：数组+链表的结构== ==问题==：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 1234选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）31只占用5bits,相乘造成数据溢出的概率较小。31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) LinkedHashSet 作为HashSet的子类；遍历其内部数据时，==可以按照添加顺序遍历==。==对于频繁的遍历操作，LinkedHashSet效率高于HashSet== LinkedHashSet ==根据元素的 hashCode 值来决定元素的存储位置==，但它同时==使用双向链表维护元素的次序==，这使得元素看起来是以插入顺序保存的 123456789101112131415161718@Test public void LinkedHashSet()&#123; LinkedHashSet set = new LinkedHashSet(); set.add(123); set.add(&quot;Tom&quot;); set.add(657); set.add(123); System.out.println(set); // [123, Tom, 657] ---&gt; 不可重复性 set.add(&quot;Jack&quot;); set.add(&quot;AA&quot;); System.out.println(set); // [123, Tom, 657, Jack, AA] ---&gt; 按照添加顺序遍历 &#125; TreeSet ==以按照添加对象的指定属性进行排序== 向TreeSet中添加的数据。要求是相同类的对象 两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）。默认情况下，TreeSet采用自然排序 ==自然排序中==，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals() ==定制排序中==，比较两个对象是否相同的标准为：compare()返回0，不再是equals() 新增方法 Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) ==TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快== User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class User implements Comparable &#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; //自然排序：默认从小到大排序 @Override public int compareTo(Object o) &#123; if (o instanceof User) &#123; User user = (User) o;// return this.name.compareTo(user.name); // 二级排序 int compare = -this.name.compareTo(user.name); // 加了负号，所以按照姓名从大到小排序 if (compare != 0) &#123; return compare; &#125; else &#123; return Integer.compare(this.age, user.age); // 年龄从小到大排列 &#125; &#125; else &#123; throw new RuntimeException(&quot;输入类型不匹配！&quot;); &#125; &#125;&#125; 自然排序实现==（实现Comparable接口）——&gt; 重写compareTo( )方法== 1234567891011121314151617public class UserTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125;User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125; 定制排序实现 构建comparator对象，并重写compare（）方法 将其作为形参传入User类的构造器中 12345678910111213141516171819202122232425262728293031public class UserTest &#123; public static void main(String[] args) &#123; Comparator comparator = new Comparator() &#123; //按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入数据类型不匹配&quot;); &#125; &#125; &#125;; TreeSet set = new TreeSet(comparator); set.add(new User(&quot;Tom&quot;, 12)); set.add(new User(&quot;Jerry&quot;, 32)); set.add(new User(&quot;Jim&quot;, 2)); set.add(new User(&quot;Mike&quot;, 65)); set.add(new User(&quot;Jack&quot;, 33)); set.add(new User(&quot;Jack&quot;, 56)); // 若排序方式中未定义年龄的排序方式，则无法添加成功 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 123456User&#123;name=&#x27;Jim&#x27;, age=2&#125;User&#123;name=&#x27;Tom&#x27;, age=12&#125;User&#123;name=&#x27;Jerry&#x27;, age=32&#125;User&#123;name=&#x27;Jack&#x27;, age=33&#125;User&#123;name=&#x27;Jack&#x27;, age=56&#125;User&#123;name=&#x27;Mike&#x27;, age=65&#125; ==非常非常经典的面试题：== 1234567891011121314151617@Test public void test1() &#123; HashSet set = new HashSet(); Person p1 = new Person(1001, &quot;AA&quot;); Person p2 = new Person(1002, &quot;BB&quot;); set.add(p1); // 根据算法算出hash值h1，确定在set中的存储位置 set.add(p2); // 根据算法算出hash值，确定在set中的存储位置 p1.name = &quot;CC&quot;; // 只改变p1的属性值，但p1已存入set，在set中位置不变 set.remove(p1); // 根据此时的p1(属性改变后)计算出的hash值h2≠h1，所以没能删除set中的p1 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;CC&quot;)); // 根据算法算出hash值h2，此位置无元素，添加成功 System.out.println(set); //[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;] set.add(new Person(1001, &quot;AA&quot;)); // 计算出hash值h1与p1所在位置哈希值相同，调用 // Person中的equals()方法，返回结果为false，此对象以链表的形式存入数组中，添加成功。 System.out.println(set); // [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;] &#125; Map接口 概述： ==双列数据，存储key-value对的数据== ==&gt; 类似于高中的函数，类比其他语言中的==字典== ==Map中的key：无序的，不可重复的==，使用Set存储所有的key。 ==&gt; key所在的类必须要重写equals()和hashCode()==（以HashMap为例） ==Map中的value：无序的，可重复的==，==使用Collection存储所有的value==。 –&gt; ==value所在类要重写equals()== 一个键值对：==key-value构成一个Entry对象==。 ==Map中的Entry：无序的，不可重复的，使用Set存储所有entry==。 ==添加、删除、修改等操作== Object put(Object key,Object value):将制定key-value添加到（或修改）当前map对象中。 void putAll(Map m):将m中所有key-value对存放到当前map中。 Object remove(Object key):移除指定key的key-value对，并返回value。没有相应的key则返回null void clear():清空当前map中的所有数据。与map=null操作不同 ==元素查询的操作== Object get(Object key):获取指定key对应的value。没有相应的key则返回null boolean containsKey(Object key):是否包含指定的key。 boolean containsValue(Object value):是否包含指定的value。 int size():返回map中key-value对的个数。 boolean isEmpty(): 判断当前map是否为空。 boolean equals(Object obj):判断当前map和参数对象是否相等 ==元视图操作的方法== Set keySet():返回所有key构成的Set集合。 Collections values():返回所有value构成的Collection集合。 Set entrySet():返回所有key-value构成的Set集合 ==总结：常用方法== 添加：put(Object key,Object value) 12345678910@Test public void putTest()&#123; HashMap hashMap = new HashMap(); hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; &#125; 删除：remove(Object key) 12345678910111213141516@Test public void removeTest()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); System.out.println(hashMap); // &#123;tt=546, 2=Tom&#125; //remove Object remove = hashMap.remove(2); System.out.println(remove); // Tom System.out.println(hashMap); // &#123;tt=546&#125; &#125; 修改：put(Object key,Object value) 12345678910111213141516171819@Test public void put2Test()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; //修改 hashMap.put(2, &quot;Jim&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Jim, 564=Tom, 6=324&#125; &#125;&#125; 查询：get(Object key) 长度：size() 遍历：keySet() / values() / entrySet() 123456789101112131415161718192021@Test public void test1()&#123; HashMap hashMap = new HashMap(); //put hashMap.put(2, &quot;Tom&quot;); hashMap.put(&quot;tt&quot;, 546); hashMap.put(6, 324); hashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(hashMap); // &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125; Set set = hashMap.keySet(); Collection values = hashMap.values(); Set set1 = hashMap.entrySet(); System.out.println(set); // [tt, 2, 564, 6] System.out.println(values); // [546, Tom, Tom, 324] System.out.println(set1); // [tt=546, 2=Tom, 564=Tom, 6=324] &#125; HashMap ==作为Map的主要实现类==；线程不安全，效率高；==存储null的key和value== ==底层实现原理：(jdk7)== 12345678HashMap map = new HashMap();//在实例化以后，底层创建了一个长度为16的一维数组Entry[] table。//...可能已经执行过多次put...map.put(key1,value1);//首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值通过某种算法计算后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。---情况1/*如果，此位置上的数据不为空，(意味着此位置上一个或多个数据(以链表形式存在))，比较key1与已经存在的一个或多个数据的哈希值： 如果key1与已经存在的数据的哈希值都不相同，key1-value1添加成功。---情况2 如果key1与已经存在的某个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较： equals()返回false，添加成功。---情况3 equals()返回true，使用value1替换value2值。*/ ==补充==： 情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。 默认扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。 ==jdk8相较于jdk7在底层实现方面的不同== new HashMap()：底层没有创建一个长度为16的数组； jdk8底层的数组是Node[]，而非Entry[]； 首次调用put()时，底层创建长度为16的数组； jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 当某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组长度 &gt; 64 时，此索引位置上的的所有数据改为用红黑树存储。 HashMap的存储结构 ==几个常量值== —&gt; ==底层源码== DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75 threshold：扩容的临界值等于容量x填充因子：16*0.75 = 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64 table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数 threshold：扩容的临界值 = 容量*填充因子 loadFactor：填充因子 ==面试题==：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？ ==面试题==：负载因子的值太小，对HashMap有什么影响？ 1234负载因子的大小决定了HashMap的数据密度。负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 LinkedHashMap 概述 作为HashMap的子类 保证在遍历map元素时，可以按照添加的顺序实现遍历。 原理：在原有的HashMap地层结构基础上，添加了一对指针，指向前一个和后一个元素。 对于频繁的遍历操作，此类执行效率高于HashMap。 底层实现原理：(了解) 1234567//源码：static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after;//能记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 12345678910111213141516@Test public void LinkedHashMapTest()&#123; LinkedHashMap linkedHashMap = new LinkedHashMap(); //put linkedHashMap.put(2, &quot;Tom&quot;); linkedHashMap.put(&quot;tt&quot;, 546); linkedHashMap.put(6, 324); linkedHashMap.put(&quot;564&quot;, &quot;Tom&quot;); System.out.println(linkedHashMap); // &#123;2=Tom, tt=546, 6=324, 564=Tom&#125; // 修改 linkedHashMap.put(2, &quot;Jack&quot;); System.out.println(linkedHashMap); // &#123;2=Jack, tt=546, 6=324, 564=Tom&#125; &#125; TreeMap ==保证按照添加的key-value对进行排序，实现遍历。此时考虑key的自然和定制排序==。==底层使用红黑树存储==。 向TreeMap中添加key-value，==要求key必须是由同一个类创建的对象==，因为要按照key进行自然排序、定制排序。 排序类似于之前的TreeSet。 ———&gt; ==同一个treeMap中的key的类型必须一致，意味着只能有仅只有一个类型的数据== ==TreeMap判断两个key相等的标准==：两个key通过compareTo()方法或者compare()方法返回0。———&gt; 因此涉及到了方法的重写 12345678910111213141516171819202122@Test public void TreeMapTest()&#123; TreeMap treeMap = new TreeMap(); treeMap.put(&quot;fsad&quot;, 453); treeMap.put(&quot;2&quot;, &quot;sad&quot;); treeMap.put(&quot;J&quot;, 435); System.out.println(treeMap); // &#123;2=sad, J=435, fsad=453&#125; treeMap.put(&quot;2&quot;, &quot;happy&quot;); System.out.println(treeMap); // &#123;2=happy, J=435, fsad=453&#125; //key的类型不一致，故而抛出异常 /** * java.lang.ClassCastException: class java.lang. * String cannot be cast to class java.lang.Integer (java.lang.String * and java.lang.Integer are in module java.base of loader &#x27;bootstrap&#x27;) */ Object put = treeMap.put(3, 342); System.out.println(put); &#125; Hashtable 作为Map古老的实现类(jdk1.0)；线程安全的，效率低；不能存储null的key和value。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序。 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Properties Properties 类是 Hashtable 的子类，常用来处理配置文件。key和value都是Sting类型。 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。 ==Collections工具类==概述 Collections 是一个操作 Set、List 和 Map 等集合的工具类。 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 ==常用方法== ==排序操作：(均为非static方法)== reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 ==查找、替换== Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package chapter_11;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @author Justry * @Description * @date 2020-11-28 11:52 上午 */public class CollectionsTest &#123; @Test public void Test1()&#123; ArrayList arrayList = new ArrayList(); arrayList.add(&quot;Tom&quot;); arrayList.add(546); arrayList.add(324); arrayList.add(&quot;Jack&quot;); System.out.println(arrayList); // [Tom, 546, 324, Jack] // reverse Collections.reverse(arrayList); System.out.println(arrayList); // [Jack, 324, 546, Tom] // swap Collections.swap(arrayList, 0, 2); System.out.println(arrayList); // [546, 324, Jack, Tom] //copy List&lt;Object&gt; arrayList1 = Arrays.asList(new Object[arrayList.size()]); System.out.println(arrayList1); // [null, null, null, null] Collections.copy(arrayList1, arrayList); System.out.println(arrayList1); // [546, 324, Jack, Tom] &#125;&#125; ==同步控制==： Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。 12// synchronizedXxx() List list = Collections.synchronizedList(arrayList); // 返回的list为线程安全的 补充：Enumeration Enumeration 接口是 Iterator 迭代器的 “古老版本”。 hasMoreElements() nextElement() 12345Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;);while(stringEnum.hasMoreElements())&#123; Object obj = stringEnum.nextElement(); System.out.println(obj);&#125; ==面试题==：Collection 和 Collections的区别？","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十二章 泛型","slug":"第十二章 泛型","date":"2020-11-26T14:23:19.245Z","updated":"2020-12-10T13:19:07.252Z","comments":true,"path":"undefined/95b4.html","link":"","permalink":"https://asteroidcs.github.io/undefined/95b4.html","excerpt":"","text":"范型的理解为什么要有泛型? 解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。 什么是范型？ 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 泛型的引入背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。 在集合中使用泛型​ ==使用范型的时候，这个范型指的是基本数据类型，即&lt;&gt;中不能放int、double、float等，应该放它们的包装类== 使用 使用范型之前的情况 12345678910111213141516@Test public void test1() &#123; ArrayList list = new ArrayList();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //问题一：；类型不安全// list.add(&quot;Tom&quot;); for (Object score : list) &#123; //问题二：强转时，可能会出现类型异常ClassCastException int stuScore = (Integer) score; System.out.println(stuScore); &#125; &#125; 使用范型的情况：以ArrayList为例 1234567891011121314151617181920212223@Test public void test2() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//存放学生成绩 list.add(78); list.add(89); list.add(90); list.add(86); //编译时，就会进行类型检查，保证数据安全// list.add(&quot;Tom&quot;); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;// System.out.println(stuScore);// &#125; //方式二：Iterator Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; 使用泛型的情况：以HashMap为例 12345678910111213141516171819202122@Test public void test3() &#123;// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk新特性：类型推断 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;, 87); map.put(&quot;Jerry&quot;, 90); map.put(&quot;Jack&quot;, 66);// map.put(123,&quot;ABC&quot;); //泛型嵌套 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;--&gt;&quot; + value); &#125; &#125;： ==总结== 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型 比如：add(E e) —&gt;实例化以后：add(Integer e) ==注意点==：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型 自定义泛型类、泛型接口、泛型方法 范型的声明 12interface List&lt;T&gt; 和 class GenTest&lt;K,V&gt;其中，T，K，V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写 范型的实例化 12345//一定要在类名后面指定类型参数的值（类型）。如List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator();//T只能是累，不能用基本数据类型填充。但可以使用包装类填充//把一个集合中的内容限制为一个制定的数据类型，这就是generics背后的核心思想 泛型类 使用 12345678910111213141516171819202122232425public class Order&lt;T&gt; &#123; String OrderName; int orderId; //类的内部结构就可以使用类的范型 T orderT; //这里的T目前不确定什么类型，实例化的时候才会确定 public Order()&#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; OrderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125;&#125; 123456789101112@Test public void test4() &#123; //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;abc&quot;); //建议：实例化时指明类的泛型 Order&lt;String&gt; stringOrder = new Order&lt;String&gt;(&quot;orderAA&quot;, 1001, &quot;order:AA&quot;); stringOrder.setOrderT(&quot;AA:hello&quot;); &#125; ==细节== 范型类可能有多个参数，此时应该将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 范型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass(){} 实例话后，操作原来范型位置的结构必须与指定的范型类型一致 范型不同的引用不能相互赋值 尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中 范型如果不指定，将被擦除，范型对应的类型均按照Object处理，但不等价于Object。经验：范型要使用一路都用。要不用，一路都不要用 如果范型结构是一个接口或抽象类，则不创建范型类的对象 Jdk1.7，范型的简化操作：ArrayList flist = new ArrayList&lt;&gt;() 范型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的范型，在本类或本接口中即代表某种类型，可以作为静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的范型 异常类不能是范型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capcity]； 参考：ArrayList源码中声明：Object[] elementData，而非范型参数类型数组 父类有范型，子类可以选择保留泛型也可以选择指定泛型类型 子类不保留父类的泛型：按需实现 自类保留父类的泛型：泛型子类 ==总结==： 类的内部结构就可以使用类的范型 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 泛型方法 方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型，与类的泛型类没有任何关系 泛型方法的格式 1[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常 泛型方法声明泛型时也可以指定上限 泛型在继承上的体现 泛型在继承方面的体现* * 虽然类A是类B的父类，但是G 和*G二者不具备子父类关系，二者是并列关系。 * 补充：类A是类B的父类，A 是 B 的父类 通配符 使用类型==通配符:?== 比如:List ，Map List&lt;?&gt;是List、List等各种泛型List的父类 读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object 对于List&lt;?&gt;不能向其内部添加数据——&gt;因为我们不知道c的元素类型，我们不能向其中添加对象 唯一的例外是null，它是所有类型的成员 将任意元素加入到其中不是类型安全的 12Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); // 编译时错误 可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。 注意点 不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用 不能用在泛型类的声明上 不能用在创建对象上，右边属于创建集合对象 有限制条件的通配符 通配符指定上限：上限extends:使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 12? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 通配符指定下限：下限super:使用时指定的类型不能小于操作的类，即&gt;= 12? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 举例 12345678&lt;? extends Number&gt;//只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt;//只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt;//只允许泛型为实现Comparable接口的实现类的引用调用","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"贪吃蛇","slug":"贪吃蛇","date":"2020-08-11T16:00:00.000Z","updated":"2020-12-10T13:24:03.651Z","comments":true,"path":"undefined/43fa.html","link":"","permalink":"https://asteroidcs.github.io/undefined/43fa.html","excerpt":"","text":"Java：贪吃蛇游戏笔记分析 创建一个窗体，用于游戏界面显示 ——&gt; 继承Java中的JFrame窗体类，设置自定义的参数 创建游戏棋盘，用于Snake移动 ——&gt; JPanel类的实例化，并且重写其中的 paint() 方法 采用链表的方式创建蛇身，移动以增删节点表示，头插法增加节点，方向采用头节点的横纵坐标加1添加节点 方向的改变用KeyListener来实现，每移动一次都需要重新绘制棋盘 蛇的运动采用timer调用timer task来反复执行蛇的移动 蛇撞墙：蛇头的横纵坐标超过了窗体的边界 蛇追尾：蛇头的坐标与其身体的任意节点坐标相等 创建窗体 创建一个MainFrame类继承JFrame，表示主窗口 定义窗体的空参构造器，初始化窗体参数 初始化窗体参数的方法 12345678public class MainFrame extends JFrame &#123; //定义窗体的空参构造器，初始化窗体参数 public MainFrame() throws HeadlessException &#123; //初始化窗体参数的方法 initFrame(); &#125;&#125; MainFrame类中写一个initFrame方法，初始化窗体参数： 窗体标题：setTitle() 窗体尺寸：setSize() 窗体固定显示位置：setLocation() 窗体大小能否改变：setResizable() 窗体关闭按钮的作用：setDefaultCloseOperation() 123456789101112private void initFrame() &#123; //窗体标题 setTitle(&quot;贪吃蛇&quot;); //窗体尺寸 setSize(610, 640); //固定窗体显示位置 setLocation(600, 200); //设置窗体大小不能改变 setResizable(false); //设置窗体关闭按钮的作用（退出程序） setDefaultCloseOperation(EXIT_ON_CLOSE); &#125; 在MainFrame中添加一个main方法，创建窗体并运行，就可以看到窗口了 窗体类实例化 显示窗体 123456public static void main(String[] args) &#123; //窗体类实例化 MainFrame mainFrame = new MainFrame(); //显示窗体 mainFrame.setVisible(true); &#125; 创建游戏棋盘 在JFrame类中写一个initGamePanel方法，初始化游戏棋盘 JPanel类实例化，并重写其中的paint方法 ——&gt; paint是用来绘制面板中的内容—棋盘格 设置画笔的颜色：setColor（） 绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（） 绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（） 将棋盘添加到窗体中：add( ) 123456789101112131415161718192021222324private void initGamePanel() &#123; //JPanel实例化，并重写其中的paint方法 JPanel jPanel = new JPanel() &#123; //paint是用来绘制面板中的内容 @Override public void paint(Graphics g) &#123; //g 相当于一个画笔，用于绘制 //设置画笔的颜色 g.setColor(Color.BLACK); //绘制棋盘 //绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标） for (int i = 0; i &lt;= 40; i++) &#123; g.drawLine(0, i * 15, 600, i * 15); &#125; //绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标） for (int j = 0; j &lt;= 40; j++) &#123; g.drawLine(j * 15, 0, j * 15, 600); &#125; &#125; &#125;; //将棋盘添加到窗体中 add(jPanel); &#125; 创建蛇的节点：用于构建蛇与食物 创建节点类： 在棋盘上以横纵坐标创建一个节点 随机生成节点位置：用于随机生成食物 random()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Node &#123; private int x; // 横坐标 private int y; // 纵坐标 // 空参构造器 public Node() &#123; &#125; // 带参构造器 public Node(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; //随机生成位置：用于随机生成食物 public void random() &#123; //创建Random对象 Random random = new Random(); //随机生成横坐标 this.x = random.nextInt(40); //随机生成纵坐标 this.y = random.nextInt(40); &#125;&#125; 创建蛇身：采用链表的方式构建蛇 多个节点构成蛇身 1234567891011121314151617181920212223242526public class Snake &#123; //蛇的身体 private LinkedList&lt;Node&gt; snakeBody; public Snake() &#123; //初始化蛇身 initSnake(); &#125; //初始化蛇身 private void initSnake() &#123; //创建集合 snakeBody = new LinkedList&lt;&gt;(); //创建节点，添加到集合中 snakeBody.add(new Node(16, 20)); snakeBody.add(new Node(17, 20)); snakeBody.add(new Node(18, 20)); snakeBody.add(new Node(19, 20)); snakeBody.add(new Node(20, 20)); &#125; public LinkedList&lt;Node&gt; getSnakeBody() &#123; return snakeBody; &#125;&#125; 把🐍绘制到棋盘上 在MainFrame类中实现Snake类对象化 123456private Snake snake; //蛇//初始化蛇 private void initSnake() &#123; snake = new Snake(); &#125; 在MainFrame类中的initGamePanel方法中写入绘制蛇身的代码 绘制蛇身：fillRect（）——&gt; 绘制节点的方法 12345//绘制蛇LinkedList&lt;Node&gt; body = snake.getSnakeBody();for (Node node : body) &#123; g.fillRect(node.getX() * 15, node.getY() * 15, 15, 15);&#125; 让蛇移动 定义枚举类Direction，存放蛇移动的方向 123public enum Direction &#123; UP, DOWN, LEFT, RIGHT&#125; 在Snake类中定义direction属性，用于控制蛇的运动方向，默认向左 12//蛇的运动方向：默认向左 private Direction direction = Direction.LEFT; 在Snake类中写一个move（）方法，控制蛇移动 蛇会沿着蛇头的方向移动 控制蛇移动：蛇头添加节点，蛇尾删除节点 1234567891011121314151617181920212223242526//蛇会沿着蛇头的方向移动 //控制蛇移动：蛇头添加节点，蛇尾删除节点 public void move() &#123; ////获取蛇头 Node head = snakeBody.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 snakeBody.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 snakeBody.removeLast(); &#125; 采用定时器，在指定时间内调用蛇移动 每次移动后都需要重新绘制棋盘 123456789101112131415161718192021222324252627282930313233public class MainFrame extends JFrame &#123; ... private Timer timer; //定时器，在指定时间内调用蛇移动的方法 public MainFrame() throws HeadlessException &#123; ... //初始化定时器 initTimer(); &#125; private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; //蛇移动 snake.move(); //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; &#125; 添加键盘监听 设置键盘监听，让蛇随着上下左右移动，addKeyListener（） 蛇的运动方向不能与当前方向相反 每次按下方向键都会改变蛇的运动方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainFrame extends JFrame &#123; ... public MainFrame() throws HeadlessException &#123; ... //设置键盘监听，让蛇随着上下左右移动 setKeyListener(); &#125; private void setKeyListener() &#123; addKeyListener(new KeyAdapter() &#123; //当键盘按下时会自动调用此方法 @Override public void keyPressed(KeyEvent e) &#123; //键盘中每一个键都有一个编号 switch (e.getKeyCode()) &#123; case KeyEvent.VK_UP: // 上键 //修改蛇的运动方向不能与当前方向相反 if (snake.getDirection() != Direction.DOWN) &#123; //修改蛇的运动方向 snake.setDirection(Direction.UP); &#125; break; case KeyEvent.VK_DOWN: // 下键 if (snake.getDirection() != Direction.UP) &#123; snake.setDirection(Direction.DOWN); &#125; break; case KeyEvent.VK_LEFT: //左键 if (snake.getDirection() != Direction.RIGHT) &#123; snake.setDirection(Direction.LEFT); &#125; break; case KeyEvent.VK_RIGHT: // 右键 if (snake.getDirection() != Direction.LEFT) &#123; snake.setDirection(Direction.RIGHT); &#125; break; &#125;a &#125; &#125;); &#125;&#125; 添加边界处理 当蛇移动到边界处就游戏结束，把标记改为false 123456public class Snake &#123; ... //定义一个标记true表示蛇还活着，可以运动 private boolean isLiving = true;&#125; 判断蛇是否撞墙：头节点的坐标是否越界 12345//判断蛇是否撞墙head = body.getFirst();if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false;&#125; 判断蛇是否碰到自己的身体：头节点坐标与任意身体节点的坐标一致 123456for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125;&#125; 优化move( )代码 1234567891011121314151617181920212223242526272829303132333435363738394041public void move() &#123; if (isLiving) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 body.removeLast(); //判断蛇是否撞墙 head = body.getFirst(); if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false; &#125; //判断蛇是否碰到自己的身体 for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125; &#125; &#125; &#125; 把食物绘制到棋盘上 此处的食物就是节点 12345678910111213141516171819202122public class MainFrame extends JFrame &#123; ... private Node food; //食物 public MainFrame() throws HeadlessException &#123; ... //初始化食物 initFood(); &#125; private void initFood() &#123; food = new Node(); food.random(); // food随机出现 &#125; private void initGamePanel() &#123; ... //绘制食物 g.fillRect(food.getX() * 15, food.getY() * 15, 15, 15); &#125;&#125; 吃食物 吃食物：沿着蛇头的移动方向添加节点 1234567891011121314151617181920212223//吃食物：沿着蛇头的移动方向添加节点 public void eat(Node food) &#123; //获取蛇头 Node head = snakeBody.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 snakeBody.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 snakeBody.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 snakeBody.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; &#125; 吃食物：判断蛇头是否和食物重合，即头节点坐标与食物坐标一致 12345678910111213141516171819202122232425private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; snake.move(); //吃食物：判断蛇头是否和食物重合 Node head = snake.getSnakeBody().getFirst(); if (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123; snake.eat(food); food.random(); &#125; //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; 完整代码MainFrame类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package Snake;import javax.swing.*;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.util.LinkedList;import java.util.Timer;import java.util.TimerTask;/** * @author Justry * @Description 窗体设置 * @date 2020-12-07 7:31 下午 *///java中有准备好的窗体类，继承即可public class MainFrame extends JFrame &#123; private Snake snake; //蛇 private JPanel jPanel; //游戏棋盘 private Timer timer; //定时器，在指定时间内调用蛇移动的方法 private Node food; //食物 //构造器 public MainFrame() throws HeadlessException &#123; //初始化窗体参数 this.initFrame(); //初始化游戏棋盘 this.initGamePanel(); //初始化蛇 this.initSnake(); //初始化食物 initFood(); //初始化定时器 initTimer(); //设置键盘监听，让蛇随着上下左右移动 setKeyListener(); &#125; public static void main(String[] args) &#123; //创建窗体对象，并显示 MainFrame mainFrame = new MainFrame(); mainFrame.setVisible(true); &#125; private void initFood() &#123; food = new Node(); food.random(); &#125; private void setKeyListener() &#123; addKeyListener(new KeyAdapter() &#123; //当键盘按下时会自动调用此方法 @Override public void keyPressed(KeyEvent e) &#123; //键盘中每一个键都有一个编号 switch (e.getKeyCode()) &#123; case KeyEvent.VK_UP: // 上键 //修改蛇的运动方向不能与当前方向相反 if (snake.getDirection() != Direction.DOWN) &#123; //修改蛇的运动方向 snake.setDirection(Direction.UP); &#125; break; case KeyEvent.VK_DOWN: // 下键 if (snake.getDirection() != Direction.UP) &#123; snake.setDirection(Direction.DOWN); &#125; break; case KeyEvent.VK_LEFT: //左键 if (snake.getDirection() != Direction.RIGHT) &#123; snake.setDirection(Direction.LEFT); &#125; break; case KeyEvent.VK_RIGHT: // 右键 if (snake.getDirection() != Direction.LEFT) &#123; snake.setDirection(Direction.RIGHT); &#125; break; &#125; &#125; &#125;); &#125; private void initTimer() &#123; //创建定时器对象 timer = new Timer(); //初始化定时任务 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; snake.move(); //吃食物：判断蛇头是否和食物重合 Node head = snake.getBody().getFirst(); if (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123; snake.eat(food); food.random(); &#125; //重新绘制棋盘 jPanel.repaint(); &#125; &#125;; //每100毫秒，执行一次定时任务 timer.scheduleAtFixedRate(timerTask, 0, 100); &#125; //初始化蛇 private void initSnake() &#123; snake = new Snake(); &#125; //初始化游戏棋盘 private void initGamePanel() &#123; //匿名内部类 jPanel = new JPanel() &#123; @Override public void paint(Graphics g) &#123; //清空棋盘 g.clearRect(0, 0, 600, 600); //Graphics g 相当于一个画笔，用于绘制 //绘制横线 for (int i = 0; i &lt;= 40; i++) &#123; g.drawLine(0, i * 15, 600, i * 15); &#125; //绘制竖线 for (int j = 0; j &lt;= 40; j++) &#123; g.drawLine(j * 15, 0, j * 15, 600); &#125; //绘制蛇 LinkedList&lt;Node&gt; body = snake.getBody(); for (Node node : body) &#123; g.fillRect(node.getX() * 15, node.getY() * 15, 15, 15); &#125; //绘制食物 g.fillRect(food.getX() * 15, food.getY() * 15, 15, 15); &#125; &#125;; //把棋盘添加到窗体中 this.add(jPanel); &#125; //初始化窗体参数 private void initFrame() &#123; //设置窗体标题 this.setTitle(&quot;贪吃蛇&quot;); //设置窗体宽高 this.setSize(600, 615); //设置窗体位置 this.setLocation(600, 200); //设置关闭按钮的作用（退出程序） this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置窗体大小不可变 this.setResizable(false); &#125;&#125; Node类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package Snake;import java.util.Random;/** * @author Justry * @Description 节点类：每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置 * @date 2020-12-07 8:14 下午 */public class Node &#123; private int x; private int y; public Node() &#123; &#125; public Node(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; //随机生成位置 public void random() &#123; //创建Random对象 Random random = new Random(); //随机生成横坐标 this.x = random.nextInt(40); //随机生成纵坐标 this.y = random.nextInt(40); &#125;&#125; Snake类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package Snake;import java.util.LinkedList;/** * @author Justry * @Description 每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置，采用链表的方式构建蛇 * @date 2020-12-07 8:25 下午 */public class Snake &#123; //蛇的身体 private LinkedList&lt;Node&gt; body; //蛇的运动方向：默认向左 private Direction direction = Direction.LEFT; //蛇是否活着 private boolean isLiving = true; //构造方法，在创建Snake对象时执行 public Snake() &#123; //初始化蛇身 initSnake(); &#125; //初始化蛇身 private void initSnake() &#123; //创建集合 body = new LinkedList&lt;&gt;(); //创建节点，添加到集合中 body.add(new Node(16, 20)); body.add(new Node(17, 20)); body.add(new Node(18, 20)); body.add(new Node(19, 20)); body.add(new Node(20, 20)); &#125; public LinkedList&lt;Node&gt; getBody() &#123; return body; &#125; //蛇会沿着蛇头的方向移动 //控制蛇移动：蛇头添加节点，蛇尾删除节点 public void move() &#123; if (isLiving) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; //删除最后的节点 body.removeLast(); //判断蛇是否撞墙 head = body.getFirst(); if (head.getX() &lt; 0 || head.getY() &lt; 0 || head.getX() &gt;= 40 || head.getY() &gt;= 40) &#123; isLiving = false; &#125; //判断蛇是否碰到自己的身体 for (int i = 1; i &lt; body.size(); i++) &#123; Node node = body.get(i); if (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123; isLiving = false; &#125; &#125; &#125; &#125; public Direction getDirection() &#123; return direction; &#125; public void setDirection(Direction direction) &#123; this.direction = direction; &#125; //吃食物：沿着蛇头的移动方向添加节点 public void eat(Node food) &#123; //获取蛇头 Node head = body.getFirst(); switch (direction) &#123; case UP: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() - 1)); break; case DOWN: //在蛇头下边添加一个节点 body.addFirst(new Node(head.getX(), head.getY() + 1)); break; case LEFT: //在蛇头左边添加一个节点 body.addFirst(new Node(head.getX() - 1, head.getY())); break; case RIGHT: //在蛇头上边添加一个节点 body.addFirst(new Node(head.getX() + 1, head.getY())); break; &#125; &#125;&#125; Direction类12345678910package Snake;/** * @author Justry * @Description 枚举 * @date 2020-12-07 8:53 下午 */public enum Direction &#123; UP, DOWN, LEFT, RIGHT&#125; 游戏界面","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"game","slug":"Java/game","permalink":"https://asteroidcs.github.io/categories/Java/game/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"},{"name":"游戏","slug":"游戏","permalink":"https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"第一章 Java语言概述","slug":"第一章 Java语言概述","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:17:28.105Z","comments":true,"path":"undefined/e28.html","link":"","permalink":"https://asteroidcs.github.io/undefined/e28.html","excerpt":"","text":"基础知识图解 软件开发介绍基础常识 软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件 系统软件：Windows，Mac os，linux，unix，android，iOS… 应用软件：word，ppt，画图板… 人机交互方式：图形化界面 vs 命令行方式 应用程序 = 算法 ➕ 数据结构 常用的DOS指令 dir：列出当前目录下的文件以及文件夹 md：创建目录 rd；删除目录 cd：进入目录 cd..：返回到上一级目录 cd\\：退回到根目录 del：删除文件 exit：推出dos命令行 ech javase&gt;：创建文件，如：ech javase&gt;1.doc，ech javase &gt; 1.jpg 常用快捷键 ⬅️ ➡️：移动光标 ⬆️ ⬇️：调阅历史操作命令 Delete 和 Backspace：删除字符 计算机语言的发展迭代史 第一代：机器语言：指令以二进制代码形式存在 第二代：汇编语言：使用助记符表示一条机器指令 第三代：高级语言： 面向过程：C、Pascal、Fortran 面向对象：Java、JS、Python、Scala… Java语言应用的领域 Java Web开发：后台开发 大数据开发： Android应用程序开发：客户端开发 Java语言特点 面向对象性： 两个要素：类、对象 三个特征：封装、继承、多态 健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏 跨平台型：write once，run anywhere：一次编译，到处运行 原理：只需要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM JAVA Virtual Machine）即可。由JVM来负责Java程序在该系统中的运行。 Java核心机制Java虚拟机 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器 对于不同的平台，由不同的虚拟机 只有某平台提供了对应的java虚拟机，java程序才可在此平台运行 java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” 垃圾回收 不再使用的内存空间应回收——垃圾回收 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预 Java程序==还会出现内存泄漏和内存溢出问题== Java语言的环境搭建什么是JDK，JRE JDK(Java Development Kit Java开发工具包) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了 JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等 RE(Java Runtime Environment Java运行环境) 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等， 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 Java语言的环境搭建:JDK、JRE、JVM关系 开发体验— HelloWorld 注释(Comment)Java中的注释类型 //单行注释 /* 多行注释 */ /** 文档注释（Java特有） **/ 单行和多行注释的作用 对所写程序进行解释说明，增强可读性，方便自己和别人。 调试所写代码（注释掉不需要运行部分）。 特点：单行和多行注释掉的内容不参与编译，编译以后生成的.class文件中不包含注释掉的信息。 文档注释的使用 注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。 操作方式 &gt;javadoc -d [生成文件名] -author -version [解析文件名.java]（-author和-version分别为注释当中@author和@version后面的内容） 注意：多行注释不能嵌套使用 第1个Java代码12345public class Hello&#123; public static void main(String[] args)&#123;//arguments参数 System.out.println(&quot;Hello World !&quot;); &#125; &#125; 对第一个Java程序总结 java程序的编写-编译-运行的过程 编写：我们将编写的java代码保存在以“.java”结尾的源文件中 编译：使用javac.exe来编译我们的java源文件。格式：javac 源文件名.java 运行：使用java.exe解释运行我们的字节码文件（.class)。格式：java 类名 在一个java源文件中可以声明多个类（class），但是只能有一个类声明为public的，而且要求声明为public的类的类名必须与源文件名必须相同。 程序的入口是main()方法，格式是固定的。可以写成：public static void main(String[] args)或public static void main(String[] a)或public static void main(String a[]) 输出语句 System.out.println()：输出后换行，无内容则只换行 System.out.print()：输出后不换行 每一个执行语句都以分号结尾，每个执行语句只要以分号隔开即使不换行也不影响执行 编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。 知识点： java语言的特点是什么？ 123面向对象性：两个基本概念：类、对象；三大特性：封装、继承、多态健壮性：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” System.out.println()和System.out.print()有什么区别？ 1前者输出内容后换行，后者输出后不换行。 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 1答：可以。但最多只有一个类名声明为public，与文件名相同。 JDK,JRE和JVM的关系是什么？以及JDK、JRE包含的主要结构有哪些？ 123关系：JDK包含JRE，JRE包含JVMJDK = JRE + Java开发工具（javac.exe、java.exe、javadoc.exe）JRD = JVM + Java核心类库","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第三章 数组","slug":"第三章 数组","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:19:12.677Z","comments":true,"path":"undefined/4fb4.html","link":"","permalink":"https://asteroidcs.github.io/undefined/4fb4.html","excerpt":"","text":"数组的概述 数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。 数组的常见概念 数组名 标（或索引） 元素 数组的长度：元素的个数 特点 数组是有序排列的； 数组属于引用数据类型，但是数组的元素既可以是基本数据类型，也可以是引用数据类型； 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址； 数组的长度一旦确定，就不能修改； 可以通过下标（或索引）的方式调用指定位置的元素，速度很快。 数组的分类 按照维数：一维数组、二维数组…… 按照数组元素类型分类：基本数据类型元素的素组、引用数据类型元素的数组。 数据结构 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多 数据的存储结构： 线性表：顺序表（比如：数组）、链表、栈、队列 树形结构：二叉树 图形结构： 算法 排序算法 搜（检索）索算法 一维数组的使用一维数组的声明和初始化 声明：int[] ins; 静态初始化：数组的初始化和数组的赋值操作同时进行。 int ids = new int[]&#123;1001,1002,1003,1004&#125;; 动态初始化：数组的初始化和数组的赋值操作分开进行 String[] names = new String[5]; 错误写法 int[] arr1 = new int[]; int[5] arr2 = new int[5]; int [] arr3 = new int[3]&#123;1,2,3&#125;; 总结：数组一旦初始化完成，其长度就确定了。 数组的基本操作 如何调用数组指定函数指定位置的函数 通过索引（角标）的方式调用，索引（角标）从0开始，直到数组的长度-1结束 如何获取数组的长度 属性：length 使用：names.length 遍历数组 for(int i = 0; i &lt; names.length; i++)&#123;&#125; 数组元素的默认初始化值 数组的内存解析 栈（stack）：存放局部变量 堆（heap)：存放new出来的结构（对象数组） 方法区：常量池、静态域 内存的简化结构 解析 栈中的所有地址为Java虚拟机计算出来的哈希地址，并非真正的内存地址 多维数组的使用二维数组 理解：对于二维数组的理解，可以看成是一维数组array1的元素而存在。从数组底层的运行机制来看，其实没有多维数组。 二维数组的使用 123456789int[][] arr1 = new int[][]&#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;;//静态初始化String[][] arr2 = new String[3][2];//动态初始化1String[][] arr3 = new String[3][];//动态初始化2//错误情况String[][] arr4 = new String[][4];String[4][3] arr5 = new String[][];int[][] arr6 = new int[4][3]&#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; Tips：中括号（[]）的位置可以放在类名或者变量名后面；或者类名后面放一个，变量名后面放一个（二维数组）。 类型推断：int[][] arr7 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; //省略new int[][] 数组的基本操作 如何调用数组指定位置的函数 arry[i][j]; //第i行第j列的元素 如何获取数组长度 arr4.length; arr4[0].length; 如何遍历数组 12345for(int i = 0; a &lt;= arr4.length; i++)&#123; for(int j = 0; j &lt;= arr4[i].length)&#123; //执行语句 &#125;&#125; 数组元素的默认初始化值 规定：二维数组分为外层数组的元素和内层数组的元素 int[][] arr = new int[4][3]; 外层元素：arr[0]，arr[1]等； 内层元素：arr[0][0]，arr[1][2]等； 初始化方式一：int[][] arr = new int[4][3]; 外层元素的初始化值为：地址值 内层元素的初始化值：与一维数组初始化情况相同 初始化方式二：int[][] arr = new int[4][]; 外层元素的初始化值为：null 内层元素的初始化值为：不能调用，否则报错 数组中涉及到的常见算法 数组元素的赋值（杨辉三角、回形书等）（面试常考） 求数值型数组中元素的最大值、最小值、平均数、总数等 1234567891011121314151617181920212223242526272829303132333435363738package com.dawnlee.arrayex;/** * * @Description 求数值型数组中元素的最大值、最小值、平均数、总和等 * @author DawnLee * @version 1.0 * @data 2020-7-27 22:14:07 * */public class NumArray &#123; public static void main(String[] args) &#123; int[] array = new int[10]; int maxValue = 0; int minValue = 0; int avg = 0; int sum = 0; for(int i = 0;i &lt; array.length;i++) &#123; array[i] = (int)(Math.random() * (99 - 10 + 1) + 10); System.out.print(array[i] + &quot; &quot;); if(array[i] &gt; maxValue) &#123; maxValue = array[i]; &#125; sum += array[i]; &#125; minValue = array[0]; for(int i = 0;i &lt; array.length;i++) &#123; if(array[i] &lt; minValue) &#123; minValue = array[i]; &#125; &#125; avg = sum / array.length; System.out.println(&quot;\\n最大值为：&quot; + maxValue); System.out.println(&quot;最小值为：&quot; + minValue); System.out.println(&quot;平均数为：&quot; + avg); System.out.println(&quot;总和为：&quot; + sum); &#125;&#125; 数组的复制、反转、查找（线性查找、二分法查找）（面试会考） 复制：通过遍历元素的方式进行复制操作，赋值只能使得新数组值相同一块内存区域，修改其中一个，原数组就得一起改变，相当于Linux中的硬链接 反转：通过中间变量实现反转 查找 线性查找 123456789101112String dest = &quot;BB&quot;;boolean isFind = false;for(i = 0;i &lt; arr.length;i++)&#123; if(dest.equals(arr[i]))&#123; System.out.println(&quot;找到了指定元素，位置为：&quot; + i); isFind = true; break; &#125;&#125;if(isFind == false)&#123; System.out.println(&quot;没找到！&quot;);&#125; 二分法查找 123456789101112131415161718192021//所有要查找的数组必须有序int[] arr2 = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int dest1 = -34;int head = 0;//初始首索引int end = arr2.length - 1;//初始末索引boolean isFind = false;while(head &lt;= end)&#123; int mid = (head + end)/2; if(dest1 == arr2[mid])&#123; System.out.println(&quot;找到了指定的元素，位置为：&quot; + mid); isFind = true; break; &#125;else if(arr2[mid] &gt; dest1)&#123; end = mid - 1; &#125;else&#123; head = mid + 1; &#125;&#125;if(isFind == false)&#123; System.out.println(&quot;很遗憾，没有找到！&quot; );&#125; 数组元素的排序算法（面试最常考） 排序：假设含有n个记录的序列为(R1, R2,…, Rn)，其相应的关键字序列为(K1, K2,…, Kn)。将这些记录重新排序为(Ri1, Ri2,…, Rin)，使得相应的关键字满足条件Ki1 &lt;= Ki2 &lt;=…&lt;= Kin，这样的一种操作成为排序。 通常来说，排序的目的是快速查找。 衡量排序算法的优劣 时间复杂度：分析关键字的比较次数和记录的移动次数。 空间复杂度：分析排序算法中徐需要多少辅助内存。 稳定性：若两个记录A和B的关键字值相等，但排序后A、B先后次序保持不变，则称这种排序算法是稳定的。 排序算法分类 内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。 十大内部排序算法（和具体语言无关），前八种较常用 (数据结构与算法中学) 各种排序算法的比较 从平均时间而言：快速排序最佳，但在最坏的情况下，时间性能不如堆排序和归并排序。 从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。 从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序。 从待排序的记录数n的大小看：n较小时，宜采用简单排序；而n较大时，宜采用改进排序。 排序算法的选择 若n较小（如n≤50），可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。 若文件初始状态基本有序（正序），则应选用直接插入、冒泡或随机的快速排序为宜。 若n较大，则应采用时间复杂度为O（nlgn）的排序方法：快速排序、堆排序或归并排序 算法五大特征 Arrays工具类的使用 java.util.Arrays类即为操作数组的工具类，它包含了用来操作数组（比如排序和搜索）的各种方法。 12345678910111213141516171819202122232425262728293031323334353637383940package com.dawnlee.arrayex;import java.util.Arrays;/** * * @Description java.util.Arrays：操作数组的共工具类，里面定义了很多操作数组的方法 * @author DawnLee * @version 1.0 * @data 2020-7-28 16:56:11 * */public class ArraysTest &#123; public static void main(String[] args) &#123; //1.boolean equals(int[] a,int[] b):判断两个数组是否相等 int[] arr1 = new int[] &#123;1,2,3,4&#125;; int[] arr2 = new int[] &#123;1,3,2,4&#125;; boolean isEquals = Arrays.equals(arr1,arr2); System.out.println(isEquals); //2.String toString(int[] a):输出数组信息 System.out.println(Arrays.toString(arr1)); //3.void fill(int[] a,int val):将指定的值填充到数组中 Arrays.fill(arr1,10); System.out.println(Arrays.toString(arr1)); //4.void sort(int[] a):对数组进行排序 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //5.int binarySearch(int[] a,int key):对排序后的数组进行二分法检索指定的值 int[] arr3 = new int[] &#123;-98,-34,2,34,54,66,79,105,210,333&#125;; int index = Arrays.binarySearch(arr3, 333); if(index &gt;= 0) &#123; System.out.println(index); &#125;else &#123; System.out.println(&quot;未找到&quot;); &#125; &#125; &#125; 数组中常见的一异常 注意：编译时不会报错","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第二章 Java基本语法","slug":"第二章 基本语法","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:19:19.938Z","comments":true,"path":"undefined/2136.html","link":"","permalink":"https://asteroidcs.github.io/undefined/2136.html","excerpt":"","text":"关键字与保留字关键字（keyword） 定义：被Java语言赋予特殊含义，用作专门用途的字符（单词）。 特点：关键字中所有字母都为小写。 官方地址：https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html 保留字（reserved word） ava保留字:现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const 标识符（Identifier）标识符 ava对各种变量、方法和类等要素命名时使用的字符序列称为标识符。 比如：类名、变量名、方法名、接口名、包名…… 技巧：凡是自己可以取名字的地方都叫标识符。 定义合法标识符规则（必须遵守） 由26个英文字母大小写，0-9，_或$组成； 数字不可开头； 不可以使用关键字和保留字，但可以包含关键字和保留字； Java中严格区分大小写，长度无限制； 标识符不能包含空格。 Java中名称命名规范（建议遵守） 包名：多单词组成时所有字母都小写：xxxyyyzzz； 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ； 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz； 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ； 注意 注意1：在取名字时，为提高阅读性，要尽量有意义（见名知意） 注意2：Java采用unicode字符集，因此标识符也可以使用汉字声明，但不建议使用 变量变量的概念 内存中的一个存储区域； 该区域的数据可在同一类型范围内不断变化； 变量是程序中最基本的存储单元。包含变量类型（强类型：必须先声明）、变量名和存储的值。 定义变量的格式：数据类型 变量名 = 变量值 例：int myAge = 18; 变量的作用 ava中每个变量必须先声明，后使用； 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了。“一对{}”即为一个作用域； 同一个作用域内，不能声明两个同名的变量。 Java定义的数据类型（按数据类型分）：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间 变量的分类 按数据类型：对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间。 (1) 数值型 整数类型 byte 占用存储空间：1字节 = 8bit位 表数范围：-128~127（27），最高位为符号位（0正1负），故为7次方 short 占用存储空间：2字节 表数范围：-215~215-1 int 占用存储空间：4字节 表数范围：-231~231-1（约21亿） long 占用存储空间：8字节 表数范围：-263~263-1 ==注意== Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性 Java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’ Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long 浮点类型 单精度float 占用存储空间：4字节 表数范围：-3.403E38~3.403E38 双精度double 占用存储空间：8字节 表数范围：-1.798E308~1.798E308 注意：与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响 浮点型常量有两种表示形式 十进制数形式：如：5.12、512.0f、.512 (必须有小数点） 科学计数法形式:如：5.12e2、512E2、100E-2 float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求 double：双精度，精度是float的两倍。通常采用此类型 Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’ float表示的数值范围比long还大，是因为它使用科学计数法来计数，但是精度不够 (2) 字符型 char 1字符 = 2字节 声明或定义char型变量，通常使用一对单引号（’’），内部只能写一个字符 转义字符（例如：换行符\\n、制表符\\t、unicode编号等） 布尔型 boolean 只能取两个值之一：true、false 常用于判断、循环结构 boolean类型数据只允许取值true和false，无null 不可以使用0或非 0 的整数替代false和true，这点和C语言不同 Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替：true用1表示，false用0表示 引用数据类型（reference type） 类（class） 接口（interface） 数组（[]） 基本数据类型之间的运算规则前提 这里只讨论7种基本数据类型变量间的运算，不包含boolean类型的。 自动类型提升 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为: 多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。 byte、char、short三种类型变量做运算时，结果为int类型，即这三个变量之间的运算结果至少要拿一个int型去接收。原因：可能是防止溢出，并且整形常量默认类型为int型，运算时如果直接加减数字的话编译不通过。 boolean类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。 字符串类型:String String不是基本数据类型，属于引用数据类型 使用方式与基本数据类型一致。例如:String str = “abcd”; 一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据 强制类型转换 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。 使用时要加上强制转换符:()，但可能造成精度降低或溢出,格外要注意 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。 boolean类型不可以转换为其它的数据类型。 进制（了解内容） 所有数字在计算机底层都以二进制形式存在 整数的四种表示方式 二进制(binary)：0,1 ，满2进1，以0b或0B开头； 十进制(decimal)：0-9 ，满10进1； 八进制(octal)：0-7 ，满8进1，以数字0开头表示； 十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0。 二进制 Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位 二进制的整数有如下三种形式： 原码：直接将一个数值换成二进制数。最高位是符号位。 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 计算机以二进制补码的形式存所有的整数。 正数的原码、反码、补码都相同 负数的补码是其反码+1 运算符 概念：运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等 算术运算符 整形数相除后默认结果为整形 需要精确结果进行运算前需要先进行类型转换（自动转换或者强制类型转换） 取模（余）运算（%） 结果符号与被模（除）数相同 自增（减） （前）++：先自增1，后运算 （后）++：先运算，后自增1 自减（略） 注意：自增（减）不会改变变量本身数据类型 赋值运算符（=） 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理 支持连续赋值 int i1, j1; i1 = j1 = 10; 比较（关系）运算符 比较运算符的运算结果都是boolean型，也就是要么是true，要么false 区分“=”和“==” 逻辑运算符 区分逻辑与（&amp;）和短路与（&amp;&amp;） 相同点：运算结果相同；党符号左边为true时，都会执行符号右边的内容 不同点：当左边为false时，&amp;&amp;不会执行符号右边的运算（短路） 开发中优先使用短路与（&amp;&amp;） 区分逻辑或（|）和短路或（||） 相同点：运算结果相同；当符号右边为false时，二者都会执行符号右边的内容 不同点：当符号左边为true时，|| 不会执行符号右边的运算（短路） 开发中优先使用短路或（||） 逻辑非（!） 逻辑异或（^） 相同为true，不同为false 位运算符（用得较少） 位运算符细节： 位运算符是直接对整数的二进制进行的运算 位运算符操作的都是整形的数据 &lt;&lt;：在一定范围内，每向左移n位，相当于*2n &gt;&gt;：在一定范围内，每向右移n位，相当于/2n 面试题：如何最高效的计算2*8？ 2 &lt;&lt; 3 或 8 &lt;&lt; 1 注意：无&lt;&lt;&lt; &amp;、|、^运算 三元运算符 格式： 条件表达式的结果为boolean类型 表达式1和表达式2为同种类型 三元运算符可嵌套使用 三元运算符与if-else的联系与区别 三元运算符可简化if-else语句，因此能用三元运算符的地方尽量用三元运算符 三元运算符要求必须返回一个结果 if后的代码块可有多个语句 凡是可以使用三元运算符的地方都可以改写成if-else，反之则不一定行 练习：获取3个数中的最大值 12int max1 = (a &gt; b)? a : b;int max2 = (max1 &gt; c)? max1 : c; 运算符的优先等级 运算符有不同优先级，所谓优先级就是表达式 运算中的运算顺序 只有单目运算符、三元运算符、赋值运算符是从右向左运算的 流程控制概念 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块 如何从键盘/控制台获取不同类型的变量：需要使用Scanner类 导包：import java.util.Scanner; Scanner的实例化：Scanner scan = new Scanner(System.in); 调用Scanner的相关方法，来获取指定类型的变量。 对于char类型的获取，Scanner没有提供相关的方法，只能获取一个字符串。 如果一定要获取char类型，可用charAt(0)获取字符串索引为0位置上的字符。 注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配，则出现异常：InputMisMatchException，导致程序中断。容量小的可自动提升； 如何获取随机数 double value = Math.random()：返回一个[0.0, 1.0)之间的double型的值。 1获取[a,b]之间的int型随机数：(int)(Math.random() * (b - a + 1) + a) 流程控制方式结构化程序设计中规定的三种基本流程结构 顺序结构 程序从上到下逐行执行，中间没有任何判断和跳转 分支结构 根据条件，选择性地执行某段代码 有if-else和switch-case两种分支语句 循环结构 根据循环条件，重复性地执行某段代码 有while、do…while、for三种循环语句 注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素 分支语句if-else结构 第一种 12345if(条件表达式)&#123;执行表达式&#125; 二选一 123456789if(条件表达式)&#123;执行表达式1&#125;else&#123;执行表达式2&#125; 多选一 12345678910111213141516171819if(条件表达式1)&#123;执行表达式1&#125;if(条件表达式2)&#123;执行表达式2&#125;……else&#123;执行表达式n&#125; 使用说明 条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。 语句块只有一条执行语句时，一对{}可以省略，但建议保留 if-else语句结构，根据需要可以嵌套使用（一般不超过3层，超过3层未解决则停下来想其他办法）。 当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。 当多个条件是“包含”关系时，“小上大下 /子上父下”。 if (80 &lt; core &lt;= 99)报错原因：前面的(80 &lt; core)的结果为一个boolean类型，boolean类型不能与int类型做大小关系对比。 针对于条件表达式： 如果多个表达式之间是”互斥“关系（或没有交集的关系），判断和执行语句的上下顺序不影响。 如果多个表达式之间有交集的关系，则需要根据实际情况来决定哪个声明在上面。 如果多个表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则范围小的就没机会执行了。 就近原则 123456789101112if (x &gt; 2) if(y &gt; 2) 执行语句1;else 执行语句2;//上述语句相当于：if (x &gt; 2) if(y &gt; 2) 执行语句1; else 执行语句2;//以上误判源于省略了单行执行语句的&#123;&#125;，所以尽量不要省略&#123;&#125; switch-case结构 说明： 根据switch表达式中的值，依次匹配各个case中的常量。一旦配成功，则进入相应的case结构中，调用其执行语句，当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。 switch结构中的表达式，只能是如下六种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。 case之后只能声明常量，尤其不能是一个范围。 break关键字是可选的。 default：相当于if-else中的else，也是可选的，且default位置是可选的，一般还是写在末尾。 如果switch-case结构中多个case的执行语句相同，则可以考虑进行合并，即写完多行执行语句相同的case以后只写1行执行语句。 凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。 写分支结构时，如果既可以使用if-else，又可以使用switch-case（switch中表达式的取值情况不太多），优先选择使用switch-case。原因：switch-case执行效率稍高。 示例：输入日期，返回日期是那一年的第几天。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;class CountDays&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print(&quot;请输入年份：&quot;); int year = input.nextInt(); System.out.print(&quot;\\n请输入月份：&quot;); int month = input.nextInt(); System.out.print(&quot;\\n请输入日期：&quot;); int day = input.nextInt(); int days = 0; switch (month)&#123; case 12: days += 30; case 11: days += 31; case 10: days += 30; case 9: days += 31; case 8: days += 31; case 7: days += 30; case 6: days += 31; case 5: days += 30; case 4: days += 31; case 3: if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)&#123; days += 29; &#125;else&#123; days += 28; &#125; case 2: days += 31; case 1: days += day; System.out.println(&quot;\\n&quot; + year +&quot;年&quot; + month + &quot;月&quot; + day + &quot;号是&quot; + year + &quot;年的第&quot; + days + &quot;天。&quot;); break; default: System.out.println(&quot;\\n输入有误！&quot;); &#125; &#125;&#125; 循环结构 在某些条件满足得情况下，反复执行特定代码的功能 循环语句的四个组成部分 初始化部分（init_statement） 循环条件部分（test_exp）–&gt; boolean类型 循环体部分（body_statement） 迭代部分（alter_statement） 通常情况下，循环结束都是因为②中循环条件返回了false 循环语句分类 for循环 结构 for(① ; ② ; ④){ ③ } 执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt; 直到②不再返回true，跳出循环 例题：遍历100以内的偶数，输出所有偶数的和，输出所有偶数的个数。 1234567891011121314class ErgodicEvenNum&#123; public static void main(String[] args)&#123; int count = 0; int sum = 0; for (int i = 0; i &lt;= 100; i++)&#123; if (i % 2 == 0)&#123; sum += i; count += 1; &#125; &#125; System.out.println(&quot;0-100内偶数有&quot; + count + &quot;个，它们的和为：&quot; + sum); &#125;&#125;//i在for循环内有效，出了for循环就失效了 例题：输入两个正整数m和n，求其最大公约数和最小公倍数。比如，12和20的最大公约数是4，最小公倍数是60。 说明break的作用：跳出循环体 123456789101112131415161718192021222324import java.util.Scanner;class GetGcdLcm&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;请输入第一个整数：&quot;); int m = scan.nextInt(); System.out.print(&quot;\\n请输入第二个整数：&quot;); int n = scan.nextInt(); int min = (m &lt;= n)? m : n; for (int i = min; i &gt; 0; i--)&#123; if (m % i == 0 &amp;&amp; n % i == 0)&#123; System.out.print(&quot;\\n&quot; + m + &quot;和&quot; + n + &quot;的最大公约数为&quot; + i + &quot;，&quot;); break; &#125; &#125; int max = (m &gt;= n)? m : n; for (int i = max; i &lt;= m * n; i++)&#123; if (i % m == 0 &amp;&amp; i % n == 0)&#123; System.out.println(&quot;最小公倍数为&quot; + i + &quot;。&quot;); break; &#125; &#125; &#125;&#125; while循环 结构 ①初始化部分 while(②循环条件部分)&#123; ③循环体部分; ④迭代部分; &#125; 执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt;② 说明 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。 for循环和while循环可以相互转换 for循环和while循环初始化条件的作用范围不同。 i 出了while循环后可以继续使用，原因：①初始化部分在循环外。 do-while 结构 ① do&#123; ③； ④； &#125;while(②)； 执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② …… -&gt;② 特点 先执行再判断，至少执行一次循环体。 开发中较少使用do-while，for和while使用较多。 循环语句综合题：从键盘输入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时，结束程序。 1234567891011121314151617181920import java.util.Scanner;class CirCom&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int posNum = 0; int negNum = 0; while(true)&#123; int alter = scan.nextInt(); if (alter &gt; 0)&#123; posNum += 1; &#125;else if (alter &lt; 0)&#123; negNum += 1; &#125;else&#123; break; &#125; &#125; System.out.println(&quot;输入的正数个数为：&quot; + posNum); System.out.println(&quot;输入的负数个数为：&quot; + negNum); &#125;&#125; 说明： while(true)就相当于for(;;) 结束循环的几种方式 循环条件部分返回false； 在循环体中执行break。 嵌套循环 嵌套循环的使用 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环。 外层循环：循环结构B。 内层循环：循环结构A。 说明 内层循环结构遍历一遍，只相当于外层循环结构循环一次。 假设外层循环需要执行m次，内层循环需要执行n次，此时内存层循环的循环体需要执行m*n次。 技巧：外层循环控制行数，内层循环控制列数。 例题1：九九乘法表 1234567891011121314import java.util.Scanner;class MultiTable&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印几行？（1-9）&quot;); int line = scan.nextInt(); for (int i = 1; i &lt;= line; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; System.out.print(i + &quot;x&quot; + j + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 例题2：100以内所有质数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;class PriNum&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印多少以内的质数？&quot;); int limtNum = scan.nextInt(); System.out.println(&quot;*********结果*********&quot;); boolean isPriNum = true; for (int i = 2; i &lt;= limtNum; i++)&#123; for (int j = 2; j &lt; i; j++) &#123; if (i % j ==0)&#123; isPriNum = false; &#125; &#125; if (isPriNum)&#123; System.out.println(i); &#125; isPriNum = true; &#125; &#125;&#125;//优化import java.util.Scanner;class PriNum&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;要打印多少以内的质数？&quot;); int limtNum = scan.nextInt(); System.out.println(&quot;*********结果*********&quot;); long start = System.currentTimeMillis();//获取当前时间距1970-01-01 00:00:00的毫秒数（long型） boolean isPriNum = true; int count = 0; for (int i = 2; i &lt;= limtNum; i++)&#123; //for (int j = 2; j &lt; i; j++)&#123; for (int j = 2; j &lt;= Math.sqrt(i); j++)&#123;//优化二：一个数如果在2到它本身开方的范围内没有商，则为质数 if (i % j ==0)&#123; isPriNum = false; break;//优化一：只对本身非质数的自然数是有效的。加break前后对比：20181ms/2174ms = 9.28 &#125; &#125; if (isPriNum)&#123; count += 1; &#125; isPriNum = true; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;质数的个数：&quot; + count); System.out.println(&quot;所花费的时间：&quot; + (start - end)); //优化前：17916ms 优化一：1629ms 优化二：16ms &#125;&#125; 特殊关键字的使用 break 使用范围：switch-case、循环结构中 循环中使用的作用：结束当前循环 默认跳出包裹此关键字最近的一层循环 结束指定标识的一层循环结构 1234567label:for (int i = 1; i &lt;= 4; i++)&#123; for (int j = 1; j &lt;= 10; j++)&#123; if (j % 4 == 0)&#123; break label; &#125; &#125;&#125; continue 使用范围：循环结构中 循环中使用的作用：结束当次循环 结束指定标识的一层循环结构的当次循环 countinue label; 注意：以上两个关键字后面不能声明执行语句 return 并非专门用于结束循环的，它的的功能是结束一个方法。当一个方法执行到一个return时，这个方法将被结束。 与break、continue不同的是吗，return直接结束整个方法，不管这个return处于多少层循环之内。 补充：衡量一个功能代码的优劣 正确性 可读性 健壮性 高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第四章 面向对象（上）","slug":"第四章 面向对象(上)","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-10T13:18:28.428Z","comments":true,"path":"undefined/df1b.html","link":"","permalink":"https://asteroidcs.github.io/undefined/df1b.html","excerpt":"","text":"Java面对对象学习的三条主线 Java类及类的成员：属性、方法、构造器；代码块、内部类； 面向对象的三大特征：封装性、继承性、多态性（、抽样性）； 其他关键字：this、super、final、abstract、interface、package、import等。 面向过程与面向对象面向过程与面向对象区别 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。 面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 面对对象的三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 面对对象的思想概述 程序员从面向过程的执行者转化成了面向对象的指挥者。 面对对象分析问题的思路和步骤： 根据问题需要，选择问题所针对的现实世界中的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。 Java基本元素：类和对象面对对象的思想概述 类（Class）和对象（Object）是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例（instance） 万物皆对象 面对对象程序设计的重点是类的设计 类的设计，其实就是类的成员的设计 Java类及类的成员 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多不同功能的类构成的。 现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质……那么，Java中用类来描述事物也是如此。常见类的成员有： 属性：对应类中的成员变量 行为：对应类中的成员方法 对象的创建和使用面对对象思想的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package io.github.dawn333.oop;/** * * @Description 一、类和对象的使用（面对对象思想落地的实现）： * 1、创建类，设计类的成员 * 2、创建类的对象 * 3、通过“对象.属性”或“对象.方法”调用对象的结构 * * 二、如果创建了多个对象，则每个对象都独立的拥有一套属性。（非static） * 意味着，如果改一个对象的属性a，不影响另一个对象属性a的值。 * @author DawnLee * @version 1.0 * @data 2020-7-30 16:32:18 * */public class PersonTest &#123; public static void main(String[] args) &#123; //创建Person类的对象、 Person p1 = new Person(); //调用对象的结构：属性、方法 //调用属性：对象.属性 p1.name = &quot;Tom&quot;; p1.isMale = true; System.out.println(p1.name); //调用方法：对象.方法 p1.eat(); p1.sleep(); p1.talk(&quot;Chinese&quot;); //************************ Person p2 = new Person(); System.out.println(p2.name);//null //************************ Person p3 = p1; //将p1变量保存的地址赋给p3，导致p1和p3指向了堆空间中的同一个对象实体。 System.out.println(p3.name);//Tom p3.age = 10; System.out.println(p1.age);//10 &#125;&#125;class Person&#123; //属性 String name; int age; boolean isMale; //方法 public void eat() &#123; System.out.println(&quot;人可以吃饭&quot;); &#125; public void sleep() &#123; System.out.println(&quot;人可以睡觉&quot;); &#125; public void talk(String language) &#123; System.out.println(&quot;人可以说话，使用的语言是：&quot; + language); &#125;&#125; 内存解析 堆（heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 通常所说的栈（stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（bolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。 方法区（method area），用于存储已被虚拟机加载类信息、常量、静态变量、即时编译器编译后的代码等数据。 对象内存解析 内存解析的说明 引用类型的变量，只可能存储两类值：null或地址值（含变量的类型） 对象数组的内存解析 JVM内存结构 关注书籍：《JVM规范》 虚拟机栈即为平时提到的栈结构，我们将局部变量存储在栈结构中。 堆，我们将new出来的结构（比如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中。 理解“万事万物皆对象” 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。 Scanner，String等 文件：File 网络资源：URL 涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 匿名对象的使用 理解：我们创建的对象没有显示的赋给一个变量名， 即为匿名对象。 特征：匿名对象只能代用一次。 使用：如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package io.github.triabin.oop;/** * * @Description 匿名对象的使用 * @author DawnLee * @version 1.0 * @data 2020-8-6 16:04:02 * */public class InstanceTest &#123; public static void main(String[] args) &#123; Phone p = new Phone(); System.out.println(&quot;正常调用：&quot;); p.sendEmail(); p.playGame(); //匿名 System.out.println(&quot;\\n匿名对象：&quot;); new Phone().sendEmail(); new Phone().playGame(); System.out.println(&quot;\\n匿名对象只能代用一次：&quot;); new Phone().price = 1999; new Phone().showPrice(); System.out.println(&quot;\\n匿名对象的使用：&quot;); PhoneMall mall = new PhoneMall();// mall.show(p); mall.show(new Phone()); &#125;&#125;class PhoneMall&#123; public void show(Phone phone) &#123; phone.sendEmail(); phone.playGame(); &#125;&#125;class Phone&#123; double price;//价格 public void sendEmail() &#123; System.out.println(&quot;发送邮件&quot;); &#125; public void playGame() &#123; System.out.println(&quot;玩游戏&quot;); &#125; public void showPrice() &#123; System.out.println(&quot;手机的价格为：&quot; + price); &#125;&#125; 类的成员之一：属性类中属性的使用 语法格式: 说明： 说明1: 修饰符 常用的权限修饰符有:private、缺省、protected、public 其他修饰符:static、final (暂不考虑) 说明2:数据类型 任何基本数据类型(如int、Boolean) 或 任何引用数据类型。 说明3:属性名 属于标识符，符合命名规则和规范即可。 举例 123public class Person&#123;private int age; //声明private变量 agepublic String name = “Lila”; //声明public变量 name &#125; 变量的分类:成员变量与局部变量 成员变量：在方法体外，类体内声明的变量。 局部变量：在方法体内部声明的变量称。 注意:二者在初始化值方面的异同**:** 同:都有生命周期 异:局部变量除形参外，均需显式初始化。 区别： 代码示例： 12345678910111213141516171819202122232425262728293031323334package io.github.triabin.oop;/** * * @Description 类中属性的使用 * @author DawnLee * @version 1.0 * @data 2020-8-5 14:49:47 * */public class UserTest &#123; public static void main(String[] args) &#123; User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); u1.talk(&quot;日语&quot;);//特别的 &#125;&#125;class User&#123; //属性（或成员变量） String name; int age; boolean isMale; public void talk(String language) &#123;//形参，也是局部变量 System.out.println(&quot;我们使用&quot; + language +&quot;进行交流。&quot;); &#125; public void eat() &#123; String food = &quot;烙饼&quot;;//局部变量 System.out.println(&quot;北方人喜欢吃&quot; + food); &#125;&#125; 类的成员之二: 方法(method) 方法：描述类具有的功能。比如：Math类：sqrt()\\random()\\…… Scanner类：nextXxx()…… Arrarys类：sort()\\binarySearch()\\toString()\\equals()\\…… 类中方法的声明和使用 举例 public void eat(){}（void：没有返回值） public void sleep(int hour){} public String getNmae() {}（String：返回一个String类型的数据） public String getNation(String nation){} 方法的声明： 注意：static、final、abstract来修饰的方法 说明： 关于权限修饰符：目前默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private、public、缺省、protected —&gt; 封装性再细说 返回值类型：有返回值 or 无返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中必须使用return关键字来返回指定类型的变量或常量。例如下列代码实例方法中的getName()方法。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不使用return。但是，如果使用的话，只能“return;”，表示结束此方法。 方法名：属于标识符，遵循表示符的规则和命名规范，“见名知意”。 形参列表：方法可以声明0个，1个或多个形参。 格式：数据类型1 形参1,数据类型2 形参2,… 方法体：方法功能的体现。 return关键字的使用： 使用范围：使用在方法体中。 作用：①结束方法；②针对于有返回值的方法，使用“return 数据;”方法返回所要的数据。 ==注意：return关键字后面不可以声明执行语句== 方法的使用中可以调用当前类的属性或方法 特别地：方法A中调用方法A：递归方法。 方法中不能再定义方法。 代码实例1234567891011121314151617181920212223242526272829303132333435package io.github.triabin.oop;public class CustomarTest &#123;&#125;//客户类class Customar&#123; //属性: String name; int age; boolean isMale; //方法： public void eat()&#123; System.out.println(&quot;客户吃饭&quot;); &#125; public void sleep(int hour) &#123; System.out.println(&quot;休息了&quot; + hour + &quot;小时&quot;); &#125; public String getNmae() &#123; if(age &gt; 18) &#123; return name; &#125;else &#123;//没有else则报错，必须要有一个返回值。 return &quot;Tom&quot;; &#125; &#125; public String getNation(String nation) &#123; String info = &quot;我的国籍是：&quot; + nation; return info; &#125;&#125; 方法的分类（按照是否有形参及返回值） 再谈方法方法的重载 定义： 在同一个类中，允许存在一个以上的同名方法，只要它们的==参数个数== ==或者== ==参数类型==不同即可。 “两同一不同”：同一个类、相同的方法名；参数列表不同：参数个数不同、参数类型不同 特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。 示例 Arrays类中重载的sort() / binarySearch() 12345678910111213141516171819202122232425262728293031public class OverLoadTest &#123; public static void main(String[] args) &#123; OverLoadTest test = new OverLoadTest(); test.getSum(1,2); &#125; //如下4个方法构成了重载 public void getSum(int i,int j) &#123; System.out.println(&quot;1&quot;); &#125; public void getSum(double d1, double d2) &#123; System.out.println(&quot;2&quot;); &#125; public void getSum(String s, int i) &#123; System.out.println(&quot;3&quot;); &#125; public void getSum(int i,String s) &#123; System.out.println(&quot;4&quot;); &#125; // public int getSum(int i,int j) &#123;// return 0;// &#125; // public void getSum(int m,int n) &#123;// // &#125;&#125; 注意：支持自动类型提升，例如，如果形参为double型，但是输入的形参为int型，则自动将int型转换为double型。 判断是否是重载 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系，==只看形参数目和类型== 通过对象调用方法时，如何确定某一个指定的方法： 方法名 —&gt; 参数列表 练习题 编写程序，定义三个重载方法并调用。方法名为mOL。 三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果、相乘并输出结果、输出字符串信息。 在主类的main方法中分别用参数区别调用三个方法。 1234567891011121314151617181920public class OverLoadEx1 &#123; public static void main(String[] args) &#123; OverLoadEx1 m = new OverLoadEx1(); m.mOL(2); m.mOL(2, 5); m.mOL(&quot;字符串&quot;); &#125; public void mOL(int i) &#123; System.out.println(i * i); &#125; public void mOL(int i,int j) &#123; System.out.println(i * j); &#125; public void mOL(String s) &#123; System.out.println(s); &#125;&#125; 定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，分别调用三个方法。 123456789101112131415161718public class OverLoadEx2 &#123; public static void main(String[] args) &#123; OverLoadEx2 test = new OverLoadEx2(); test.max(1, 3); test.max(1.5, 3.5); test.max(1.5, 3.5, 7.5); &#125; public void max(int i,int j) &#123; System.out.println(&quot;第一个方法求得最大值为：&quot; + ((i &gt; j)? i : j)); &#125; public void max(double i,double j) &#123; System.out.println(&quot;第二个方法求得最大值为：&quot; + ((i &gt; j)? i : j)); &#125; public void max(double i,double j,double k) &#123; System.out.println(&quot;第三个方法求得最大值为：&quot; + ((((i &gt; j)? i : j) &gt; k)? ((i &gt; j)? i : j) : k)); &#125;&#125; 可变个数的形参 JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量 public static void test(int a,String[] books); JDK 5.0：采用可变个数形参来定义方法，传入多个同一类型变量 public static void test(int a,String...books); 具体使用： 可变个数形参的格式：数据类型 … 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0个、1个、2个…… 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。 ==可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不够成重载（即二者不能共存）。== 可变个数形参在方法的形参列表中，==必须声明在末尾==。 可变个数形参在方法的形参列表中，==最多只能声明一个可变形参==。 示例 1234567891011121314151617181920212223242526272829303132public class VarAgu &#123; public static void main(String[] args) &#123; VarAgu test = new VarAgu(); test.show(12); test.show(&quot;Hello&quot;); test.show(&quot;Hello&quot;,&quot;world&quot;); test.show(); // test.show(new String[] &#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量,JDK 5.0向前兼容,所以(String ... strs)同样可以用此方法传入形参 test.show(&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;); &#125; public void show(int i) &#123; System.out.println(&quot;show(int i)&quot;); &#125; public void show(String s) &#123; System.out.println(&quot;show(String)&quot;); &#125; public void show(String ... strs) &#123; System.out.println(&quot;show(String ... strs)&quot;); //调用 for(int i = 0;i &lt; strs.length;i++) &#123; System.out.println(strs[i]); &#125; &#125; // public void show(String[] strs) &#123;//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量// System.out.println(&quot;show(String[] strs)&quot;);// &#125;&#125; ==方法参数的值传递机制==变量的值传递机制 关于变量的赋值： 如果是基本数据类型，此时赋值的是变量所保存的数据值； 如果变量是引用数据类型，此时，赋值的是变量所保存的数据的地址值。 示例 12345678910111213141516171819202122public class ValueTransfer &#123; public static void main(String[] args) &#123; System.out.println(&quot;******基本数据类型的值传递情况******&quot;); int m = 10; int n = m; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); System.out.println(&quot;******引用数据类型的值传递情况******&quot;); Order o1 = new Order(); o1.orderID = 1001; Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。 System.out.println(&quot;o1.orderID = &quot; + o1.orderID + &quot;, o2.orderID = &quot; + o2.orderID); o2.orderID = 1002; System.out.println(&quot;o1.orderID = &quot; + o1.orderID + &quot;, o2.orderID = &quot; + o2.orderID); &#125;&#125;class Order&#123; int orderID;&#125; 方法的形参传递机制：值传递 形参：方法定义时，声明的小括号内的参数。 实参：调用方法时实际传递给形参的数据。 值传递机制： 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值; 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。 示例1 123456789101112131415161718192021public class ValueTransfer01 &#123; public static void main(String[] args) &#123; int m = 10; int n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); //交换两个变量值的操作// int temp = m;// m = n;// n = temp; ValueTransfer01 test = new ValueTransfer01(); test.swap(m, n);//未能交换，原因看内存解析。 System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); &#125; public void swap(int m,int n) &#123; int temp = m; m = n; n = temp; &#125;&#125; 结果： 内存解析（交换失败原因） 示例2 12345678910111213141516171819202122232425262728public class ValueTransfer02 &#123; public static void main(String[] args) &#123; Data data = new Data(); data.m = 10; data.n = 20; System.out.println(&quot;m = &quot; + data.m + &quot;,n = &quot; + data.n); //交换m和n的值// int temp = data.m;// data.m = data.n;// data.n = temp; ValueTransfer02 test = new ValueTransfer02(); test.swap(data); System.out.println(&quot;m = &quot; + data.m + &quot;,n = &quot; + data.n); &#125; public void swap(Data data) &#123; int temp = data.m; data.m = data.n; data.n = temp; &#125;&#125;class Data&#123; int m; int n;&#125; 运行结果 内存解析 练习题例题一：方法的参数传递123456789101112131415161718192021222324252627282930public class ValueTransferEx01 &#123; public static void main(String[] args) &#123; ValueTransferEx01 test = new ValueTransferEx01(); test.first(); &#125; public void first()&#123; int i = 5; Value v = new Value(); v.i = 25; second(v,i); System.out.println(v.i); &#125; public void second(Value v,int i)&#123; i = 0; v.i = 20; Value val = new Value(); v = val; System.out.println(v.i + &quot; &quot; + i); &#125;&#125;class Value&#123; int i = 15;&#125;//result15 020 内存解析 递归（recursion）方法 递归方法：一个方法体内调用自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 示例 123456789101112131415161718192021222324252627282930313233343536373839public class RecursionIns &#123; public static void main(String[] args) &#123; //计算1-100内所有数的和 //方式一 int sum1 = 0; for(int i = 1;i &lt;= 100;i++) &#123; sum1 += i; &#125; System.out.println(&quot;方式一：&quot; + sum1); //方式二（递归）： RecursionIns test = new RecursionIns(); int sum2 = test.getSum(100); System.out.println(&quot;方式二：&quot; + sum2); //计算阶乘 int n = 5; int fac = test.getFac(n); System.out.println(n + &quot;的阶乘为：&quot; + fac); &#125; //计算1-100内所有数的和的方法 public int getSum(int n) &#123; if(n == 1) &#123; return n; &#125;else &#123; return n + getSum(n - 1); &#125; &#125; //计算1-n之间的乘积：n! public int getFac(int n) &#123; if(n == 1) &#123; return n; &#125;else &#123; return n * getFac(n - 1); &#125; &#125;&#125; 练习题 已知有一个数列：f(0) = 1，f(1) = 4，f(n+2) = 2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。 12345678910111213141516public class RecursionEx01 &#123; public static void main(String[] args) &#123; RecursionEx01 test = new RecursionEx01(); System.out.println(&quot;f(10) = &quot; + test.f(10)); &#125; public int f(int n) &#123; if(n == 0) &#123; return 1; &#125;else if(n == 1) &#123; return 4; &#125;else &#123; return 2*f(n - 1) + f(n - 2); &#125; &#125;&#125; 斐波那契数列（Fibonacci）: 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值1 1 2 3 5 8 13 21 34 55。 规律：一个数等于前两个数之和。 要求：计算斐波那契数列的第n个值，并将整个数列打印出来。 1234567891011121314151617181920212223public class RecursionEx02 &#123; public static void main(String[] args) &#123; RecursionEx02 test = new RecursionEx02(); Scanner input = new Scanner(System.in); System.out.println(&quot;要打印斐波那契数列前几位？（输入任意大于0的整数）&quot;); int n = input.nextInt(); for(int i = 1;i &lt;= n;i++) &#123; System.out.print(test.f(i) + &quot; &quot;); &#125; System.out.println(); input.close(); &#125; public int f(int n) &#123; if(n == 1) &#123; return 1; &#125;else if(n == 2) &#123; return 1; &#125;else &#123; return f(n - 1) + f(n - 2); &#125; &#125;&#125; OOP特征一：封装与隐藏 OOP，即Object oriented programming，面向对象编程。 引入 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗？有必要碰电动机吗? 我要开车…… 我们程序设计追求==“高内聚，低耦合”==。 高内聚：类的内部操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 信息的封装和隐藏 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值的操作要受属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们需要给属性赋值加入额外的条件。这个条件就不能再属性声明时体现，我们只能通过方法进行限制条件的添加。（比如，示例中的setLegs()方法）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private）。 –&gt; 此时，针对属性就体现了封装性。 封装性的体现：我们讲类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。 拓展：封装性的体现 ①如上 ②不对外暴露的私有的方法 ③单例模式 … 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class InsAnimal &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.name = &quot;大黄&quot;; //a.age = 1;//age属性私有后无法赋值，通过setAge()方法来赋值 a.setAge(1); //a.legs = 4;//The field Animal.legs is not visible（不可见） a.setLegs(4); a.show(); System.out.println(); a.setLegs(6); a.show(); System.out.println(); a.setLegs(-2); a.show(); &#125;&#125;class Animal&#123; String name; private int age; private int legs;//私有权限修饰符，使得外界不能直接调用legs这个参数，只能通过规定的方式（setLegs()）来设置legs属性的值 //筛选合理赋值 public void setLegs(int l) &#123; if(l &gt;= 0 &amp;&amp; l % 2 == 0) &#123; legs = l; &#125;else&#123; legs = 0; //抛出一个异常（暂时没有讲） &#125; &#125; //legs被私有化以后用它来获取当前legs属性 public int getLegs() &#123; return legs; &#125; public void eat() &#123; System.out.println(&quot;动物进食&quot;); &#125; public void show() &#123; System.out.println(&quot;name:&quot; + name + &quot;，age:&quot; + age + &quot;， legs:&quot; + legs); &#125; //提供属性age的get和set方法 public int getAge() &#123; return age; &#125; public void setAge(int n) &#123; age = n; &#125;&#125; 四种访问权限修饰符 封装性的体现，需要权限修饰符来配合 Java规定的种权限（从小到大排列）：private、缺省、protected、public Java的权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类成员的访问权限。 4种权限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类。 具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类只能用default（缺省）、public。 总结封装性： Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构的在被调用时的可见性大小。 类的成员之三：构造器（或构造方法）构造器的作用 创建对象 初始化对象的信息 示例： 1234567891011121314151617181920212223242526272829303132public class PersonTest &#123; public static void main(String[] args) &#123; //创建类的对象：new + 构造器 Person p = new Person(); p.eat(); Person p1 = new Person(&quot;Tom&quot;); System.out.println(p1.name); &#125;&#125;class Person&#123; //属性 String name; int age; //构造器 public Person() &#123; System.out.println(&quot;Person()....&quot;); &#125; public Person(String n) &#123; name = n; &#125; //方法 public void eat() &#123; System.out.println(&quot;人吃饭&quot;); &#125; public void study() &#123; System.out.println(&quot;人可以学习&quot;); &#125;&#125; 说明 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){}。 一个类中定义多个构造器，彼此构成重载。 一旦我们显式定义了构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 总结：属性赋值的先后顺序 默认初始化 显式初始化 构造器中初始化 通过”对象.方法”的方式赋值 扩展知识扩展知识一：JavaBean JavaBean是一种Java语言写成的可重用组件。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 用户可以使用JavaBean将功能、处理。值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 扩展知识二：UML类图 +表示public类型，-表示private类型，#表示protected类型。 方法的写法： 方法的类型（+、-） 方法名(参数名:参数类型):返回值类型 ==关键字：this==this关键字的使用 his可以用来修饰：属性、方法、构造器。 this修饰属性和方法：this可理解为当前对象（方法中）或当前正在创建的对象（构造器中） 在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用“this.属性”或”this.方法“的方式，调用当前属性或方法。但是通常情况下，我们都选择省略”this.“。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。、 this调用构造器 我们在类的构造器中，可以显式的使用“this(形参列表)”的方式，调用本类中指定的其他构造器。 构造器中不能通过“this(形参列表)”的方式调用自己。 如果有n个构造器，最多有n-1个个构造器中使用了“this(形参列表)” 规定：“this(形参列表)”必须声明在当前构造器的首行 构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他构造器。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setAge(18); System.out.println(p1.getAge()); Person p2 = new Person(&quot;Triabin&quot;,20); System.out.println(p2.getAge() + &quot;\\t&quot; + p2.getName()); &#125;&#125;class Person&#123; private String name; private int age; public Person() &#123; &#125; //构造器中使用:理解为当前正在创建的对象（Person） public Person(String name) &#123; this.name = name; &#125; public Person(int age) &#123; this.age = age; &#125; public Person(String name,int age) &#123;// this(name);//调用其他构造器// this.age = age; this(name); this.age = age; &#125; //方法中使用:理解为当前对象（Person） public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age; &#125;&#125; 关键字：package、importpackagepackage关键字的使用 为了更好的实现项目中类的管理，提供包的概念。 使用package来声明类或接口所属的包，声明在源文件首行。 包，属于标识符，遵循标识符的命名规则、规范（全小写）、见名知意。 每“.”一次，就代表一层文件目录。 同一个包下，不能命名同名的接口、类。 JDK中主要的包介绍 java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System 和 Thread，提供常用功能。 java.net—-包含执行与网络相关的操作的类和接口。 java.io—-包含能提供多种输入/输出功能的类。 java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text—-包含了Java进行JDBC数据库编程的相关类/接口。 java.sql—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 MVC设计模式 MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。 模型层：model，主要处理数据。 数据对象封装 model.bean/domain 数据库操作类 model.dao 数据库 model.db 控制层：controller，处理业务逻辑。 应用界面相关 controller.activity 存放fragment controller.fragment 显示列表的适配器 controller.adapter 服务相关的 controller.service 抽取的基类 controller.base 视图层：view，显示数据。 相关工具类 view.utils 自定义view view.ui importimport关键字的使用 在源文件显式的使用import结构导入指定包下的类、接口。 声明在包的声明和类的声明之间。 如果需要导入多个包，则并列写出即可。 可以使用“xxx.*”的方式导入xxx包下所有结构。 如果使用的类或接口是java.lang包下定义的，则可以省略import结构。 如果使用的类或接口是本包下定义的，则可以省略import结构。 如果再源文件中使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 如果使用“xxx.*”的方式表明可以调用xxx包下所有结构。但如果使用的是xxx子包下的结构，仍需要显示导入。 import static：导入指定类或接口中的静态结构。 静态结构：属性或方法 面试题面向对象面向对象的三大特征说明 面向对象有三大特点：封装、继承、多态。(如果要回答四个，可加上抽象性这一特点) 继承性 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装性 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 多态性 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 抽象性 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 作用域public、private、protected及默认不写时的区别？ public：修饰的结构在同一个工程(Project)中的结构都可调用； protected：同一个工程中不同包的子类、同一个包以内都可调用； 不写(缺省)：同一个包中的结构都可调用； private：只在其所在类内部可以调用。 找错123456public class Something &#123; void doSomething () &#123; private String s = &quot;&quot;; int l = s.length(); &#125;&#125; 答案：错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。 Java的内存管理之垃圾回收（了解） 分配：由JVM自动为其分配相应的内存空间 释放：由JVM提供垃圾回收机制自动的释放内存空间 垃圾回收机制（GC：Garbage Collection）：将垃圾对象所占用的堆内存进行回收。Java的垃圾回收机制是JVM提供的能力，由单独的系统级垃圾回收线程在空闲时间以不定时的方式动态回收。 垃圾对象：不再被任何引用指向的对象。 简答 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十七章 Java9&10&11新特性","slug":"第十七章 Java9&10&11新特性","date":"2020-06-11T16:00:00.000Z","updated":"2020-12-10T13:18:55.024Z","comments":true,"path":"undefined/1e12.html","link":"","permalink":"https://asteroidcs.github.io/undefined/1e12.html","excerpt":"","text":"Java 9 的新特性 JDK 和 JRE 目录结构的改变 JDK 8 的目录结构 JDK 9 的目录结构 模块化系统: Jigsaw ——&gt; Modularity 用模块来管理各个package，通过声明某个package 暴露，==模块(module)的概念==，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。 实现目标 模块化的主要目的在于减少内存的开销 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护 改进 Java SE 平台，使其可以适应不同大小的计算设备 改进其安全性，可维护性，提高性能 模块将由通常的类和新的模块声明文件(module-info.java)组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。 要想在java9demo模块中调用java9test模块下包中的结构： 需要在java9test的module-info.java中声明: 对应在java 9demo 模块的src 下创建module-info.java文件: Java的REPL工具：jShell命令 调出jShell 获取帮助 基本使用 导入指定的包 默认已经导入如下的所有包：(包含java.lang包) ==Tips==：在 JShell 环境下，语句末尾的“;” 是可选的。但推荐还是最好加上。提高代码可读 性。 只需按下 Tab 键，就能自动补全代码 列出当前 session 里所有有效的代码片段 查看当前 session 下所有创建过的变量 查看当前 session 下所有创建过的方法 Tips：我们还可以重新定义相同方法名和参数列表的方法，即为对现有方法的修改(或 覆盖)。 使用/open命令调用: 没有受检异常(编译时异常) 退出jShell 语法改进接口的私有方法 Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。 12345678910111213141516171819202122232425package lesson;/** * @author Justry * @Description * @date 2020-12-06 10:28 上午 */public interface MyInterface &#123; //如下三个方法放入权限修饰符都是public void methodAbstract(); static void methodStatic()&#123; System.out.println(&quot;我是接口中的静态方法&quot;); &#125; default void methodDefault()&#123; System.out.println(&quot;我是接口中的默认方法&quot;); &#125; //Java 8中此处报错，在java 9中就不会出现问题 private void methodPrivate()&#123; System.out.println(&quot;我是接口中的私有方法&quot;); &#125;&#125; 在Java 9中，接口更加的灵活和强大，==连方法的访问权限修饰符都可 以声明为private的了==，此时方法将不会成为你对外暴露的API的一部分 1234567891011121314151617181920212223242526272829303132package lesson;/** * @author Justry * @Description * @date 2020-12-06 10:34 上午 */public class MyInterfaceImp implements MyInterface&#123; @Override public void methodAbstract() &#123; &#125; @Override public void methodDefault() &#123; System.out.println(&quot;重写的默认方法&quot;); &#125; public static void main(String[] args) &#123; //接口中的静态方法只能由接口自己调用 MyInterface.methodStatic(); //可以调用默认方法 MyInterfaceImp imp = new MyInterfaceImp(); imp.methodDefault(); //无法调用私有方法，只能接口自己用 //imp.methodPrivate(); &#125;&#125; 钻石操作符使用升级 能够与匿名实现类共同使用钻石操作符(diamond operator) 在Java 8中如下的操作是会报错的: Java 9中如下操作可以正常执行通过: try语句 Java 8 中，可以实现资源的==自动关闭==，但是==要求执行后必须关闭的所有资源必须在try子句中初始化==，否则编译不通过。如下例所示： Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package lesson;import java.io.IOException;import java.io.InputStreamReader;/** * @author Justry * @Description * @date 2020-12-06 11:06 上午 */public class Java9Test &#123; public static void main(String[] args) &#123; //java 8之前的资源关闭操作 InputStreamReader reader = null; try &#123; reader = new InputStreamReader(System.in); char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //java 8中的资源关闭操作:自动关闭 //要求自动关闭的资源的初始化必须放在try的一对小括号中 try (InputStreamReader reader = new InputStreamReader(System.in)) &#123; char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //java 9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一对小括号外 //此时的资源属性是常量，声明为final，不可修改 InputStreamReader reader = new InputStreamReader(System.in); try (reader) &#123; char[] cbuf = new char[20]; int len; if ((len = reader.read(cbuf)) != -1) &#123; String str = new String(cbuf, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; String存储结构变更 String 再也不用 char[] 来存储，改成了 byte[] 加上编码标记，节约 了一些空间。 那StringBuffer 和 StringBuilder 是否仍无动于衷呢? 集合工厂方法：快速创建只读集合 以前要创建一个==只读、不可改变==的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。 Java 9因此引入了方便的方法，这使得类似的事情更容易表达。 调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的:在 创建后，继续添加元素到这些集合会导致“UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。 InputStream 加强 InputStream 终于有了一个非常有用的方法：==transferTo==，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。 增强的 Stream API Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。 在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法: takeWhile dropWhile, ofNullable iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。 takeWhile()的使用 用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，==takeWhile 返回从开头开始的尽量多的元素==。 123456789@Test public void test1() &#123; // takeWhile 返回从开头开始的按照指定规则尽量多的元素 List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list.stream().takeWhile(x -&gt; x &lt; 50).forEach(System.out::println); // 45 43 System.out.println(); list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); list.stream().takeWhile(x -&gt; x &lt; 5).forEach(System.out::println); // 1 2 3 4 &#125; dropWhile()的使用 dropWhile 的行为与 takeWhile 相反，返回剩余的元素。 12345678910@Test public void test2() &#123; List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88); list.stream().dropWhile(x -&gt; x &lt; 50).forEach(System.out::println); System.out.println(); list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); list.stream().dropWhile(x -&gt; x &lt; 5).forEach(System.out::println); &#125; ofNullable()的使用 Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。 123456789101112131415161718192021222324@Test public void test3() &#123; // 报NullPointerException，of()参数不能存储单个null值 // Stream&lt;Object&gt; stream1 = Stream.of(null); // System.out.println(stream1.count()); // 不报异常，允许通过 Stream&lt;String&gt; stringStream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, null); System.out.println(stringStream.count()); // 3 // 不报异常，允许通过 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;AA&quot;); list.add(null); System.out.println(list.stream().count()); // 2 // ofNullable():允许值为null Stream&lt;Object&gt; stream1 = Stream.ofNullable(null); System.out.println(stream1.count());// 0 Stream&lt;String&gt; stream = Stream.ofNullable(&quot;hello world&quot;); System.out.println(stream.count()); // 1 &#125; iterate()重载的使用 这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。 12345678@Test public void test4() &#123; // 原来的控制终止方式: Stream.iterate(1, i -&gt; i + 1).limit(10).forEach(System.out::println); // 现在的终止方式: Stream.iterate(1, i -&gt; i &lt; 100, i -&gt; i + 1).forEach(System.out::println); &#125; Optional获取Stream的方法 Optional类中stream()的使用 123456789101112@Test public void test6() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Tom&quot;); list.add(&quot;Jerry&quot;); list.add(&quot;Tim&quot;); Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list); Stream&lt;List&lt;String&gt;&gt; stream = optional.stream(); stream.flatMap(x -&gt; x.stream()).forEach(System.out::println); &#125; Javascript引擎升级：Nashorn Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。 Java 10 新特性局部变量类型推断 好处：减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！ 举例如下： 场景一：类实例化时：作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第 一次用于声明变量类型，第二次用于构造器。 1LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); 场景二：返回值类型含复杂泛型结构：变量的声明类型书写复杂且较长，尤其是加上泛型的使用 1Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator(); 场景三： 我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如： 1234URL url = new URL(&quot;http://www.atguigu.com&quot;);URLConnection connection = url.openConnection();Reader reader = new BufferedReader(newInputStreamReader(connection.getInputStream())); 适用于以下情况： 局部变量的初始化 1var list = new ArrayList&lt;&gt;(); 增强for循环中的索引 123for(var v : list) &#123;System.out.println(v);&#125; 传统for循环中 123for(var i = 0;i &lt; 100;i++) &#123;System.out.println(i);&#125; 在局部变量中使用时，如下情况不适用： 初始值为null Lambda表达式 方法引用 为数组静态初始化 不适用以下的结构中： ==工作原理== 在处理 var时，==编译器先是查看表达式右边部分==，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。 ==注 意== var不是一个关键字 这不是JavaScript，var并不会改变Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码： 集合新增创建不可变集合的方法 自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合。 示例1和2代码基本一致，为什么一个为true,一个为false? 结论：copyOf(Xxx coll)：如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前coll；如果参数coll不是只读集合，则copyOf返回一个新的只读集合，这个集合只读。 Java 11 新特性新增了一系列字符串处理方法 Optional 加强 可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。 123456789101112131415161718@Test public void test() &#123; Optional&lt;Object&gt; op = Optional.empty(); System.out.println(op.isPresent()); System.out.println(op.isEmpty()); op = Optional.of(&quot;abc&quot;); Object o = op.orElseThrow(); System.out.println(o); Optional&lt;String&gt; op1 = Optional.of(&quot;hello&quot;); // op = Optional.empty(); //or:value非空，返回对应的Optional；value为空，返回形参封装的Optional Optional&lt;Object&gt; op2 = op.or(() -&gt; op1); System.out.println(op2); &#125; 局部变量类型推断升级 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样=的语法。 12345678910@Test public void test2() &#123; //错误的形式: 必须要有类型, 可以加上var //Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase()); //正确的形式: //使用var的好处是在使用lambda表达式时给参数加上注解。 Consumer&lt;String&gt; con2 = (@Deprecated var t) -&gt; System.out.println(t.toUpperCase()); &#125; 全新的 HTTP 客户端 API 更简化的编译运行程序 ZGC 优势： GC暂停时间不会超过10ms 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG) 和G1相比, 应用吞吐能力不会下降超过15% 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础 初始只支持64位系统 ==ZGC的设计目标是==：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。 其它新特性","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十六章 Java8的其他新特性","slug":"第十六章 Java8的其他新特性","date":"2020-05-11T16:00:00.000Z","updated":"2020-12-10T13:19:01.501Z","comments":true,"path":"undefined/1e12.html","link":"","permalink":"https://asteroidcs.github.io/undefined/1e12.html","excerpt":"","text":"优点： 速度更快 代码更少(增加了新的语法:Lambda 表达式)  强大的 Stream API 便于并行 最大化减少空指针异常:Optional Nashorn引擎，允许在JVM上运行JS应用 并行流与串行流 并行流：就是把一个内容分成多个数据块，并用不同的线程分别处理每个数 据块的流。 相比较串行的流，并行的流可以很大程度上提高程序的执行效率。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流 之间进行切换 Lambda表达式为什么使用 Lambda 表达式1Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以 传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 从匿名类到 Lambda 的转换举例1 12345678910111213141516171819202122232425262728293031package lesson1;import org.junit.jupiter.api.Test;/** * @author Justry * @Description * @date 2020-12-02 11:02 上午 */public class LambdaTest &#123; @Test public void test1() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱吃红烧肉！&quot;); &#125; &#125;; runnable.run(); System.out.println(&quot;******************************&quot;); Runnable runnable1 = () -&gt; System.out.println(&quot;我爱喝排骨汤！&quot;); runnable1.run(); &#125;&#125; 从匿名类到 Lambda 的转换举例2 123456789101112131415161718192021@Test public void test2() &#123; Comparator&lt;Integer&gt; integerComparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125; &#125;; int compare = integerComparator.compare(12, 21); System.out.println(compare); System.out.println(&quot;******************************&quot;); Comparator&lt;Integer&gt; integerComparator1 = (o1, o2) -&gt; Integer.compare(o1, o2); //Comparator&lt;Integer&gt; integerComparator1 = Integer :: compare; int compare1 = integerComparator.compare(12, 21); System.out.println(compare1); &#125; Lambda 表达式：语法 Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分： 左侧:指定了 Lambda 表达式需要的参数列表（其实就是接口中的抽象方法的形参列表） 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。 Lambda 表达式的使用（分6种情况） 语法格式一:无参，无返回值 语法格式二：:Lambda 需要一个参数，但是没有返回值。 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 总结： 左边：Lambda形参列表的参数类型可以省略（类型推断），若Lambda形参列表只有一个参数，其中一对（）也可以省略 右边：Lambda体应该用一对{}包裹；如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return 类型推断​ 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序 的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于 上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。 函数式(Functional)接口什么是函数式(Functional)接口 只包含==一个抽象方法==的接口，称为==函数式接口==。 可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda 表达式抛出一个受检异常(即:非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。 可以在一个接口上使用 ==@FunctionalInterface==注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 在java.util.function包下定义了Java 8 的丰富的函数式接口 如何理解函数式接口 java 不但可以支持OOP还 可以支持OOF (面向函数编程) 在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。 在Java8中，==Lambda表达式就是一个函数式接口的实例==。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。 ==以前用匿名实现类表示的现在都可以用Lambda表达式来写。== Java 内置四大核心函数式接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package lesson1;import org.junit.jupiter.api.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;/** * @author Justry * @Description * @date 2020-12-02 11:57 上午 */public class LambdaTest1 &#123; @Test public void test1()&#123; happyTime(500, new Consumer&lt;Double&gt;() &#123; @Override public void accept(Double aDouble) &#123; System.out.println(&quot;购物花了&quot; + aDouble); &#125; &#125;); System.out.println(&quot;******************************&quot;); happyTime(400, money -&gt; System.out.println(&quot;购物花了&quot; + money)); &#125; public void happyTime(double money, Consumer&lt;Double&gt; consumer)&#123; consumer.accept(money); &#125; @Test public void test2()&#123; List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;, &quot;南京&quot;, &quot;天津&quot;, &quot;东京&quot;, &quot;西京&quot;); List&lt;String&gt; filterString = filterString(list, new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(&quot;京&quot;); &#125; &#125;); System.out.println(filterString); System.out.println(&quot;******************************&quot;); List&lt;String&gt; filterString1 = filterString(list, s -&gt; s.contains(&quot;京&quot;)); System.out.println(filterString1); &#125; //根据给定规则，过滤集合中的字符串。此规则由Predicate的方法决定 public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;(); for (String s : list)&#123; if (pre.test(s))&#123; filterList.add(s); &#125; &#125; return filterList; &#125;&#125; 方法引用与构造器引用方法引用(Method References) 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用! 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。 ==要求==：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致! ==格式==：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。 如下三种主要使用情况： 对象：：实例方法名 类：：静态方法名 类：：实例方法名 ==注意==：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时:ClassName::methodName 1234567891011121314//情况三：类：：实例方法 //Comparator中的int compare(T t1, T t2) //String中的int t1.compareTo(t2) @Test public void test2()&#123; Comparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.compareTo(s2); System.out.println(comparator.compare(&quot;abc&quot;, &quot;abd&quot;)); System.out.println(&quot;**************************************&quot;); Comparator&lt;String&gt; comparator1 = String::compareTo; System.out.println(comparator1.compare(&quot;abc&quot;, &quot;abm&quot;)); &#125; 构造器引用 格式:：ClassName：：new 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型 数组引用 格式: type[] :: new 可以把数组看作是一个特殊的类，则写法与构造器引用一致 Stream API Java8中有两大最为重要的改变。第一个是：Lambda 表达式，另外一个则是：Stream API。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。 为什么要使用Stream API 实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。 Stream 和 Collection 集合的区别： Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。 前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。 什么是 Stream 数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。 “集合讲的是数据，Stream讲的是计算！” 注意： Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream 的操作三个步骤 步骤： 创建 Stream：一个数据源(如:集合、数组)，获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 创建 Stream方式 方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流 的方法: 方式二：通过数组 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流: 12345678910public class StreamAPITest &#123; @Test public void test1() &#123; int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; IntStream stream = Arrays.stream(arr); &#125;&#125; 方式三:通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。 12345@Test public void test2() &#123; Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6); &#125; 方式四：创建无限流（用的较少，了解即可） 12345678@Test public void test3() &#123; // 遍历前10个偶数 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out :: println); Stream.generate(Math::random).limit(10).forEach(System.out :: println); &#125; Stream 的中间操作​ 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则==中间操作不会执行任何的处理!而在终止操作时一次性全 部处理，称为“惰性求值”== 筛选与切片 映 射 123456@Test public void test1() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;); list.stream().map(str -&gt; str.toCharArray()).forEach(System.out::println); &#125; 排序 Stream 的终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如:List、Integer，甚至是 void 。 流进行了终止操作后，不能再次使用。 匹配与查找 归约 123456@Test public void test1() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list.stream().reduce(0, Integer::sum); System.out.println(sum); &#125; 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名 收集 ​ Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map) Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表： Optional类 Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 Optional类的Javadoc描述如下:这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 创建Optional类对象的方法: 判断Optional容器中是否包含对象： 获取Optional容器的对象: 12345678910111213@Test public void test1() &#123; Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); // 如果女朋友存在就打印女朋友的信息 opt.ifPresent(System.out::println); &#125; @Test public void test2() &#123; Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); // 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了 Girl girl = opt.orElse(new Girl(&quot;嫦娥&quot;)); System.out.println(&quot;他的女朋友是:&quot; + girl.getName()); &#125; 123456789101112131415@Test public void test3() &#123; Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888)); //判断opt中员工对象是否满足条件，如果满足就保留，否则返回空 Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000); System.out.println(emp); &#125; @Test public void test4() &#123; Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888)); //如果opt中员工对象不为空，就涨薪10% Optional&lt;Employee&gt; emp = opt.map(e -&gt; &#123; e.setSalary(e.getSalary() % 1.1); return e; &#125;); System.out.println(emp); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]},{"title":"第十五章 反射机制","slug":"第十五章 反射","date":"2020-01-11T16:00:00.000Z","updated":"2020-12-10T13:18:38.276Z","comments":true,"path":"undefined/a7d1.html","link":"","permalink":"https://asteroidcs.github.io/undefined/a7d1.html","excerpt":"","text":"重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构概述Java Reflection Reflection(反射)**是被视为$\\color{red}{动态语言}$**的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 补充：动态语言 vs 静态语言 动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。 Java不是动态语言，但Java可以称之为$\\color{yellow}{“准动态语言”}$。即Java有一定的动态性，可以利用$\\color{red}{反射机制、字节码操作}$获得类似动态语言的特性。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。 $\\color{red}{我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，故形象的称之为：反射}$ Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射相关的主要API java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 举例Person1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package lesson;/** * @author Justry * @Description * @date 2020-12-01 12:00 下午 */public class Person &#123; public int age; private String name; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; private Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show() &#123; System.out.println(&quot;你好，我是一个人！&quot;); &#125; private String showNation(String nation) &#123; System.out.println(&quot;我的国籍是：&quot; + nation); return nation; &#125;&#125; 反射前对于类的操作12345678910111213141516//反射前对于类的操作@Testpublic void test1() &#123; //1.创建Person类的实例化 Person p1 = new Person(&quot;Tom&quot;, 12); //2.通过对象，调用其内部的属性、方法 p1.age = 10; System.out.println(p1); p1.show(); //在Person类的外部，不可以通过Person类的对象调用其内部私有结构&#125; 反射后对于类的操作123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; Class&lt;Person&gt; personClass = Person.class; //1.通过反射，创建Person类的对象 Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); Person person = constructor.newInstance(&quot;Tom&quot;, 12); System.out.println(person); //2.通过反射，调用对象指定的属性、方法 //调属性 Field age = personClass.getDeclaredField(&quot;age&quot;); age.set(person, 10); System.out.println(person); //调方法 Method show = personClass.getDeclaredMethod(&quot;show&quot;); show.invoke(person); System.out.println(&quot;*************************************************&quot;); //通过反射，可以调用Person类的私有结构。如：私有的构造器、方法、属性 //调用私有的构造器 Constructor&lt;Person&gt; constructor1 = personClass.getDeclaredConstructor(String.class); constructor1.setAccessible(true); Person person1 = constructor1.newInstance(&quot;Jerry&quot;); System.out.println(person1); //调用私有的属性 Field name = personClass.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(person1, &quot;Tom&quot;); System.out.println(person1); //调用私有的方法 Method showNation = personClass.getDeclaredMethod(&quot;showNation&quot;, String.class); showNation.setAccessible(true); Object nation = showNation.invoke(person1, &quot;中国&quot;);// 相当于p1.showNation(&quot;中国&quot;） System.out.println(nation); &#125; 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？12建议直接用new的方式//什么时候用：放射的方式。————&gt; 反射的特征：动态性 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？理解Class类 并 获取Class的实例Class 类 类的加载过程 程序经过Java.exe命令以后，会生成一个或多个字节码文件(.class结尾) 接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存。此过程就称为类的加载。加载到内存中的类，就称为运行时的类，此时运行时的类就作为C lass的一个实例 换句话说，Class的实例就对应着一个运行时类 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 在Object类中定义了以下的方法，此方法将被所有子类继承 public final Class getClass() 以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class类的常用方法 获取Class类的实例(四种方法) 前提:若已知具体的类，通过类的class属性获取，该方法最为安全可靠， 程序性能最高 1Class clazz = String.class; 前提:已知某个类的实例，调用该实例的getClass()方法获取Class对象 1Class clazz = “www.atguigu.com”.getClass(); 前提:已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException 1Class clazz = Class.forName(“java.lang.String”) 其他方式(不做要求) 1ClassLoader cl = this.getClass().getClassLoader(); Class clazz4 = cl.loadClass(“类的全类名”); 12345678910111213141516171819202122//获取Class的实例方式 @Test public void test3() throws ClassNotFoundException &#123; //方式一：调用运行时类的属性：.class Class clazz1 = Person.class; System.out.println(clazz1); // class lesson.Person //方式二：通过运行时类的对象 Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); // class lesson.Person //方式三：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(&quot;lesson.Person&quot;); System.out.println(clazz3); // class lesson.Person //方式四：使用类的加载器：ClassLoader ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;lesson.Person&quot;); System.out.println(clazz4); // class lesson.Person &#125; 哪些类型可以有Class对象? 12345678Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = int.class;Class c8 = void.class;Class c9 = Class.class;int[] a = new int[10];int[] b = new int[100];Class c10 = a.getClass();Class c11 = b.getClass();// 只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11); 类的加载 与 ClassLoader的理解类的加载过程（了解）​ 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据$\\color{yellow}{转换成方法区的运行时数据结构}$，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象 ClassLoader(了解) 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。 创建运行时类的对象有了Class对象，能做什么? 创建类的对象：调用Class对象的newInstance()方法。要求： 类必须有一个无参数的构造器。 类的构造器的访问权限需要足够，通常设置为public 1234567891011121314public class NewInstanceTest &#123; @Test public void test1() throws IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; /* newInstance():调用此方法，创建对应的运行时类的对象 */ Person obj = clazz.newInstance(); System.out.println(obj); &#125;&#125; 在javabean中要求提供一个public的空参构造器。原因： 便于通过反射，创建运行时类的对象 便于子类继承次运行时类时，默认调用super()时，保证父类有此构造器 难道没有无参的构造器就不能创建对象了吗? ————&gt; NO，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下: 通过Class类的$\\color{red}{getDeclaredConstructor(Class … parameterTypes)}$取得本类的指定形参类 型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象。 1234567891011121314151617181920212223242526272829303132333435363738//体现反射的动态性@Test public void test2()&#123; int num = new Random().nextInt(3); String classPath = &quot;&quot;; switch (num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;lesson.Person&quot;; break; &#125; try &#123; Object instance = getInstance(classPath); System.out.println(instance); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; /* 创建一个指定类的对象 */ public Object getInstance(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName(classPath); return clazz.newInstance(); &#125;&#125; 获取运行时类的完整结构 使用反射可以取得: 实现的全部接口：确定此对象所表示的类或接口实现的接口。 1public Class&lt;?&gt;[] getInterfaces() 所继承的父类：返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class 1public Class&lt;? Super T&gt; getSuperclass() 全部的构造器 返回此 Class 对象所表示的类的所有public构造方法。 1public Constructor&lt;T&gt;[] getConstructors() 返回此 Class 对象表示的类声明的所有构造方法。 1public Constructor&lt;T&gt;[] getDeclaredConstructors() Constructor类中: 取得修饰符: 1public int getModifiers(); 取得方法名称: 1public String getName(); 取得参数的类型: 1public Class&lt;?&gt;[] getParameterTypes(); 全部的方法 返回此Class对象所表示的类或接口的全部方法 1public Method[] getDeclaredMethods() 返回此Class对象所表示的类或接口的public的方法 1public Method[] getMethods() Method类中: 取得全部的返回值 1public Class&lt;?&gt; getReturnType() 取得全部的参数 1public Class&lt;?&gt;[] getParameterTypes() 取得修饰符 1public int getModifiers() 取得异常信息 1public Class&lt;?&gt;[] getExceptionTypes() 全部的Field 返回此Class对象所表示的类或接口的public的Field。 1public Field[] getFields() 返回此Class对象所表示的类或接口的全部Field。 1public Field[] getDeclaredFields() Field方法中: 以整数形式返回此Field的修饰符 1public int getModifiers() 得到Field的属性类型 1public Class&lt;?&gt; getType() 返回Field的名称。 1public String getName() 1234567891011121314151617181920212223242526272829303132333435363738394041public class FieldTest &#123; @Test public void test1()&#123; Class&lt;Person&gt; clazz = Person.class; //获取属性结构： //getFields():能够获取当前运行时类及其所有父类当中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields)&#123; System.out.println(f); &#125; System.out.println(&quot;***************************************&quot;); //getDeclaredFields():获取当前运行时类中声明的所有属性，不包含父类中声明的属性 Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; System.out.println(f); &#125; &#125; @Test public void test2()&#123; Class&lt;Person&gt; clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; //1.权限修饰符 int modifier = f.getModifiers(); System.out.print(Modifier.toString(modifier) + &quot;\\t&quot;); //2.数据类型 Class&lt;?&gt; type = f.getType(); System.out.print(type.getName() + &quot;\\t&quot;); //3.变量名 String name = f.getName(); System.out.println(name); &#125; &#125;&#125; Annotation相关 12get Annotation(Class&lt;T&gt; annotationClass) getDeclaredAnnotations() 泛型相关 获取父类泛型类型 1Type getGenericSuperclass() 泛型类型 1ParameterizedType 获取实际的泛型类型参数数组 1getActualTypeArguments() 类所在的包 1Package getPackage() 总结： 在实际的操作中，取得类的信息的操作代码，并不会经常开发。 一定要熟悉java.lang.reflect包的作用，反射机制。 如何取得属性、方法、构造器的名称，修饰符等。 调用运行时类的指定结构调用指定方法​ 通过反射，调用类中的方法，通过Method类完成。步骤: 通过Class类的 ==getMethod(String name,Class…parameterTypes)== 方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用 ==Object invoke(Object obj, Object[] args)== 进行调用，并向方法中 传递要设置的obj对象的参数信息。 Object invoke(Object obj, Object … args)，说明： Object 对应原方法的返回值，若原方法无返回值，此时返回null 若原方法若为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args为null 若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ReflectionTest &#123; @Test public void testField() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; //创建运行时类的对象 Person person = clazz.newInstance(); //获取指定属性 Field id = clazz.getField(&quot;id&quot;); id.set(person, 1001); Object o = id.get(person); System.out.println(o); System.out.println(person); Field age = clazz.getDeclaredField(&quot;age&quot;); age.setAccessible(true); age.set(person, 18); Object o1 = age.get(person); System.out.println(o1); System.out.println(person); &#125; @Test public void testMethod() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;Person&gt; clazz = Person.class; // 创建运行时类的对象 Person person = clazz.newInstance(); // 获取指定的某个方法 //getDeclaredMethod(): 参数1：指明获取的方法的名称 参数2：指明获取的方法形参列表 Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); //保证当前方法时可访问的 show.setAccessible(true); //调用invoke()方法：参数1：方法的调用者 参数2：给方法形参赋值的实参 //invoke()的返回值即为对应类中调用的方法的返回值 Object o = show.invoke(person, &quot;中国&quot;); System.out.println(o); System.out.println(&quot;*************调用静态方法***************&quot;); Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); showDesc.invoke(null); &#125;&#125; 调用指定属性​ 在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。 关于setAccessible方法的使用 1234567891011121314151617181920212223242526public class ReflectionTest &#123; @Test public void testField() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; //创建运行时类的对象 Person person = clazz.newInstance(); //获取指定属性 Field id = clazz.getField(&quot;id&quot;); id.set(person, 1001); Object o = id.get(person); System.out.println(o); System.out.println(person); Field age = clazz.getDeclaredField(&quot;age&quot;); age.setAccessible(true); age.set(person, 18); Object o1 = age.get(person); System.out.println(o1); System.out.println(person); &#125;&#125; 反射的应用：动态代理 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上 静态代理：特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package lesson;/** * @author Justry * @Description 静态代理 * @date 2020-12-02 9:20 上午 */interface ClothFactory &#123; void produceCloth();&#125;//代理类class ProxyClothFactory implements ClothFactory &#123; private final ClothFactory factory; // 用被代理的对象进行实例化 public ProxyClothFactory(ClothFactory factory) &#123; this.factory = factory; &#125; @Override public void produceCloth() &#123; System.out.println(&quot;代理工厂做一些准备工作&quot;); factory.produceCloth(); System.out.println(&quot;代理工厂做一些后续的收尾工作&quot;); &#125;&#125;//被代理类class NikeClothFactory implements ClothFactory&#123; @Override public void produceCloth() &#123; System.out.println(&quot;Nike工厂生产一批运动服&quot;); &#125;&#125;public class StaticProxyTest &#123; public static void main(String[] args) &#123; //创建被代理类的对象 NikeClothFactory nike = new NikeClothFactory(); //创建代理类的对象 ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); proxyClothFactory.produceCloth(); &#125;&#125; 动态代理：是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理使用场合： 调试 远程方法调用 动态代理相比于静态代理的优点： 抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。 Java动态代理相关API Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。 供用于创建动态代理类和动态代理对象的静态方法 创建一个动态代理类所对应的Class对象 1static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 直接创建一个动态代理对象 1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h) 动态代理步骤 创建一个实现接口. InvocationHandler. 的类，它必须实现invoke方法，以完成代理的具体操作。 创建被代理的类以及接口 通过Proxy的静态方法 通过 Subject代理调用RealSubject实现类的方法 栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package lesson;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author Justry * @Description 动态代理的举例 * @date 2020-12-02 9:30 上午 */interface Human &#123; void getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human &#123; @Override public void getBelief() &#123; System.out.println(&quot;I believe I can fly!&quot;); &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法 */class ProxyFactory &#123; //调用此方法返回一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; // obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj; // 赋值时，需要使用被代理类的对象进行赋值 public void bind(Object obj) &#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj, args); // 反射 //上述方法的返回值就作为当前类中invoke(）的返回值 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance：代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法 proxyInstance.getBelief(); proxyInstance.eat(&quot;麻辣香锅&quot;); System.out.println(&quot;**************************************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125; 动态代理与AOP(Aspect Orient Programming) 前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制 改进后的说明:代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和 一个特定的方法A耦合了!最理想的效果是:代码块1、2、3既可以执行方法A，又无须在程序 中以硬编码的方式直接调用深色代码的方法 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异: ==AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package lesson;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author Justry * @Description 动态代理的举例 * @date 2020-12-02 9:30 上午 */interface Human &#123; void getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human &#123; @Override public void getBelief() &#123; System.out.println(&quot;I believe I can fly!&quot;); &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;class HumanUtil &#123; public void method1() &#123; System.out.println(&quot;===================通用方法一===================&quot;); &#125; public void method2() &#123; System.out.println(&quot;===================通用方法二===================&quot;); &#125;&#125;/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法 */class ProxyFactory &#123; //调用此方法返回一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; // obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj; // 赋值时，需要使用被代理类的对象进行赋值 public void bind(Object obj) &#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj, args); // 反射 util.method2(); //上述方法的返回值就作为当前类中invoke(）的返回值 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance：代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法 proxyInstance.getBelief(); proxyInstance.eat(&quot;麻辣香锅&quot;); System.out.println(&quot;***********************************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"},{"name":"game","slug":"Java/game","permalink":"https://asteroidcs.github.io/categories/Java/game/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://asteroidcs.github.io/tags/Java/"},{"name":"游戏","slug":"游戏","permalink":"https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"}]}