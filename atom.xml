<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asteroid</title>
  
  
  <link href="https://asteroidcs.github.io/atom.xml" rel="self"/>
  
  <link href="https://asteroidcs.github.io/"/>
  <updated>2020-12-01T01:41:42.240Z</updated>
  <id>https://asteroidcs.github.io/</id>
  
  <author>
    <name>Komorebi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十四章 网络编程</title>
    <link href="https://asteroidcs.github.io/undefined/ce7e.html"/>
    <id>https://asteroidcs.github.io/undefined/ce7e.html</id>
    <published>2020-11-30T04:25:18.289Z</published>
    <updated>2020-12-01T01:41:42.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>​    把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。</p><h4 id="网络编程的目的"><a href="#网络编程的目的" class="headerlink" title="网络编程的目的"></a>网络编程的目的</h4><p>​    直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</p><h4 id="网络编程中有两个主要的问题"><a href="#网络编程中有两个主要的问题" class="headerlink" title="网络编程中有两个主要的问题"></a>网络编程中有两个主要的问题</h4><ol><li>如何准确地定位网络上一台或多台主机;定位主机上的特定的应用</li><li>找到主机后如何可靠高效地进行数据传输</li></ol><h3 id="网络通信要素概述"><a href="#网络通信要素概述" class="headerlink" title="网络通信要素概述"></a>网络通信要素概述</h3><h4 id="如何实现网络中的主机互相通信"><a href="#如何实现网络中的主机互相通信" class="headerlink" title="如何实现网络中的主机互相通信"></a>如何实现网络中的主机互相通信</h4><ol><li>通信双方地址<ul><li>IP</li><li>端口号</li></ul></li><li>一定的规则(即:网络通信协议。有两套参考模型)<ul><li>OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广</li><li>==TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。==</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130123705011.png" alt="image-20201130123705011" style="zoom:50%;" /><ol start="3"><li>数据传输视图</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130124223380.png" alt="image-20201130124223380" style="zoom:50%;" /><h3 id="通信要素1-IP和端口号"><a href="#通信要素1-IP和端口号" class="headerlink" title="==通信要素1: IP和端口号=="></a>==通信要素1: IP和端口号==</h3><h4 id="IP-地址-InetAddress"><a href="#IP-地址-InetAddress" class="headerlink" title="IP 地址:InetAddress"></a>IP 地址:InetAddress</h4><ol><li>唯一的标识 Internet 上的计算机(通信实体)</li><li>本地回环地址(hostAddress):127.0.0.1 主机名(hostName):localhost</li><li>IP地址分类方式1:IPV4 和 IPV6<ul><li>PV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1</li><li>IPV6:128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li></ul></li><li>IP地址分类方式2:==公网地址(万维网使用)==和==私有地址(局域网使用)==。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</li><li>特点:不易记忆</li></ol><h4 id="端口号-：标识正在计算机上运行的进程-程序"><a href="#端口号-：标识正在计算机上运行的进程-程序" class="headerlink" title="==端口号==：标识正在计算机上运行的进程(程序)"></a>==端口号==：标识正在计算机上运行的进程(程序)</h4><ol><li>==不同的进程有不同的端口号==</li><li>被规定为一个 16 位的整数 0~65535</li><li>端口分类:<ul><li>公认端口:0~1023。被预先定义的服务通信占用(如:HTTP占用端口 80，FTP占用端口21，Telnet占用端口23)</li><li>注册端口:1024~49151。分配给用户进程或应用程序。(如:Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等)</li><li>动态/私有端口:49152~65535</li></ul></li></ol><h4 id="端口号与IP地址的组合得出一个网络套接字：Socket。"><a href="#端口号与IP地址的组合得出一个网络套接字：Socket。" class="headerlink" title="==端口号与IP地址的组合得出一个网络套接字：Socket。=="></a>==端口号与IP地址的组合得出一个网络套接字：Socket。==</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130125026273.png" alt="image-20201130125026273" style="zoom:50%;" /><h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><ol><li>Internet上的主机有两种方式表示地址:<ul><li>域名(hostName): <a href="http://www.atguigu.com/">www.atguigu.com</a></li><li>P 地址(hostAddress): 202.108.35.210</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternetAddressTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br><span class="line">            System.out.println(address);  <span class="comment">// www.atguigu.com/58.215.145.106</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>InetAddress类主要表示IP地址，两个子类:Inet4Address、Inet6Address</li><li>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: <a href="http://www.atguigu.com/">www.atguigu.com</a> 和 202.108.35.210</li><li>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS) 负责将域名转化成IP地址，这样才能和主机建立连接。———==域名解析==</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130125809486.png" alt="image-20201130125809486" style="zoom: 50%;" /><ol start="4"><li>InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例<ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByName(String host)</li></ul></li><li>InetAddress提供了如下几个常用的方法<ul><li>public String getHostAddress(): 返回 IP 地址字符串(以文本表现形式)</li><li>public String getHostName(): 获取此 IP 地址的主机名</li><li>public boolean isReachable(int timeout): 测试是否可以达到该地址</li></ul></li></ol><h3 id="通信要素2：网络协议"><a href="#通信要素2：网络协议" class="headerlink" title="==通信要素2：网络协议=="></a>==通信要素2：网络协议==</h3><ol><li><p>网络通信协议</p><p>​    计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代 码结构、传输控制步骤、出错控制等制定标准。</p></li><li><p>问题:网络协议太复杂</p><p>​    计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩，解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢?</p></li><li><p>通信协议分层的思想</p><p>​    在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</p></li></ol><h4 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP/IP协议簇"></a>TCP/IP协议簇</h4><ol><li><p>传输层协议中有两个非常重要的协议:</p><ul><li>传输控制协议TCP(Transmission Control Protocol)</li><li>用户数据报协议UDP(User Datagram Protocol)</li></ul></li><li><p>==TCP/IP 以其两个主要协议==：==传输控制协议(TCP)==和==网络互联协议(IP)==而得 名，实际上是一组协议，包括多个具有不同功能且互为关联的协议</p></li><li><p>==IP(Internet Protocol)协议==是网络层的主要协议，支持网间互连的数据通信</p></li><li><p>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理链路层==、==IP层==、==传输层==和==应用层==。</p></li></ol><h4 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h4><ol><li><p>TCP协议:</p><ul><li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li><li>传输前，采用==“三次握手”==方式，点对点通信，==是可靠的==</li><li>TCP协议进行通信的两个应用进程:客户端、服务端。</li><li>在连接中可==进行大数据量的传输==</li><li>传输完毕，==需释放已建立的连接，效率低==</li></ul></li><li><p>UDP协议:</p><ul><li>将数据、源、目的封装成数据包，==不需要建立连接==</li><li>每个数据报的大小限制在64K内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的  可以广播发送</li><li>发送数据结束时==无需释放资源，开销小，速度快==</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130131804507.png" alt="image-20201130131804507" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130131838776.png" alt="image-20201130131838776" style="zoom:50%;" /><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><ol><li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。</li><li>==网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字==</li><li>通信的两端都要有Socket，是两台机器间通信的端点。 </li><li>网络通信其实就是Socket间的通信。</li><li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。  一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</li><li>Socket分类:<ul><li>流套接字(stream socket):使用TCP提供可依赖的字节流服务 </li><li>数据报套接字(datagram socket):使用UDP提供“尽力而为”的数据报服务</li></ul></li></ol><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><h4 id="基于Socket的TCP编程"><a href="#基于Socket的TCP编程" class="headerlink" title="基于Socket的TCP编程"></a>基于Socket的TCP编程</h4><ol><li>Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模 型如图所示</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140123191.png" alt="image-20201130140123191" style="zoom:50%;" /><ol start="2"><li>==客户端Socket的工作过程包含以下四个基本的步骤:==<ul><li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket 的输入/出流:：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 (但不能读取自己放入线路的信息)，通过输出流将信息写入线程。</li><li>关闭 Socket:：断开客户端到服务器的连接，释放线路</li></ul></li><li>==服务器程序的工作过程包含以下四个基本的步骤:==<ul><li>调用 ServerSocket(int port) :创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept():监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。</li><li>调用 该Socket类对象的 getOutputStream() 和 getInputStream ():获取输出 流和输入流，开始网络数据的发送和接收。</li><li>关闭ServerSocket和Socket对象:客户端访问结束，关闭通信套接字</li></ul></li></ol><h4 id="客户端创建Socket对象"><a href="#客户端创建Socket对象" class="headerlink" title="客户端创建Socket对象"></a>客户端创建Socket对象</h4><ol><li>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是:<ul><li>Socket(String host,int port)throws UnknownHostException,IOException:向服务器(域名是 host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li><li>Socket(InetAddress address,int port)throws IOException:根据InetAddress对象所表示的 IP地址以及端口号port发起连接。</li></ul></li><li>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140600249.png" alt="image-20201130140600249" style="zoom:67%;" /><h4 id="服务器建立-ServerSocket-对象"><a href="#服务器建立-ServerSocket-对象" class="headerlink" title="服务器建立 ServerSocket 对象"></a>服务器建立 ServerSocket 对象</h4><ol><li>erverSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。</li><li>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140912034.png" alt="image-20201130140912034" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130142653444.png" alt="image-20201130142653444" style="zoom:50%;" /><h4 id="例题1：客户端发送内容给服务端，服务端将内容打印到控制台上"><a href="#例题1：客户端发送内容给服务端，服务端将内容打印到控制台上" class="headerlink" title="例题1：客户端发送内容给服务端，服务端将内容打印到控制台上"></a>例题1：客户端发送内容给服务端，服务端将内容打印到控制台上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 实现TCP的网络编程：客户端发送信息给服务器，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-30 1:38 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(localHost, <span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2：客户端发送文件给服务端，服务端将文件保存在本地"><a href="#例题2：客户端发送文件给服务端，服务端将文件保存在本地" class="headerlink" title="例题2：客户端发送文件给服务端，服务端将文件保存在本地"></a>例题2：客户端发送文件给服务端，服务端将文件保存在本地</h4><p>例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给 客户端。并关闭相应的连接。</p><h4 id="练习1：服务端读取图片并发送给客户端，客户端保存图片到本地"><a href="#练习1：服务端读取图片并发送给客户端，客户端保存图片到本地" class="headerlink" title="练习1：服务端读取图片并发送给客户端，客户端保存图片到本地"></a>练习1：服务端读取图片并发送给客户端，客户端保存图片到本地</h4><h4 id="练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"><a href="#练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端" class="headerlink" title="练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"></a>练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端</h4><h3 id="客户端—服务端"><a href="#客户端—服务端" class="headerlink" title="客户端—服务端"></a>客户端—服务端</h3><ol><li>客户端:<ul><li>自定义 </li><li>浏览器</li></ul></li><li>服务端:<ul><li>自定义</li><li>Tomcat服务器</li></ul></li></ol><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><ol><li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</li><li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，==系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达==。</li><li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。</li><li>==UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样==。</li><li>常用方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130150126474.png" alt="image-20201130150126474" style="zoom:50%;" /><h4 id="UDP网络通信"><a href="#UDP网络通信" class="headerlink" title="UDP网络通信"></a>UDP网络通信</h4><ol><li>流程<ul><li>DatagramSocket与DatagramPacket</li><li>建立发送端，接收端</li><li>建立数据包</li><li>调用Socket的发送、接收方法 5. 关闭Socket</li></ul></li><li>发送端与接收端是两个独立的运行程序</li><li>例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-30 2:46 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">        InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, <span class="number">0</span>, data.length, localHost, <span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><ol><li><p>URL(Uniform Resource Locator):统一资源定位符，它表示 Internet 上某一 资源的地址</p></li><li><p>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate 这个资源</p></li><li><p>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。</p></li><li><p>URL的基本结构由5部分组成:</p><p>==&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表==</p><ul><li><p>例如: <a href="http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</a></p></li><li><p>#片段名:即锚点，例如看小说，直接定位到章节</p></li><li><p>参数列表格式:参数名=参数值&amp;参数名=参数值….</p></li></ul></li><li><p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象:</p></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130151447169.png" alt="image-20201130151447169" style="zoom:50%;" /><ol start="6"><li>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。</li><li>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的 方法来获取这些属性:</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130151611370.png" alt="image-20201130151611370" style="zoom:50%;" /><h4 id="针对HTTP协议的URLConnection类"><a href="#针对HTTP协议的URLConnection类" class="headerlink" title="针对HTTP协议的URLConnection类"></a>针对HTTP协议的URLConnection类</h4><ol><li>==URL的方法 openStream():能从网络上读取数据==</li><li>若希望输出数据，例如向服务器端的 CGI (公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口)程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</li><li>URLConnection:表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException.<ul><li>URL netchinaren = new URL (“<a href="http://www.atguigu.com/index.shtml&quot;">http://www.atguigu.com/index.shtml&quot;</a>); </li><li>URLConnectonn u = netchinaren.openConnection( );</li></ul></li><li>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201130151829726.png" alt="20201130151829726" style="zoom:50%;" /><h3 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="==URI、URL和URN的区别=="></a>==URI、URL和URN的区别==</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net<span class="meta">@java</span>.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。</span><br><span class="line">在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h3><ul><li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li><li>==客户端-服务器==是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。==端口号== 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。==套接字==用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。</li><li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段:主机名(String) 和 IP 地址(int)。</li><li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端-服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。</li><li>类 URL 和 URLConnection 提供了最 高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; title=&quot;网络基础&quot;&gt;&lt;/a&gt;网络基础&lt;/h3&gt;&lt;h4 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十三章 IO流</title>
    <link href="https://asteroidcs.github.io/undefined/4554.html"/>
    <id>https://asteroidcs.github.io/undefined/4554.html</id>
    <published>2020-11-28T12:25:50.563Z</published>
    <updated>2020-12-02T02:40:18.689Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重点掌握-：节点流、缓冲流、转换流、对象流"><a href="#重点掌握-：节点流、缓冲流、转换流、对象流" class="headerlink" title="==重点掌握==：节点流、缓冲流、转换流、对象流"></a>==重点掌握==：节点流、缓冲流、转换流、对象流</h4><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><p>File类的一个对象，==代表一个文件或一个文件目录==（俗称：文件夹）</p></li><li><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。</p></li><li><p>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是==Java程序中的一个File对象，可能没有一个真实存在的文件或目录==</p></li><li><p>File对象可以作为参数传递给流的构造器</p></li><li><p>==File类不涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流==</p><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点“</p></li></ol><h3 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a><strong>路径分隔符</strong></h3><ul><li><p>路径中的每级目录之间用一个路径分隔符隔开。</p></li><li><p>==路径分隔符和系统有关==：</p><p>①windows和DOS系统默认使用“\”来表示</p><p>②UNIX和URL使用“/”来表示</p></li><li><p>Java程序支持跨平台运行，因此路径分隔符要慎用，为了解决这个隐患，File类提供了一个常量：</p><p>==public static final String separator。根据操作系统，动态的提供分隔符==</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118164027.png" alt="20201118164027" style="zoom:50%;" /><h3 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h3><ol><li>==public File(String pathname)==：以pathname为路径创建对象(绝对路径或相对路径)，==相对路径默认当前路径为系统属性user.dir==。<ul><li>IDEA中：<ul><li>如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下；</li><li>如果使用main()测试，相对路径即为当前的Project下。</li></ul></li><li>Eclipse中：<br>不管是单元测试方法还是main()测试，相对路径都是当前的Project下。</li></ul></li><li>==public File(String parent,String child)==：以parent为父路径，child为子路径创建File对象。</li><li>==public File(File parent,String child)==：根据一个父File对象和子文件路径创建File对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器的使用</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器1：</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior&quot;</span>);</span><br><span class="line">        System.out.println(file1);</span><br><span class="line">        System.out.println(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器2：</span></span><br><span class="line">        File file3 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\workspace_idea1&quot;</span>, <span class="string">&quot;JavaSenior&quot;</span>);</span><br><span class="line">        System.out.println(file1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器3：</span></span><br><span class="line">        File file4 = <span class="keyword">new</span> File(file3, <span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        System.out.println(file4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li><p><strong>File类的获取功能：</strong></p><ul><li>public String getAbsolutePath()：获取绝对路径</li><li>public String getPath()：获取路径</li><li>public String getName() ：获取名称</li><li>public String getParent()：获取上层文件目录路径。若无，返回null</li><li>public long length() ：获取文件长度（即：字节数）。不能获取目录的长度</li><li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;\\Users\\i-mamba\\Desktop\\IO\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file1.getAbsoluteFile()); <span class="comment">// /Users/i-mamba/程序员技能学习/Java/Java基础入门/code/IDEA-workspace/JavaSenior/day08/Hello.txt</span></span><br><span class="line">        System.out.println(file1.getPath()); <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file1.getName()); <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file1.getParent());  <span class="comment">// null</span></span><br><span class="line">        System.out.println(file1.length());  <span class="comment">// 12</span></span><br><span class="line">        System.out.println(file1.lastModified());  <span class="comment">// 1606614159235</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(file1.lastModified()));  <span class="comment">// Sun Nov 29 09:42:39 CST 2020</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>下面两方法适用于文件目录：<ul><li>public String[] list()：获取指定目录下的所有文件或者文件目录的==名称==数组</li><li>public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File路径数组</li></ul></li></ul></li><li><p><strong>File类的重命名功能</strong></p><ul><li><p>public boolean renameTo(File dest)：把文件重命名为指定的文件路径</p><p>比如file1.renameTo(file2)，要保证返回true，==需要file1在硬盘中存在且file2在硬盘中不存在==。修改可包括路径和文件内容。</p></li></ul></li><li><p><strong>File类的判断功能</strong></p><ul><li>public boolean isDirectory()：判断是否是文件目录</li><li>public boolean isFile()：判断是否是文件</li><li>public boolean exists()：判断是否存在</li><li>public boolean canRead()：判断是否可读</li><li>public boolean canWrite()：判断是否可写</li><li>public boolean isHidden()：判断是否隐藏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/i-mamba/程序员技能学习&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file.isDirectory());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isFile());  <span class="comment">// false</span></span><br><span class="line">        System.out.println(file.exists());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.canRead());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.canWrite());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isHidden());  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>File类的创建功能</strong></p><ul><li>public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false</li><li>public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li><li>public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建——&gt; 创建多层文件目录</li></ul><ul><li>==注意事项==：如果你创建文件或者文件目录没有写盘符路径，那么默认在项目路径下。</li></ul></li><li><p><strong>File类的删除功能</strong></p><ul><li>public boolean delete()：删除文件或者文件夹</li><li>删除注意事项：<ul><li>==Java中的删除不走回收站==；</li><li>==要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录==</li></ul></li></ul></li></ol><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 利用File构造器，<span class="keyword">new</span> 一个文件目录file。</span><br><span class="line">   * 在其中创建多个文件和目录</span><br><span class="line">   * 编写方法，实现删除file中指定文件的操作</span><br><span class="line"><span class="number">2.</span> 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称。</span><br><span class="line"><span class="number">3.</span> 遍历指定目录所有文件名称，包括子文件目录中的文件。</span><br><span class="line">   * 拓展<span class="number">1</span>：并计算指定目录占用空间的大小</span><br><span class="line">   * 拓展<span class="number">2</span>：删除指定文件目录及其下的所有文件</span><br></pre></td></tr></table></figure><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><h3 id="Java-IO原理"><a href="#Java-IO原理" class="headerlink" title="Java IO原理"></a>Java IO原理</h3><ol><li>I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</li><li>==Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行的==</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li><li><strong>输入输出：</strong>进入内存即为输入(Input)，出内存即为输出(Output)</li></ol><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ol><li>按操作==数据单位==不同分为：==字节流(8 bit)==，==字符流(16 bit)==。</li><li>按数据流的==流向==不同分为：==输入流==，==输出流==。</li><li>按流的==角色==的不同分为：==节点流==，==处理流==。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118221934.png" alt="20201118221934" style="zoom:50%;" /><table><thead><tr><th align="center">==<strong>(抽象基类)</strong>==</th><th align="center"><strong>字节流</strong></th><th align="center"><strong>字符流</strong></th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><ul><li>Java的IO流共涉及40多个类，实际上非常规则，都是从者4个类派生的，==由这4个类派生出来的子类名称都是以其父类名作为子类名后缀==</li></ul><h4 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a><strong>IO流体系</strong></h4><table><thead><tr><th align="center">分类</th><th align="center">字节输入流</th><th align="center">字节输出流</th><th align="center">字符输入流</th><th align="center">字符输出流</th></tr></thead><tbody><tr><td align="center">==抽象基类==</td><td align="center">InputStream</td><td align="center">OutputStream</td><td align="center">Reader</td><td align="center">Writer</td></tr><tr><td align="center">==访问文件==</td><td align="center">FileInputStream</td><td align="center">FileOutputStream</td><td align="center">FileReader</td><td align="center">FileWriter</td></tr><tr><td align="center">访问数组</td><td align="center">ByteArrayInputStream</td><td align="center">ByteArrayOutputStream</td><td align="center">CharArrayReader</td><td align="center">CharArrayWriter</td></tr><tr><td align="center">访问管道</td><td align="center">PipedInputStream</td><td align="center">PipedOutputStream</td><td align="center">PipedReader</td><td align="center">PipedWriter</td></tr><tr><td align="center">访问字符串</td><td align="center"></td><td align="center"></td><td align="center">StringReader</td><td align="center">StringWriter</td></tr><tr><td align="center">==缓冲流==</td><td align="center">BufferedInputStream</td><td align="center">BufferedOutputStream</td><td align="center">BufferedReader</td><td align="center">BufferedWriter</td></tr><tr><td align="center">转换流</td><td align="center"></td><td align="center"></td><td align="center">InputStreamReader</td><td align="center">OutputStreamWriter</td></tr><tr><td align="center">对象流</td><td align="center">ObjectInputStream</td><td align="center">ObjectOutputStream</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">FilterInputStream</td><td align="center">FilterOutputStream</td><td align="center">FilterReader</td><td align="center">FilterWriter</td></tr><tr><td align="center">打印流</td><td align="center"></td><td align="center">PrintStream</td><td align="center"></td><td align="center">PrintWriter</td></tr><tr><td align="center">推回输入流</td><td align="center">PushbackInputStream</td><td align="center"></td><td align="center">PushbackReader</td><td align="center"></td></tr><tr><td align="center">特殊流</td><td align="center">DataInputStream</td><td align="center">DataOutputStream</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul><li>==节点流==：直接从数据源或目的地读写数据</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118224629.png" alt="20201118224629"></p><ul><li>==处理流==：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118224802.png" alt="20201118224802" style="zoom:67%;" /><h3 id="InputStream-amp-Reader"><a href="#InputStream-amp-Reader" class="headerlink" title="InputStream &amp; Reader"></a>InputStream &amp; Reader</h3><ol><li><p>==InputStream和Reader是所有输入流的基类==。</p></li><li><p>InputStream（典型实现：FileInputStream）</p><ul><li>int read()</li><li>int read(byte[] b)</li><li>int read(byte[] b,int off,int len)</li></ul></li><li><p>Reader（典型实现：FileReader）</p><ul><li><p>int read()</p></li><li><p>int read(byte[] b)</p></li><li><p>int read(byte[] b,int off,int len)</p></li></ul></li><li><p>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</p></li><li><p>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader</p></li></ol><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a><strong>InputStream</strong></h4><ol><li>int read()：从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</li><li>int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。</li><li>int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。</li><li>public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</li></ol><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a><strong>Reader</strong></h4><ol><li>int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1。</li><li>int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li><li>int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li><li>public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</li></ol><h3 id="OutputStream-amp-Writer"><a href="#OutputStream-amp-Writer" class="headerlink" title="OutputStream &amp; Writer"></a>OutputStream &amp; Writer</h3><ol><li><p>OutputStream 和 Writer 也非常相似：</p><ul><li><p>void write(int b/int c);</p></li><li><p>void write(byte[] b/char[] cbuf);</p></li><li><p>void write(byte[] b/char[] buff, int off, int len);</p></li><li><p>void flush();</p></li><li><p>void close(); 需要先刷新，再关闭此流</p></li></ul></li><li><p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数</p><ul><li><p>void write(String str);</p></li><li><p>void write(String str, int off, int len);</p></li></ul></li><li><p>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。</p></li></ol><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a><strong>OutputStream</strong></h4><ul><li>void write(int b)：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。</li><li>void write(byte[] b)：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。</li><li>void write(byte[] b,int off,int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</li><li>public void flush()throws IOException：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</li><li>public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源</li></ul><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a><strong>Writer</strong></h4><ul><li>void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</li><li>void write(char[] cbuf)：写入字符数组。</li><li>void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符。</li><li>void write(String str)：写入字符串。</li><li>void write(String str,int off,int len)：写入字符串的某一部分。</li><li>void flush()：刷新该流的缓冲，则立即将它们写入预期目标。</li><li>public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源</li></ul><h2 id="节点流-或文件流"><a href="#节点流-或文件流" class="headerlink" title="节点流(或文件流)"></a>节点流(或文件流)</h2><h3 id="通用步骤："><a href="#通用步骤：" class="headerlink" title="通用步骤："></a><strong>通用步骤：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 实例化File类对象，指明要操作的文件</span><br><span class="line">* 提供具体的流</span><br><span class="line">* 数据的操作</span><br><span class="line">* 关闭资源</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：异常处理</span></span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><ol><li><p>步骤：</p><ul><li><pre><code>File类的实例化FileReader流的实例化读入的操作资源关闭<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 说明点：</span><br><span class="line"></span><br><span class="line">* read()的理解：返回读入的一个字符，如果到大文件末尾，返回-1。</span><br><span class="line">* 异常处理：为了保证资源一定可以执行关闭操作。需要使用try-catch-finally处理。</span><br><span class="line">* 读入文件一定要存在，否则就会报FileNotFoundException</span><br><span class="line"></span><br><span class="line">3. 基本操作</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Test</span><br><span class="line">    public void FileReaderTest() &#123;</span><br><span class="line">        FileReader fileReader &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.实例化File类的对象，指明要操作的文件</span><br><span class="line">            File file &#x3D; new File(&quot;hello.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.提供具体的流</span><br><span class="line">            fileReader &#x3D; new FileReader(file);</span><br><span class="line">            &#x2F;&#x2F;3.数据的读入</span><br><span class="line">            &#x2F;&#x2F;read()：返回读入的一个字符。如果达到文件末尾，返回-1</span><br><span class="line">            &#x2F;&#x2F;方式一：</span><br><span class="line">&#x2F;&#x2F;            int data &#x3D; fileReader.read();</span><br><span class="line">&#x2F;&#x2F;            while (data !&#x3D; -1) &#123;</span><br><span class="line">&#x2F;&#x2F;                System.out.print((char) data);</span><br><span class="line">&#x2F;&#x2F;                &#x2F;&#x2F;读取下一个字符</span><br><span class="line">&#x2F;&#x2F;                data &#x3D; fileReader.read();</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;方式二：语法上针对于方式一的修改</span><br><span class="line">            int data;</span><br><span class="line">            while ((data &#x3D; fileReader.read()) !&#x3D; -1) &#123;</span><br><span class="line">                System.out.print((char) data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;4.流的关闭操作</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileReader !&#x3D; null) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>对read()操作升级：使用read()的重载方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileReaderTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    System.out.print(cbuf[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><ol><li><p>步骤：</p><ul><li><pre><code class="java">创建File类的对象：指明读入和写出的文件创建输入流和输出流的对象数据的读入和写出操作关闭流资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#x3D;&#x3D;说明点&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">   * 从内存中写出数据到硬盘的文件里</span><br><span class="line">   * 输出操作，对应的File可以不存在。</span><br><span class="line">          *  如果不存在，在输出过程中，会自动创建此文件</span><br><span class="line">               *  如果存在：</span><br><span class="line">               *      使用的流构造器是: FileWriter(file,false) &#x2F; FileWriter(file)，对原有文件覆盖</span><br><span class="line">                    *      使用的流构造器是: FileWriter(file,true)，不会对原有文件覆盖，而是在原有文件的基础上</span><br><span class="line"></span><br><span class="line">3. 基本操作</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Test</span><br><span class="line">    public void FileWriterTest1() &#123;</span><br><span class="line">        FileReader fileReader &#x3D; null;</span><br><span class="line">        FileWriter fileWriter &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.创建File类的对象：指明读入和写出的文件</span><br><span class="line">            File file &#x3D; new File(&quot;Hello.txt&quot;);</span><br><span class="line">            File file1 &#x3D; new File(&quot;Hello2.txt&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;2.创建输入流和输出流的对象</span><br><span class="line">            fileReader &#x3D; new FileReader(file);</span><br><span class="line">            fileWriter &#x3D; new FileWriter(file1);</span><br><span class="line">            &#x2F;&#x2F;3.数据的读入和写出操作</span><br><span class="line">            char[] cbuf &#x3D; new char[5];</span><br><span class="line">            int len;  &#x2F;&#x2F; 记录每次读入到cbuf数组中的字符的个数</span><br><span class="line">            while ((len &#x3D; fileReader.read(cbuf)) !&#x3D; -1) &#123;</span><br><span class="line">                &#x2F;&#x2F;每次写出len个字符</span><br><span class="line">                fileWriter.write(cbuf, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;4.关闭流资源</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileWriter !&#x3D; null) &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileReader !&#x3D; null)</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><ol><li>==注意点：使用字节流处理文本文件，可能出现乱码==</li><li>说明：<ul><li>对于文本文件（.txt，.java，.c，.cpp），使用字符流处理</li><li>对于非文本文件，使用字节流处理</li></ul></li><li>基本操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fISStreamTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//造文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">            <span class="comment">//造流</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//读数据</span></span><br><span class="line">            <span class="keyword">int</span> len;  <span class="comment">// 记录每次读取的字节的个数</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    System.out.print(bytes[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭流资源</span></span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>复制图片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fISStreamTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建File类对象</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">            File file1 = <span class="keyword">new</span> File(<span class="string">&quot;cat2.jpeg&quot;</span>);</span><br><span class="line">            <span class="comment">//创建输入流和输出流的对象</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">            <span class="comment">//数据的读入和写出操作</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)</span><br><span class="line">                    outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>通用操作：指定路径下的文件复制操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String srcPath,String destPath)</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建File类对象</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">            File file1 = <span class="keyword">new</span> File(destPath);</span><br><span class="line">            <span class="comment">//创建输入流和输出流的对象</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">            <span class="comment">//数据的读入和写出操作</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)</span><br><span class="line">                    outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String srcPath = <span class="string">&quot;文件路径&quot;</span>;</span><br><span class="line">        String destPath = <span class="string">&quot;复制路径&quot;</span>;</span><br><span class="line">        copyFile(srcPath,destPath);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;整个复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//13031</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以复制文本文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><ol><li>处理流的一种，“套接”在已有的流的基础上</li><li>缓冲流涉及到的类<ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul></li><li>==作用==：提供流的读取、写入的速度<ul><li>==原因==：内部提供了一个缓冲区。默认情况下是<em>8kb</em></li></ul></li><li>说明：<ul><li>先关闭外层流，再关闭内层流</li><li>==关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略==</li></ul></li><li>非文本文件的复制</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BfStreamTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">       BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.造文件</span></span><br><span class="line">           File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">           File file1 = <span class="keyword">new</span> File(<span class="string">&quot;cat3.jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.造流</span></span><br><span class="line">           <span class="comment">//2.1造节点流</span></span><br><span class="line">           FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">           FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">           <span class="comment">//2.2造处理流</span></span><br><span class="line">           bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">           bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.复制：数据的读入和写出操作</span></span><br><span class="line">           <span class="keyword">int</span> len;</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">           <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               bufferedOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//关闭流资源</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bufferedOutputStream != <span class="keyword">null</span>)</span><br><span class="line">                   bufferedOutputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bufferedInputStream != <span class="keyword">null</span>)</span><br><span class="line">                   bufferedInputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>文本文件的复制，略，基本雷同</li></ol><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>图片的加密</p><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201129145623613.png" alt="image-20201129145623613"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PicTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片的加密操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncrypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//文件类可省略，它会自动包装为文件类</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;cat.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cat2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">              <span class="comment">//核心</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>图片的解密</p></li></ol><ul><li>对加密的文件做同样的异或操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片的解密操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDecode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//文件类可省略，它会自动包装为文件类</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;加密后的玛雅.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;解密后的玛雅.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取文本上每个字符出现的次数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提示：遍历文本每一个字符，字符及出现次数保存在Map中，将Map中数据写入文件。</span></span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ol><li>转换流提供了在字节流和字符流之间的转换</li><li>==Java API提供了两个转换流==:<ul><li>==InputStreamReader==：将InputStream转换为Reader</li><li>==OutputStreamWriter==；将Writer转换为OutputStream</li></ul></li><li>字节流中的数据都是字符时，转成字符流操作更高效</li><li>很多时候我们使用转换流来==处理文件乱码==问题。实现==编码==和== 解码==的功能</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201129151859662.png" alt="image-20201129151859662" style="zoom:33%;" /><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><ol><li>==实现将字节的输入流按指定字符集转换为字符的输入流==</li><li>需要和InputStream“套接”</li><li>构造器<ul><li>public InputStreamReader(InputStream in)</li><li>public InputSreamReader(InputStream in,String charsetName)</li></ul></li></ol><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><ol><li>==实现将字符的输出流按指定字符集转换为字节的输出流==</li><li>需要和OutputStream“套接”</li><li>构造器<ul><li>public OutputStreamWriter(OutputStream out)</li><li>public OutputSreamWriter(OutputStream out,String charsetName)</li></ul></li></ol><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ol><li>编码:字符串字节数组</li><li>解码:字节数组字符串</li><li>转换流的编码应用<ul><li>可以将字符按指定编码格式存储</li><li>可以对文本数据按指定编码格式来解读</li><li>指定编码表的动作由构造器完成</li></ul></li></ol><h2 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h2><ol><li>==System.in==和==System.out==分别代表了系统标准的输入和输出设备<ul><li>默认输入设备是：键盘，输出设备是：显示器</li></ul></li><li>System.in的类型是==InputStream==，直接以流的形式读取了</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li><li>重定向:通过System类的setIn()，setOut()方法对默认设备进行改变</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">                String data = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (data.equalsIgnoreCase(<span class="string">&quot;e&quot;</span>) || data.equalsIgnoreCase(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序结束！&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String upperCase = data.toUpperCase();</span><br><span class="line">                System.out.println(upperCase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ol><li>==实现将基本数据类型的数据格式转化为字符串输出==，指定输入/输出的位置</li><li>打印流：==PrintStream==和==PrintWriter==<ul><li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。<ul><li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li></ul></li><li>System.out返回的是PrintStream的实例</li></ul></li><li>例子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">null</span>; <span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>)); <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true);</span></span><br><span class="line"><span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">System.setOut(ps); &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符 System.out.print((char) i);</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">System.out.println(); <span class="comment">// 换行 &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace(); &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; ps.close();</span><br><span class="line">&#125; &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ol><li><p>作用：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流</p></li><li><p>数据流有两个类:(==用于读取和写出基本数据类型、String类的数据==)</p><ul><li>==DataInputStream== 和 ==DataOutputStream==</li><li>分别“套接”在 InputStream 和 OutputStream 子类的流上</li></ul></li><li><p>DataInputStream中的方法</p><ul><li>boolean readBoolean() </li><li>char readChar() </li><li>double </li><li>readDouble() </li><li>long readLong()</li><li>String readUTF()</li><li>byte readByte() </li><li>float readFloat() </li><li>short readShort() </li><li>int readInt()</li><li>void readFully(byte[] b)</li></ul></li><li><p>DataOutputStream中的方法</p><ul><li>==将上述的方法的read改为相应的write即可==</li></ul></li><li><p>练习</p><ul><li>将内存中的字符串、基本数据类型变量写出到文件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 创建连接到指定文件的数据输出流对象</span></span><br><span class="line">dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;destData.dat&quot;</span>)); dos.writeUTF(<span class="string">&quot;我爱北京天安门&quot;</span>); <span class="comment">// 写UTF字符串 dos.writeBoolean(false); // 写入布尔值</span></span><br><span class="line">dos.writeLong(<span class="number">1234567890L</span>); <span class="comment">// 写入长整数 System.out.println(&quot;写文件成功!&quot;);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">null</span>; <span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;destData.dat&quot;</span>)); String info = dis.readUTF();</span><br><span class="line"><span class="keyword">boolean</span> flag = dis.readBoolean();</span><br><span class="line"><span class="keyword">long</span> time = dis.readLong();</span><br><span class="line">System.out.println(info); System.out.println(flag); System.out.println(time);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dis != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123; dis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>==注意==：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</li></ol><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ol><li><p>用于==存储==和==读取==基本数据类型数据或对象的处理流。它的强大之处就是==可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来==</p></li><li><p>==ObjectInputStream==和==OjbectOutputSteam==</p><ul><li>==序列化==：用ObjectOutputStream类==保存==基本类型数据或对象的机制</li><li>==反序列化==：用ObjectInputStream类==读取==基本类型数据或对象的机制</li></ul></li><li><p>ObjectOutputStream和ObjectInputStream==不能序列化static和transient==修饰的成员变量</p><ul><li>以下面的Person类为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">44353533453L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将变量用static 和 transient修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">略</span><br><span class="line">  </span><br><span class="line"><span class="comment">//此时的反序列化结果</span></span><br><span class="line">我爱北京天安门</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;  <span class="comment">//显然无法序列化这两个变量</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><ol><li><p>==对象序列化机制==允许把内存中的Java对象转换成平台无关的==二进制流==，从 而允许把这种二进制流持久地==保存在磁盘上==，或通过网络将这种二进制流==传输到另一个网络节点==。//==当其它程序获取了这种二进制流，就可以恢复成原来的Java对象==</p></li><li><p>==序列化的好处==：在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原</p></li><li><p>序列化是 RMI(Remote Method Invoke – 远程方法调用)过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此==序列化机制是 JavaEE 平台的基础==</p></li><li><p>==如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的==，==为了让某个类是可序列化的，该类必须实现如下两个接口之一==。 否则，会抛出NotSerializableException异常</p><ul><li>$\color{red}{Serializable}$</li><li>Externalizable</li></ul></li><li><p>==凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量==:</p><ul><li>$\color{red}{private static final long serialVersionUID}$;</li><li>==serialVersionUID==用来表明类的不同版本间的兼容性。简言之，其目的是==以序列化对象 进行版本控制，有关各版本反序列化时是否兼容==。</li><li>==如果类没有显示定义这个静态常量==，它的值是==Java运行时环境根据类的内部细节自动生成==的。<ul><li>若类的实例变量做了修改，serialVersionUID 可能发生变化。故==建议， 显式声明==</li></ul></li></ul></li><li><p>==Java的序列化机制==是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，==JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较==，如果相同就认为是==一致==的，==可以进行反序列化==，==否则就会出现序列化版本不一致的异 常。(InvalidCastException)==</p></li></ol><h3 id="使用对象流序列化对象"><a href="#使用对象流序列化对象" class="headerlink" title="使用对象流序列化对象"></a>使用对象流序列化对象</h3><h4 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h4><ol><li>==若某个类实现了 Serializable 接口，该类的对象就是可序列化的:==<ul><li>创建一个 ObjectOutputStream</li><li>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</li><li>==注意写出一次，操作flush()一次==</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化实现"><a href="#反序列化实现" class="headerlink" title="反序列化实现"></a>反序列化实现</h4><ol><li>步骤<ul><li>创建一个 ObjectInputStream</li><li>调用 readObject() 方法读取流中的对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObctIStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类实现序列化"><a href="#自定义类实现序列化" class="headerlink" title="自定义类实现序列化"></a>自定义类实现序列化</h4><ol><li><p>==强调==：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是==可序列化的==，否则拥有该类型的 Field 的类也不能序列化</p></li><li><p>==以Person类为例==</p><ul><li>需要==实现接口==：Serializable</li><li>当前类==提供一个全局常量==：serialVersionUID</li><li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化de 。(默认情况下，基本数据类型可序列化)</li></ul></li><li><pre><code class="java">package lesson;import org.junit.jupiter.api.Test;import java.io.*;/** * @author Justry * @Description 对象流的使用 * @date 2020-11-30 9:35 上午 */public class ObiectIOStreamTest &#123;    //序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现    @Test    public void ObjectOStreamTest() &#123;        ObjectOutputStream oos = null;        try &#123;            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));            oos.writeObject(&quot;我爱北京天安门&quot;);            oos.flush();            oos.writeObject(new Person(&quot;如花&quot;, 60));            oos.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (oos != null)                try &#123;                    oos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;        &#125;    &#125;    //反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现    @Test    public void ObctIStreamTest() &#123;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));            Object obj = ois.readObject();            String str = (String) obj;            Person p = (Person) ois.readObject();            System.out.println(str);  // 我爱北京天安门            System.out.println(p);  // Person&#123;name=&#39;如花&#39;, age=60&#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (ois != null)                try &#123;                    ois.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;        &#125;    &#125;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Q</span><br><span class="line"></span><br><span class="line">1. 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗?</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。&#x2F;&#x2F;这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。</span><br><span class="line">换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。</span><br><span class="line">由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="随机存取文件流"><a href="#随机存取文件流" class="headerlink" title="随机存取文件流"></a>随机存取文件流</h2><h3 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h3><ol><li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写，即可以作为输入/出流<ul><li>实现图片的复制</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile r1 = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile r2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            r2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;cat2.jpeg&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = r1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                r2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r2 != <span class="keyword">null</span>)</span><br><span class="line">                r2.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r1 != <span class="keyword">null</span>)</span><br><span class="line">                r1.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件</p><ul><li>支持只访问文件的部分内容 </li><li>可以向已存在的文件后追加内容</li></ul></li><li><p>==RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置==</p><ul><li>long getFilePointer():获取文件记录指针的当前位置 </li><li>void seek(long pos):将文件记录指针定位到 pos 位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile rw = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;Hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rw.seek(<span class="string">&quot;Hello.txt&quot;</span>.length());  <span class="comment">// 将指针指到末尾，追加内容</span></span><br><span class="line">    rw.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    rw.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器</p><ul><li>public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode)</li></ul></li><li><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式</p><ul><li>r；以只读方式打开</li><li>rw；打开以便读取和写入 </li><li>rwd；打开以便读取和写入；同步文件内容的更新 </li><li>rws；打开以便读取和写入；同步文件内容和元数据的更新</li></ul></li><li><p>==如果模式为只读r==。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 ==如果模式为rw读写==，如果文件不 存在则会去创建文件；如果存在则不会创建，写到文件时会对原有内容进行部分覆盖</p></li><li><p>应用：多线程断点下载</p></li></ol><h2 id="流的基本应用小节"><a href="#流的基本应用小节" class="headerlink" title="流的基本应用小节"></a>流的基本应用小节</h2><ol><li>流是用来处理数据的。</li><li>处理数据时，一定要先明确数据源，与数据目的地  数据源可以是文件，可以是键盘。</li><li>数据目的地可以是文件、显示器或者其他设备。</li><li>而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等</li></ol><h2 id="NIO-2中Path、-Paths、Files类的使用"><a href="#NIO-2中Path、-Paths、Files类的使用" class="headerlink" title="NIO.2中Path、 Paths、Files类的使用"></a>NIO.2中Path、 Paths、Files类的使用</h2><ol><li>NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。==NIO将以更加高效的方式进行文件的读写操作==。</li><li>Java API中提供了两套NIO：==一套是针对标准输入输出NIO==，==另一套就是网 络编程NIO==</li></ol><p>略，以后再学</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;重点掌握-：节点流、缓冲流、转换流、对象流&quot;&gt;&lt;a href=&quot;#重点掌握-：节点流、缓冲流、转换流、对象流&quot; class=&quot;headerlink&quot; title=&quot;==重点掌握==：节点流、缓冲流、转换流、对象流&quot;&gt;&lt;/a&gt;==重点掌握==：节点流、缓冲流、转换流</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十一章 集合</title>
    <link href="https://asteroidcs.github.io/undefined/f650.html"/>
    <id>https://asteroidcs.github.io/undefined/f650.html</id>
    <published>2020-11-27T01:12:32.106Z</published>
    <updated>2020-12-01T01:41:40.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><h3 id="集合与数组存储数据概述"><a href="#集合与数组存储数据概述" class="headerlink" title="集合与数组存储数据概述"></a>集合与数组存储数据概述</h3><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</p><h3 id="数组存储的弊端"><a href="#数组存储的弊端" class="headerlink" title="数组存储的弊端"></a>数组存储的弊端</h3><ul><li>一旦初始化以后，其长度就不可以修改了，这就使得不便于扩展</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作不便，且效率不高</li><li>获取数组中实际元素的个数的需求，数组中没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。故无法满足对于无序、不可重复的需求</li></ul><h3 id="集合存储的优点"><a href="#集合存储的优点" class="headerlink" title="集合存储的优点"></a>集合存储的优点</h3><p>集合的出现就是为了==解决数组存储数据方面的弊端==</p><h3 id="集合框架结构：Java集合可分为-Collection-和-Map-两种体系"><a href="#集合框架结构：Java集合可分为-Collection-和-Map-两种体系" class="headerlink" title="集合框架结构：Java集合可分为==Collection==和==Map==两种体系"></a>集合框架结构：Java集合可分为==Collection==和==Map==两种体系</h3><ul><li><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>List接口：==存储有序的、可重复的数据  ——&gt;  “动态”数组==</li><li>Set接口：==存储无序的、不可重复的数据==</li><li>Collection接口继承树</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/wpsClwKIf.png" alt="wpsClwKIf" style="zoom: 33%;" /></li><li><p>Map接口：双列数据，==保存具有映射关系的“key-value”对的集合==</p><ul><li>Map接口继承树</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201116214800.png" alt="20201116214800" style="zoom: 50%;" /></li></ul><h2 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul><li>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合——&gt;  ==继承性的特点：可以调用父类的方法==</li><li>==JDK不提供Collection接口的任何直接实现，而是提供更具体的子接口(Set、List)实现== ——&gt; 意味着只能构造其子接口的对象，即ArrayList、LinkedList、Vector/LinkedHashSet、TreeSet等</li><li>在==Java5==之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；==从JDK 5.0增加了泛型以后==，Java集合可以记住容器中对象的数据类型。</li><li>$\color{red}{注意：向Collection接口的实现类对象中添加数据obj时，要求obj所在类重写equals()方法}$</li></ul><h3 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h3><ol><li>增加数据</li></ol><ul><li>add(Object e): 将元素e添加到集合coll中</li><li>addAll(Collection coll): 将coll集合中的元素添加到当前的集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于JDK不提供Collection接口的任何直接实现，所以这种写法是错误的 ---&gt; 只能用其子接口</span></span><br><span class="line"><span class="comment">//        Collection collection = new Collection();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用子接口实现</span></span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);  <span class="comment">// 其中false为Boolean型，包装类</span></span><br><span class="line">        collection1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(collection1);  <span class="comment">// [123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addAll</span></span><br><span class="line">        collection2.add(<span class="number">4324</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection2.add(<span class="keyword">new</span> String(<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">        collection2.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection2);  <span class="comment">// [4324, 555, 123, Jack, true]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合1加入集合2中</span></span><br><span class="line">        collection2.addAll(collection1);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection2);  <span class="comment">// [4324, 555, 123, Jack, true, 123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==从代码输出的结果可以看出：这里正好体现了List接口存放有序、可重复数据的特点==</li></ul><ol start="2"><li>删除数据</li></ol><ul><li>clear()：==清空==集合元素</li><li>remove(Object obj)：从当前集合中移除指定的obj元素</li><li>removeAll(Collection coll)：移除当前集合与另外的coll集合的==交集==中的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">      collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      collection1.add(<span class="number">123</span>);</span><br><span class="line">      collection1.add(<span class="keyword">false</span>);</span><br><span class="line">      collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//remove</span></span><br><span class="line">      collection1.remove(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [123, 123, false]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// clear</span></span><br><span class="line">      collection1.clear();</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//removeAll</span></span><br><span class="line">      Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      collection2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">      collection1.removeAll(collection2);</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [false, Tom]</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>查找数据</li></ol><ul><li>contains(Object obj)；判断当前集合中是否包含obj</li><li>containsAll(Collection coll)：判断形参coll中所有元素是否都存在于当前集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ContainsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);  <span class="comment">// 其中false为Boolean型，包装类</span></span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Contains</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = collection1.contains(<span class="number">123</span>);</span><br><span class="line">        System.out.println(contains);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> contains1 = collection1.contains(<span class="number">3543</span>);</span><br><span class="line">        System.out.println(contains1);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此处调用的是String类中的equals，由于String重写了equals方法，</span></span><br><span class="line"><span class="comment">         * 故比较的是内容，而非地址，所以返回true，</span></span><br><span class="line"><span class="comment">         * 若自定义的类没有重写object的equals方法，则返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(collection1.contains(<span class="string">&quot;Tom&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ContainsAll</span></span><br><span class="line">        Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合collection2中的所有元素是否都存在于collection1中</span></span><br><span class="line">        <span class="keyword">boolean</span> b = collection1.containsAll(collection2);</span><br><span class="line">        System.out.println(b);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>集合的长度</li></ol><ul><li>size(): 获取添加的元素个数</li></ul><ol start="5"><li><p>其他</p><ul><li><p>isEmpty()：判断当前集合是否为空</p></li><li><p>retainAll(Collection coll): 交集，将当前集合修改为当前集合与coll的交集</p></li><li><p>equals(Object obj): 判断当前集合与形参集合的元素是否都相同</p></li><li><p>hashCode()：返回当前对象的哈希值</p></li><li><p>toArray()：集合转换成数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object[] array = collection1.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;  <span class="comment">// 123 123 false Tom</span></span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展：数组 ---&gt; 集合</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);  <span class="comment">// [AA, BB, CC]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        List arr = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">        System.out.println(arr);  <span class="comment">// [[I@3ecd23d9] ---&gt; 识别为了一个元素</span></span><br><span class="line"></span><br><span class="line">        List arr1 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(arr1);  <span class="comment">//[123, 456]</span></span><br><span class="line"></span><br><span class="line">        List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">        System.out.println(arr2);  <span class="comment">// [123, 456]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展：数组 ---&gt; 集合 : 调用Arrays类的静态方法asList()</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);  <span class="comment">// [AA, BB, CC]</span></span><br></pre></td></tr></table></figure><ul><li>iterator(): 返回Iterator接口的实例，用于遍历集合元素</li></ul><p>$\color{red}{在判断时会调用obj对象所在类的equals()方法}$</p><ol start="6"><li><p>集合的默认遍历方法（jdk8新特性）—&gt; ==forEach==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="number">343</span>);</span><br><span class="line">    coll.add(<span class="number">343</span>);</span><br><span class="line"></span><br><span class="line">    coll.forEach(System.out::println);<span class="comment">//方法引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="terator迭代器接口"><a href="#terator迭代器接口" class="headerlink" title="terator迭代器接口"></a>terator迭代器接口</h3><ul><li><p>==Iterator仅用于遍历集合==，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = collection1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);  <span class="comment">// 123 123 false Tom </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">while</span> (collection1.iterator().hasNext())&#123;   <span class="comment">// 每次产生一个全新的迭代器对象</span></span><br><span class="line">      System.out.println(collection1.iterator().next());  <span class="comment">// 死循环 ---&gt; 不断输出第一个元素</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>==使用迭代器遍历集合一般使用的方式以及迭代器执行原理：==</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201116222158-20201127205655581.png" alt="20201116222158-20201127205655581" style="zoom: 67%;" /></li><li><p>remove()方法</p><ul><li><p>内部定义了remove方法，==Iterator可以删除集合的元素==，==区别集合的remove()方法和迭代器的remove()方法==</p></li><li><p>注意指针的位置，若调用remove()方法时指针位置为空，则报异常IllegalStateException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = collection1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object o = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Tom&quot;</span>.equals(o))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(collection1);  <span class="comment">// [123, 123, false]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="foreach循环-增强for循环"><a href="#foreach循环-增强for循环" class="headerlink" title="foreach循环(增强for循环)"></a>foreach循环(增强for循环)</h3><ul><li><p>Java 5.0 提供了foreach循环迭代访问Collection和数组</p></li><li><p>无需长度、索引</p></li><li><p>内部仍然调用了迭代器 ——&gt; ==底层：Iterator==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 局部变量 : 数组/Collection对象)&#123;</span><br><span class="line">    <span class="comment">//对局部变量操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : collection1)&#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);  <span class="comment">// 123 123 false Tom </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>$\color{red}{注意：增强for循环是将值赋给局部变量，改变的是局部变量，不影响对象中的元素}$</p></li><li><p><strong>练习：</strong>判断输出结果为何？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(String myStr : str)&#123;</span><br><span class="line">            myStr = <span class="string">&quot;atguigu&quot;</span>;</span><br><span class="line">            System.out.println(myStr);</span><br><span class="line">        &#125;<span class="comment">//5行&quot;atguigu&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length;i++)&#123;</span><br><span class="line">            System.out.println(str[i]);</span><br><span class="line">        &#125;<span class="comment">//5行null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collection子接口一：List"><a href="#Collection子接口一：List" class="headerlink" title="Collection子接口一：List"></a>Collection子接口一：List</h2><ol><li><p>存储有序的、可重复的数据。==&gt; “动态”数组，替换原有的数组 —&gt; 避免了角标越界</p><ul><li>理解：添加数据时，当原数组的存储空间不够时，会重新生成一个容量较大的新数组，将原数组中的元素放进新数组中，并添加新的数据 ———&gt; 占内存 </li></ul></li><li><p>List接口方法：除了从Collection集合继承的方法外，==List 集合里添加了一些根据索引来操作集合元素的方法==</p></li><li><p>增加数据</p><ul><li>void add(int index,Object ele)：在index位置插入ele元素；</li><li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">false</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="comment">//数组的第二个位置插入数据</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">657</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, 657, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addAll</span></span><br><span class="line">        <span class="comment">//将list1插入list的索引2位置</span></span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list1.add(<span class="number">7868</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list1.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        list.addAll(<span class="number">2</span>, list1);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><ul><li>Object remove(int index)：移除指定index位置的元素，==并返回此元素==</li><li>Object remove(Object obj)：移除指定的元素(若有多个，则只移除首位的元素)，==并返回true/false==</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">false</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove(int index)</span></span><br><span class="line">        Object o = list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);  <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove(Object obj)</span></span><br><span class="line">        <span class="keyword">boolean</span> b = list.remove(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(b);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = list.remove(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(b1);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>查找</p><ul><li>Object get(int index)：获取指定index位置的元素；</li><li>int indexOf(Object obj)：返回obj在集合中首次出现的位置；</li><li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置；</li><li>List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, Jack, 342, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(int index)</span></span><br><span class="line">        Object o = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(o);  <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int indexOf(Object obj)</span></span><br><span class="line">        <span class="keyword">int</span> i = list.indexOf(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(i);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int lastIndexOf(Object obj)</span></span><br><span class="line">        <span class="keyword">int</span> i1 = list.lastIndexOf(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(i1);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List subList(int fromIndex, int toIndex)</span></span><br><span class="line">        List list1 = list.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list1);  <span class="comment">// [Tom, Jack, 342]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><ul><li>Object set(int index, Object ele)：设置指定index位置的元素为ele；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="number">5464</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, 5464, Jack]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​    ==作为List接口的主要实现类；由于是线程不安全的，故效率高；底层使用Object[] elementData存储。==</p><ul><li><p><strong>==源码分析==：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7的情况下：</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建而来长度为10的Object[]数组elementData；</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">list.add(<span class="number">12</span>);<span class="comment">//如果此次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk8中ArrayList的变化：</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组。</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中。</span></span><br><span class="line"><span class="comment">//后续的添加扩容操作与jdk7无异</span></span><br></pre></td></tr></table></figure></li><li><p><strong>==小结==：</strong>jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8则类似于懒汉式，延迟了数组的创建，节省内存。</p></li><li><p><strong>【面试题】</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);  <span class="comment">// [1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考点：确定调用哪个remove， 两个remove()方法中index优先权大于Object，删除索引为2的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list.remove(<span class="number">2</span>);<span class="comment">//两个remove()方法中index优先权大于Object，删除索引为2的元素</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//删除值为2的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol><li>对于==频繁的插入和删除==操作，使用此类效率比ArrayList高；底层使用双向链表存储。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();<span class="comment">//内部声明了Node类型的first和last属性，，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line">其中，Node定义为：体现了LinkedList的双向链表</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Node除了保存数据，还定义了两个变量：</p><ul><li>prev：记录前一个元素的位置</li><li>next：记录下一个元素的位置</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117101744.png" alt="20201117101744" style="zoom:75%;" /></li><li><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeLast</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol><li><p>作为List接口的古老实现类(1.0)；线程安全的，效率低；底层使用Object[] elementData存储。</p></li><li><p><strong>源码分析：</strong></p><ul><li>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍。</li></ul></li><li><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>==面试题==：</strong>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解。ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p><ul><li><p>ArrayList和LinkedList的异同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二者都线程不安全，相对线程安全的Vector，执行效率高。</span><br><span class="line">此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br></pre></td></tr></table></figure></li><li><p>ArrayList和Vector的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(<span class="keyword">synchronized</span>)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的<span class="number">2</span>倍空间，而ArrayList是<span class="number">1.5</span>倍。Vector还有一个子类Stack。</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Collection子接口二：Set"><a href="#Collection子接口二：Set" class="headerlink" title="Collection子接口二：Set"></a>Collection子接口二：Set</h2><ul><li>Set接口是Collection的子接口，==<em>set接口没有提供额外的方法</em>==。都是Collection中声明过的方法。</li><li>==存储无序的、不可重复的数据== ==&gt; 高中数学中的“集合”</li><li>Set判断两个对象是否相同不是使用 == 运算符，而是根据equals()方法</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol><li><p>作为Set接口的主要实现类；==是线程不安全的，可以存储null值==。</p></li><li><p><strong>以HashSet为例说明：Set存储无序的、不可重复的数据:</strong></p><ul><li><p>==无序性==：==不等于随机性==。存储的数据在底层数组中并非按照数组索引的顺序添加，而是==根据数据的哈希值决定的==</p></li><li><p>==不可重复性==：保证添加的元素==按照equals()判断==时，不能返回true。即：相同的元素只能添加一个。—&gt; ==因此自定义类需要重写equals( )方法和hashCode( )方法，先比较hash值，再用equals( )比较==</p></li><li><p>==要求==：</p><ul><li>向Set中添加元素所在类，其所在类一定要==重写hashCode()和equals()==；</li><li>==重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码== —&gt; 哈希值</li><li>==重写两个方法的小技巧==：对象中用作equals()方法比较的Field，都应该用来计算hashCode值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        set.add(<span class="number">657</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set); <span class="comment">// [657, Tom, 123] ---&gt; 不可重复性</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        System.out.println(set);  <span class="comment">// [AA, 657, Tom, 123, Jack] ---&gt; 无序性</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>==<strong>添加元素的过程：以HashSet为例</strong>==</p><ul><li>向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值</li><li>==此哈希值接着通过某种算法，计算出在HashSet底层数组中的存放位置（即为：索引位置）==</li><li>判断数组此位置上是否已有元素：<ul><li>没有其他元素==&gt;添加成功。==&gt;情况1</li><li>有其他元素b(或以链表形式存在的多个元素)，则比较元素a与b的哈希值:<ul><li>哈希值不同==&gt;添加成功。==&gt;情况2</li><li>哈希值相同，进而调用元素a所在类的equals()方法：<ul><li>返回false==&gt;添加成功。==&gt;情况3</li><li>返回true，则添加失败。</li></ul></li></ul></li></ul></li></ul></li><li><p>对于添加成功的情况2和3而言：元素a与已经存在指定索性位置上的数据以链表的方式存储。</p><ul><li>jdk7：元素a放到数组中，指向原来的元素。（头插）</li><li>jdk8：原来的元素在数组中指向a元素。（尾插）</li><li>总结：七上八下</li></ul></li><li><p>==HashSet底层：数组+链表的结构==</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117110143.png" alt="20201117110143" style="zoom: 50%;" /></li><li><p>==问题==：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</span><br><span class="line"><span class="number">31</span>只占用5bits,相乘造成数据溢出的概率较小。</span><br><span class="line"><span class="number">31</span>可以 由i*<span class="number">31</span>== (i&lt;&lt;<span class="number">5</span>)-<span class="number">1</span>来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</span><br><span class="line"><span class="number">31</span>是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有<span class="number">1</span>来整除！(减少冲突)</span><br></pre></td></tr></table></figure></li></ol><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ol><li><p>作为HashSet的子类；遍历其内部数据时，==可以按照添加顺序遍历==。==对于频繁的遍历操作，LinkedHashSet效率高于HashSet==</p></li><li><p>LinkedHashSet ==根据元素的 hashCode 值来决定元素的存储位置==，但它同时==使用双向链表维护元素的次序==，这使得元素看起来是以插入顺序保存的</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117110952.png" alt="20201117110952" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LinkedHashSet</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        set.add(<span class="number">657</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [123, Tom, 657] ---&gt; 不可重复性</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [123, Tom, 657, Jack, AA] ---&gt; 按照添加顺序遍历</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol><li><p>==以按照添加对象的指定属性进行排序==</p><ul><li>向TreeSet中添加的数据。要求是相同类的对象</li><li>两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）。默认情况下，TreeSet采用自然排序</li><li>==自然排序中==，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()</li><li>==定制排序中==，比较两个对象是否相同的标准为：compare()返回0，不再是equals()</li></ul></li><li><p><strong>新增方法</strong></p><ul><li>Comparator comparator()</li><li>Object first()</li><li>Object last()</li><li>Object lower(Object e)</li><li>Object higher(Object e)</li><li>SortedSet subSet(fromElement, toElement)</li><li>SortedSet headSet(toElement)</li><li>SortedSet tailSet(fromElement)</li></ul></li><li><p>==TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快==</p><img src="https://gitee.com/Dawn_Lee/blogimg/raw/master/20201117111739.png" alt="img" style="zoom: 50%;" /></li><li><p>User类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> age == user.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自然排序：默认从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            User user = (User) o;</span><br><span class="line"><span class="comment">//            return this.name.compareTo(user.name);</span></span><br><span class="line">            <span class="comment">// 二级排序</span></span><br><span class="line">            <span class="keyword">int</span> compare = -<span class="keyword">this</span>.name.compareTo(user.name);  <span class="comment">// 加了负号，所以按照姓名从大到小排序</span></span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, user.age);  <span class="comment">// 年龄从小到大排列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不匹配！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>自然排序实现</strong>==（实现Comparable接口）——&gt; 重写compareTo( )方法==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">56</span>));  <span class="comment">// 若排序方式中未定义年龄的排序方式，则无法添加成功</span></span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">65</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">32</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">33</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">56</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>定制排序实现</p><ul><li>构建comparator对象，并重写compare（）方法</li><li>将其作为形参传入User类的构造器中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Comparator comparator = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    User u1 = (User)o1;</span><br><span class="line">                    User u2 = (User)o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">56</span>));  <span class="comment">// 若排序方式中未定义年龄的排序方式，则无法添加成功</span></span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">32</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">33</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">56</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">65</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>==<strong>非常非常经典的面试题：</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);  <span class="comment">// 根据算法算出hash值h1，确定在set中的存储位置</span></span><br><span class="line">        set.add(p2);  <span class="comment">// 根据算法算出hash值，确定在set中的存储位置</span></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;  <span class="comment">// 只改变p1的属性值，但p1已存入set，在set中位置不变</span></span><br><span class="line">        set.remove(p1);  <span class="comment">// 根据此时的p1(属性改变后)计算出的hash值h2≠h1，所以没能删除set中的p1</span></span><br><span class="line">        System.out.println(set);  <span class="comment">//[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));  <span class="comment">// 根据算法算出hash值h2，此位置无元素，添加成功</span></span><br><span class="line">        System.out.println(set);  <span class="comment">//[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));  <span class="comment">// 计算出hash值h1与p1所在位置哈希值相同，调用</span></span><br><span class="line">        <span class="comment">// Person中的equals()方法，返回结果为false，此对象以链表的形式存入数组中，添加成功。</span></span><br><span class="line">        System.out.println(set);  <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117112759.png" alt="20201117112759" style="zoom:75%;" /><ol><li><p><strong>概述：</strong></p><ul><li><p>==双列数据，存储key-value对的数据== ==&gt; 类似于高中的函数，类比其他语言中的==字典==</p></li><li><p>==Map中的key：无序的，不可重复的==，使用Set存储所有的key。 ==&gt; key所在的类必须要重写equals()和hashCode()==（以HashMap为例）</p></li><li><p>==Map中的value：无序的，可重复的==，==使用Collection存储所有的value==。 –&gt; ==value所在类要重写equals()==</p></li><li><p>一个键值对：==key-value构成一个Entry对象==。</p></li><li><p>==Map中的Entry：无序的，不可重复的，使用Set存储所有entry==。</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118101436.png" alt="20201118101436" style="zoom: 50%;" /></li><li><p>==添加、删除、修改等操作==</p><ul><li>Object put(Object key,Object value):将制定key-value添加到（或修改）当前map对象中。</li><li>void putAll(Map m):将m中所有key-value对存放到当前map中。</li><li>Object remove(Object key):移除指定key的key-value对，并返回value。没有相应的key则返回null</li><li>void clear():清空当前map中的所有数据。与map=null操作不同</li></ul></li><li><p>==元素查询的操作==</p><ul><li>Object get(Object key):获取指定key对应的value。没有相应的key则返回null</li><li>boolean containsKey(Object key):是否包含指定的key。</li><li>boolean containsValue(Object value):是否包含指定的value。</li><li>int size():返回map中key-value对的个数。</li><li>boolean isEmpty(): 判断当前map是否为空。</li><li>boolean equals(Object obj):判断当前map和参数对象是否相等</li></ul></li><li><p>==元视图操作的方法==</p><ul><li>Set keySet():返回所有key构成的Set集合。</li><li>Collections values():返回所有value构成的Collection集合。</li><li>Set entrySet():返回所有key-value构成的Set集合</li></ul></li><li><p>==总结：常用方法==</p><ul><li><p>添加：put(Object key,Object value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除：remove(Object key)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove</span></span><br><span class="line">        Object remove = hashMap.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(remove);  <span class="comment">// Tom</span></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改：put(Object key,Object value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put2Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        hashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Jim&quot;</span>);</span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Jim, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询：get(Object key)</p></li><li><p>长度：size()</p></li><li><p>遍历：keySet() / values() / entrySet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        hashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">        Set set = hashMap.keySet();</span><br><span class="line">        Collection values = hashMap.values();</span><br><span class="line">        Set set1 = hashMap.entrySet();</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [tt, 2, 564, 6]</span></span><br><span class="line">        System.out.println(values);  <span class="comment">// [546, Tom, Tom, 324]</span></span><br><span class="line">        System.out.println(set1);  <span class="comment">// [tt=546, 2=Tom, 564=Tom, 6=324]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol><li><p>==作为Map的主要实现类==；线程不安全，效率高；==存储null的key和value==</p></li><li><p>==<strong>底层实现原理：</strong>(jdk7)==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();<span class="comment">//在实例化以后，底层创建了一个长度为16的一维数组Entry[] table。</span></span><br><span class="line"><span class="comment">//...可能已经执行过多次put...</span></span><br><span class="line">map.put(key1,value1);<span class="comment">//首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值通过某种算法计算后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。---情况1</span></span><br><span class="line"><span class="comment">/*如果，此位置上的数据不为空，(意味着此位置上一个或多个数据(以链表形式存在))，比较key1与已经存在的一个或多个数据的哈希值：</span></span><br><span class="line"><span class="comment">    如果key1与已经存在的数据的哈希值都不相同，key1-value1添加成功。---情况2</span></span><br><span class="line"><span class="comment">    如果key1与已经存在的某个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较：</span></span><br><span class="line"><span class="comment">        equals()返回false，添加成功。---情况3</span></span><br><span class="line"><span class="comment">        equals()返回true，使用value1替换value2值。*/</span></span><br></pre></td></tr></table></figure></li><li><p>==补充==：</p><ul><li><p>情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p></li><li><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。</p></li><li><p>默认扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。</p></li></ul></li><li><p>==jdk8相较于jdk7在底层实现方面的不同==</p><ul><li>new HashMap()：底层没有创建一个长度为16的数组；</li><li>jdk8底层的数组是Node[]，而非Entry[]；</li><li>首次调用put()时，底层创建长度为16的数组；</li><li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</li><li>当某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组长度 &gt; 64 时，此索引位置上的的所有数据改为用红黑树存储。</li></ul></li><li><p>HashMap的存储结构</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118103319.png" alt="20201118103319" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118103404.png" alt="20201118103404" style="zoom: 50%;" /></li><li><p><strong>==几个常量值==</strong> —&gt; ==底层源码==</p><ul><li>DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75</li><li>threshold：扩容的临界值等于容量x填充因子：16*0.75 = 12</li><li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8</li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64</li><li>table：存储元素的数组，总是2的n次幂</li><li>entrySet：存储具体元素的集</li><li>size：HashMap中存储的键值对的数量</li><li>modCount：HashMap扩容和结构改变的次数</li><li>threshold：扩容的临界值 = 容量*填充因子</li><li>loadFactor：填充因子</li></ul></li><li><p><strong>==面试题==：</strong>谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？</p></li><li><p><strong>==面试题==：</strong>负载因子的值太小，对HashMap有什么影响？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">负载因子的大小决定了HashMap的数据密度。</span><br><span class="line">负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</span><br><span class="line">负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</span><br><span class="line">按照其他语言的参考及研究经验，会考虑将负载因子设置为<span class="number">0.7</span>~<span class="number">0.75</span>，此时平均检索长度接近于常数。</span><br></pre></td></tr></table></figure></li></ol><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ol><li><p>概述</p><ul><li>作为HashMap的子类</li><li>保证在遍历map元素时，可以按照添加的顺序实现遍历。<ul><li>原理：在原有的HashMap地层结构基础上，添加了一对指针，指向前一个和后一个元素。</li><li>对于频繁的遍历操作，此类执行效率高于HashMap。</li></ul></li></ul></li><li><p><strong>底层实现原理：</strong>(了解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">//能记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LinkedHashMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        linkedHashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        linkedHashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(linkedHashMap);  <span class="comment">// &#123;2=Tom, tt=546, 6=324, 564=Tom&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        linkedHashMap.put(<span class="number">2</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashMap);  <span class="comment">// &#123;2=Jack, tt=546, 6=324, 564=Tom&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li><p>==保证按照添加的key-value对进行排序，实现遍历。此时考虑key的自然和定制排序==。==底层使用红黑树存储==。</p></li><li><p>向TreeMap中添加key-value，==要求key必须是由同一个类创建的对象==，因为要按照key进行自然排序、定制排序。</p><p>排序类似于之前的TreeSet。 ———&gt; ==同一个treeMap中的key的类型必须一致，意味着只能有仅只有一个类型的数据==</p></li><li><p>==TreeMap判断两个key相等的标准==：两个key通过compareTo()方法或者compare()方法返回0。———&gt; 因此涉及到了方法的重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line"></span><br><span class="line">        treeMap.put(<span class="string">&quot;fsad&quot;</span>, <span class="number">453</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;sad&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;J&quot;</span>, <span class="number">435</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(treeMap);  <span class="comment">// &#123;2=sad, J=435, fsad=453&#125;</span></span><br><span class="line"></span><br><span class="line">        treeMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;happy&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);  <span class="comment">// &#123;2=happy, J=435, fsad=453&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key的类型不一致，故而抛出异常</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * java.lang.ClassCastException: class java.lang.</span></span><br><span class="line"><span class="comment">         * String cannot be cast to class java.lang.Integer (java.lang.String </span></span><br><span class="line"><span class="comment">         * and java.lang.Integer are in module java.base of loader &#x27;bootstrap&#x27;)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object put = treeMap.put(<span class="number">3</span>, <span class="number">342</span>);</span><br><span class="line">        System.out.println(put);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li>作为Map古老的实现类(jdk1.0)；线程安全的，效率低；不能存储null的key和value。</li><li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。</li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序。</li><li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><p>Properties 类是 Hashtable 的子类，常用来处理配置文件。key和value都是Sting类型。</p></li><li><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</p></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="==Collections工具类=="></a>==Collections工具类==</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Collections 是一个操作 Set、List 和 Map 等集合的工具类。</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="==常用方法=="></a><strong>==常用方法==</strong></h3><ol><li><p>==排序操作：(均为非static方法)==</p><ul><li>reverse(List)：反转 List 中元素的顺序</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ul></li><li><p>==查找、替换==</p><ul><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)</li><li>Object min(Collection，Comparator)</li><li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li><li>void copy(List dest,List src)：将src中的内容复制到dest中</li><li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值</li></ul></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-28 11:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        arrayList.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">546</span>);</span><br><span class="line">        arrayList.add(<span class="number">324</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [Tom, 546, 324, Jack]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse</span></span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [Jack, 324, 546, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        Collections.swap(arrayList, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [546, 324, Jack, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy</span></span><br><span class="line">        List&lt;Object&gt; arrayList1 = Arrays.asList(<span class="keyword">new</span> Object[arrayList.size()]);</span><br><span class="line"></span><br><span class="line">        System.out.println(arrayList1);  <span class="comment">// [null, null, null, null]</span></span><br><span class="line">        Collections.copy(arrayList1, arrayList);</span><br><span class="line">        System.out.println(arrayList1);  <span class="comment">// [546, 324, Jack, Tom]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>==同步控制==：</strong></p><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronizedXxx() </span></span><br><span class="line">List list = Collections.synchronizedList(arrayList); <span class="comment">// 返回的list为线程安全的</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><strong>补充：</strong>Enumeration</p><ul><li><p>Enumeration 接口是 Iterator 迭代器的 “古老版本”。</p><ul><li><p>hasMoreElements()</p></li><li><p>nextElement()</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration stringEnum = <span class="keyword">new</span> StringTokenizer(<span class="string">&quot;a-b*c-d-e-g&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stringEnum.hasMoreElements())&#123;</span><br><span class="line">    Object obj = stringEnum.nextElement();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==面试题==：Collection 和 Collections的区别？</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h2&gt;&lt;h3 id=&quot;集合与数组存储数据概述&quot;&gt;&lt;a href=&quot;#集合与数组存储数据概述&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十二章 泛型</title>
    <link href="https://asteroidcs.github.io/undefined/95b4.html"/>
    <id>https://asteroidcs.github.io/undefined/95b4.html</id>
    <published>2020-11-26T14:23:19.245Z</published>
    <updated>2020-12-01T01:41:45.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范型的理解"><a href="#范型的理解" class="headerlink" title="范型的理解"></a>范型的理解</h2><h3 id="为什么要有泛型"><a href="#为什么要有泛型" class="headerlink" title="为什么要有泛型?"></a>为什么要有泛型?</h3><ul><li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li><li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li></ul><h3 id="什么是范型？"><a href="#什么是范型？" class="headerlink" title="什么是范型？"></a>什么是范型？</h3><ul><li><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118121221.jpg" alt="20201118121221" style="zoom: 50%;" /></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118121235.png" alt="20201118121235" style="zoom:50%;" /><ul><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</li></ul><h3 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h3><ul><li>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>，List<E>，ArrayList<E>  这个<E>就是类型参数，即泛型。</li></ul><h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><p>​    ==使用范型的时候，这个范型指的是基本数据类型，即&lt;&gt;中不能放int、double、float等，应该放它们的包装类==</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>使用范型之前的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//存放学生成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">90</span>);</span><br><span class="line">        list.add(<span class="number">86</span>);</span><br><span class="line">        <span class="comment">//问题一：；类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object score : list) &#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能会出现类型异常ClassCastException</span></span><br><span class="line">            <span class="keyword">int</span> stuScore = (Integer) score;</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用范型的情况：以ArrayList为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//存放学生成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">90</span>);</span><br><span class="line">        list.add(<span class="number">86</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：Iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用泛型的情况：以HashMap为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span></span><br><span class="line">        <span class="comment">//jdk新特性：类型推断</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        map.put(123,&quot;ABC&quot;);</span></span><br><span class="line">        <span class="comment">//泛型嵌套</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">            String key = e.getKey();</span><br><span class="line">            Integer value = e.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">：</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h4><ul><li>集合接口或集合类在<em>jdk5.0</em>时都修改为带泛型的结构</li><li>在实例化集合类时，可以指明具体的泛型类型</li><li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型<ul><li>比如：<em>add(E e) —&gt;<em>实例化以后：</em>add(Integer e)</em></li></ul></li><li>==注意点==：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li><li>如果实例化时，没指明泛型的类型。默认类型为<em>java.lang.Object</em>类型</li></ul><h2 id="自定义泛型类、泛型接口、泛型方法"><a href="#自定义泛型类、泛型接口、泛型方法" class="headerlink" title="自定义泛型类、泛型接口、泛型方法"></a><strong>自定义泛型类、泛型接口、泛型方法</strong></h2><ol><li><p>范型的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; 和 <span class="title">class</span> <span class="title">GenTest</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">其中，<span class="title">T</span>，<span class="title">K</span>，<span class="title">V</span>不代表值，而是表示类型。这里使用任意字母都可以。常用<span class="title">T</span>表示，是<span class="title">Type</span>的缩写</span></span><br></pre></td></tr></table></figure></li><li><p>范型的实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一定要在类名后面指定类型参数的值（类型）。如</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;Customer&gt; iterator = customers.iterator();</span><br><span class="line"><span class="comment">//T只能是累，不能用基本数据类型填充。但可以使用包装类填充</span></span><br><span class="line"><span class="comment">//把一个集合中的内容限制为一个制定的数据类型，这就是generics背后的核心思想</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ol><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String OrderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的内部结构就可以使用类的范型</span></span><br><span class="line">    T orderT;  <span class="comment">//这里的T目前不确定什么类型，实例化的时候才会确定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T orderT)</span> </span>&#123;</span><br><span class="line">        OrderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">        <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">        Order&lt;String&gt; stringOrder = <span class="keyword">new</span> Order&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">        stringOrder.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>==细节==<ul><li>范型类可能有多个参数，此时应该将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li><li>范型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass<E>(){}</li><li>实例话后，操作原来范型位置的结构必须与指定的范型类型一致</li><li>范型不同的引用不能相互赋值</li><li>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中</li><li>范型如果不指定，将被擦除，范型对应的类型均按照Object处理，但不等价于Object。经验：范型要使用一路都用。要不用，一路都不要用</li><li>如果范型结构是一个接口或抽象类，则不创建范型类的对象</li><li>Jdk1.7，范型的简化操作：ArrayList<Fruit> flist = new ArrayList&lt;&gt;()</li><li>范型的指定中不能使用基本数据类型，可以使用包装类替换</li><li>在类/接口上声明的范型，在本类或本接口中即代表某种类型，可以作为静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的范型</li><li>异常类不能是范型的</li><li>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capcity]；<ul><li>参考：ArrayList源码中声明：Object[] elementData，而非范型参数类型数组</li></ul></li><li>父类有范型，子类可以选择保留泛型也可以选择指定泛型类型<ul><li>子类不保留父类的泛型：按需实现</li><li>自类保留父类的泛型：泛型子类</li></ul></li></ul></li></ol><ul><li>==总结==：<ul><li>类的内部结构就可以使用类的范型</li><li>如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</li><li>要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型</li><li>由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型</li></ul></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ol><li><p>方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型，与类的泛型类没有任何关系</p></li><li><p>泛型方法的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常</span><br></pre></td></tr></table></figure></li><li><p>泛型方法声明泛型时也可以指定上限</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128184559793.png" alt="image-20201128184559793" style="zoom:50%;" /></li><li><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128184811944.png" alt="image-20201128184811944" style="zoom:50%;" /></li></ol><h2 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a><strong>泛型在继承上的体现</strong></h2><ul><li><p>泛型在继承方面的体现*</p><p>*    虽然类<em>A</em>是类<em>B</em>的父类，但是<em>G<A></em> 和*G<B><em>二者不具备子父类关系，二者是并列关系。</em></p><p>*    补充：类<em>A</em>是类<em>B</em>的父类，<em>A<G></em> 是 <em>B<G></em> 的父类</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128194134097.png" alt="image-20201128194134097"  /></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h2><ol><li><p>使用类型==通配符:?==</p><ul><li>比如:List<?> ，Map<?,?></li><li>List&lt;?&gt;是List<String>、List<Object>等各种泛型List的父类</li></ul></li><li><p>读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object</p></li><li><p>对于List&lt;?&gt;不能向其内部添加数据——&gt;因为我们不知道c的元素类型，我们不能向其中添加对象</p><ul><li>唯一的例外是null，它是所有类型的成员</li></ul></li><li><p>将任意元素加入到其中不是类型安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">c.add(<span class="keyword">new</span> Object()); <span class="comment">// 编译时错误</span></span><br></pre></td></tr></table></figure></li><li><p>可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。</p></li><li><p>注意点</p><ul><li>不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用</li><li>不能用在泛型类的声明上</li><li>不能用在创建对象上，右边属于创建集合对象</li></ul></li><li><p>有限制条件的通配符</p><ul><li>通配符指定上限：上限extends:使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A:</span><br><span class="line">     G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span><br></pre></td></tr></table></figure><ul><li>通配符指定下限：下限super:使用时指定的类型不能小于操作的类，即&gt;=</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> A:</span><br><span class="line">     G&lt;? <span class="keyword">super</span> A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span><br></pre></td></tr></table></figure></li><li><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;? extends Number&gt;</span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line">  </span><br><span class="line">&lt;? <span class="keyword">super</span> Number&gt;</span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br><span class="line">  </span><br><span class="line">&lt;? extends Comparable&gt;</span><br><span class="line"><span class="comment">//只允许泛型为实现Comparable接口的实现类的引用调用</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;范型的理解&quot;&gt;&lt;a href=&quot;#范型的理解&quot; class=&quot;headerlink&quot; title=&quot;范型的理解&quot;&gt;&lt;/a&gt;范型的理解&lt;/h2&gt;&lt;h3 id=&quot;为什么要有泛型&quot;&gt;&lt;a href=&quot;#为什么要有泛型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇</title>
    <link href="https://asteroidcs.github.io/undefined/43fa.html"/>
    <id>https://asteroidcs.github.io/undefined/43fa.html</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2020-12-08T07:18:47.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java：贪吃蛇游戏笔记"><a href="#Java：贪吃蛇游戏笔记" class="headerlink" title="Java：贪吃蛇游戏笔记"></a>Java：贪吃蛇游戏笔记</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>创建一个窗体，用于游戏界面显示 ——&gt; 继承Java中的JFrame窗体类，设置自定义的参数</li><li>创建游戏棋盘，用于Snake移动 ——&gt; JPanel类的实例化，并且重写其中的 paint() 方法</li><li>采用链表的方式创建蛇身，移动以增删节点表示，头插法增加节点，方向采用头节点的横纵坐标加1添加节点</li><li>方向的改变用KeyListener来实现，每移动一次都需要重新绘制棋盘</li><li>蛇的运动采用timer调用timer task来反复执行蛇的移动</li><li>蛇撞墙：蛇头的横纵坐标超过了窗体的边界</li><li>蛇追尾：蛇头的坐标与其身体的任意节点坐标相等</li></ol><h2 id="创建窗体"><a href="#创建窗体" class="headerlink" title="创建窗体"></a>创建窗体</h2><ul><li><input disabled="" type="checkbox"> 创建一个MainFrame类继承JFrame，表示主窗口<ul><li>定义窗体的空参构造器，初始化窗体参数</li><li>初始化窗体参数的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义窗体的空参构造器，初始化窗体参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化窗体参数的方法</span></span><br><span class="line">        initFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> MainFrame类中写一个initFrame方法，初始化窗体参数：<ul><li>窗体标题：setTitle()</li><li>窗体尺寸：setSize()</li><li>窗体固定显示位置：setLocation()</li><li>窗体大小能否改变：setResizable()</li><li>窗体关闭按钮的作用：setDefaultCloseOperation()</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗体标题</span></span><br><span class="line">        setTitle(<span class="string">&quot;贪吃蛇&quot;</span>);</span><br><span class="line">        <span class="comment">//窗体尺寸</span></span><br><span class="line">        setSize(<span class="number">610</span>, <span class="number">640</span>);</span><br><span class="line">        <span class="comment">//固定窗体显示位置</span></span><br><span class="line">        setLocation(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置窗体大小不能改变</span></span><br><span class="line">        setResizable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//设置窗体关闭按钮的作用（退出程序）</span></span><br><span class="line">        setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在MainFrame中添加一个main方法，创建窗体并运行，就可以看到窗口了<ul><li>窗体类实例化</li><li>显示窗体</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗体类实例化</span></span><br><span class="line">        MainFrame mainFrame = <span class="keyword">new</span> MainFrame();</span><br><span class="line">        <span class="comment">//显示窗体</span></span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="创建游戏棋盘"><a href="#创建游戏棋盘" class="headerlink" title="创建游戏棋盘"></a>创建游戏棋盘</h2><ul><li><input disabled="" type="checkbox"> 在JFrame类中写一个initGamePanel方法，初始化游戏棋盘<ul><li>JPanel类实例化，并重写其中的paint方法 ——&gt; paint是用来绘制面板中的内容—棋盘格<ul><li>设置画笔的颜色：setColor（）</li><li>绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（）</li><li>绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（）</li></ul></li><li>将棋盘添加到窗体中：add( )</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//JPanel实例化，并重写其中的paint方法</span></span><br><span class="line">        JPanel jPanel = <span class="keyword">new</span> JPanel() &#123;</span><br><span class="line">            <span class="comment">//paint是用来绘制面板中的内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//g 相当于一个画笔，用于绘制</span></span><br><span class="line">                <span class="comment">//设置画笔的颜色</span></span><br><span class="line">                g.setColor(Color.BLACK);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//绘制棋盘</span></span><br><span class="line">                <span class="comment">//绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    g.drawLine(<span class="number">0</span>, i * <span class="number">15</span>, <span class="number">600</span>, i * <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">40</span>; j++) &#123;</span><br><span class="line">                    g.drawLine(j * <span class="number">15</span>, <span class="number">0</span>, j * <span class="number">15</span>, <span class="number">600</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将棋盘添加到窗体中</span></span><br><span class="line">        add(jPanel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="创建蛇的节点：用于构建蛇与食物"><a href="#创建蛇的节点：用于构建蛇与食物" class="headerlink" title="创建蛇的节点：用于构建蛇与食物"></a>创建蛇的节点：用于构建蛇与食物</h2><ul><li><input disabled="" type="checkbox"> 创建节点类：<ul><li>在棋盘上以横纵坐标创建一个节点</li><li>随机生成节点位置：用于随机生成食物  random()方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;  <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;  <span class="comment">// 纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成位置：用于随机生成食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成横坐标</span></span><br><span class="line">        <span class="keyword">this</span>.x = random.nextInt(<span class="number">40</span>);</span><br><span class="line">        <span class="comment">//随机生成纵坐标</span></span><br><span class="line">        <span class="keyword">this</span>.y = random.nextInt(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建蛇身：采用链表的方式构建蛇"><a href="#创建蛇身：采用链表的方式构建蛇" class="headerlink" title="创建蛇身：采用链表的方式构建蛇"></a>创建蛇身：采用链表的方式构建蛇</h2><ul><li><input disabled="" type="checkbox"> 多个节点构成蛇身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//蛇的身体</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; snakeBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化蛇身</span></span><br><span class="line">        initSnake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇身</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        snakeBody = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建节点，添加到集合中</span></span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">16</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">17</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">18</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">19</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title">getSnakeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snakeBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把🐍绘制到棋盘上"><a href="#把🐍绘制到棋盘上" class="headerlink" title="把🐍绘制到棋盘上"></a>把🐍绘制到棋盘上</h2><ul><li><input disabled="" type="checkbox"> 在MainFrame类中实现Snake类对象化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Snake snake; <span class="comment">//蛇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化蛇</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        snake = <span class="keyword">new</span> Snake();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在MainFrame类中的initGamePanel方法中写入绘制蛇身的代码<ul><li>绘制蛇身：fillRect（）——&gt;  绘制节点的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制蛇</span></span><br><span class="line">LinkedList&lt;Node&gt; body = snake.getSnakeBody();</span><br><span class="line"><span class="keyword">for</span> (Node node : body) &#123;</span><br><span class="line">    g.fillRect(node.getX() * <span class="number">15</span>, node.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="让蛇移动"><a href="#让蛇移动" class="headerlink" title="让蛇移动"></a>让蛇移动</h2><ul><li><input disabled="" type="checkbox"> 定义枚举类Direction，存放蛇移动的方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    UP, DOWN, LEFT, RIGHT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在Snake类中定义direction属性，用于控制蛇的运动方向，默认向左</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蛇的运动方向：默认向左</span></span><br><span class="line">    <span class="keyword">private</span> Direction direction = Direction.LEFT;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在Snake类中写一个move（）方法，控制蛇移动<ul><li>蛇会沿着蛇头的方向移动</li><li>控制蛇移动：蛇头添加节点，蛇尾删除节点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蛇会沿着蛇头的方向移动</span></span><br><span class="line">    <span class="comment">//控制蛇移动：蛇头添加节点，蛇尾删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">////获取蛇头</span></span><br><span class="line">        Node head = snakeBody.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最后的节点</span></span><br><span class="line">        snakeBody.removeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 采用定时器，在指定时间内调用蛇移动<ul><li>每次移动后都需要重新绘制棋盘</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> Timer timer; <span class="comment">//定时器，在指定时间内调用蛇移动的方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化定时器</span></span><br><span class="line">    initTimer();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//蛇移动</span></span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加键盘监听"><a href="#添加键盘监听" class="headerlink" title="添加键盘监听"></a>添加键盘监听</h2><ul><li><input disabled="" type="checkbox"> 设置键盘监听，让蛇随着上下左右移动，addKeyListener（）<ul><li>蛇的运动方向不能与当前方向相反 </li><li>每次按下方向键都会改变蛇的运动方向</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置键盘监听，让蛇随着上下左右移动</span></span><br><span class="line">    setKeyListener();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKeyListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addKeyListener(<span class="keyword">new</span> KeyAdapter() &#123;</span><br><span class="line">            <span class="comment">//当键盘按下时会自动调用此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//键盘中每一个键都有一个编号</span></span><br><span class="line">                <span class="keyword">switch</span> (e.getKeyCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_UP:  <span class="comment">// 上键</span></span><br><span class="line">                        <span class="comment">//修改蛇的运动方向不能与当前方向相反</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.DOWN) &#123;</span><br><span class="line">                            <span class="comment">//修改蛇的运动方向</span></span><br><span class="line">                            snake.setDirection(Direction.UP);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_DOWN:  <span class="comment">// 下键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.UP) &#123;</span><br><span class="line">                            snake.setDirection(Direction.DOWN);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_LEFT:  <span class="comment">//左键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.RIGHT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.LEFT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_RIGHT:  <span class="comment">// 右键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.LEFT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.RIGHT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;a</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加边界处理"><a href="#添加边界处理" class="headerlink" title="添加边界处理"></a>添加边界处理</h2><ul><li><input disabled="" type="checkbox"> 当蛇移动到边界处就游戏结束，把标记改为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//定义一个标记true表示蛇还活着，可以运动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLiving = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 判断蛇是否撞墙：头节点的坐标是否越界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">head = body.getFirst();</span><br><span class="line"><span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">  isLiving = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 判断蛇是否碰到自己的身体：头节点坐标与任意身体节点的坐标一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">  Node node = body.get(i);</span><br><span class="line">  <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">    isLiving = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 优化move( )代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLiving) &#123;</span><br><span class="line">            <span class="comment">//获取蛇头</span></span><br><span class="line">            Node head = body.getFirst();</span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEFT:</span><br><span class="line">                    <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RIGHT:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除最后的节点</span></span><br><span class="line">            body.removeLast();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">            head = body.getFirst();</span><br><span class="line">            <span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">                isLiving = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否碰到自己的身体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">                Node node = body.get(i);</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">                    isLiving = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="把食物绘制到棋盘上"><a href="#把食物绘制到棋盘上" class="headerlink" title="把食物绘制到棋盘上"></a>把食物绘制到棋盘上</h2><ul><li><input disabled="" type="checkbox"> 此处的食物就是节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> Node food; <span class="comment">//食物</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化食物</span></span><br><span class="line">    initFood();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     food = <span class="keyword">new</span> Node();</span><br><span class="line">     food.random();  <span class="comment">// food随机出现</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//绘制食物</span></span><br><span class="line">    g.fillRect(food.getX() * <span class="number">15</span>, food.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="吃食物"><a href="#吃食物" class="headerlink" title="吃食物"></a>吃食物</h2><ul><li><input disabled="" type="checkbox"> 吃食物：沿着蛇头的移动方向添加节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//吃食物：沿着蛇头的移动方向添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Node food)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取蛇头</span></span><br><span class="line">        Node head = snakeBody.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 吃食物：判断蛇头是否和食物重合，即头节点坐标与食物坐标一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//吃食物：判断蛇头是否和食物重合</span></span><br><span class="line">                Node head = snake.getSnakeBody().getFirst();</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123;</span><br><span class="line">                    snake.eat(food);</span><br><span class="line">                    food.random();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="MainFrame类"><a href="#MainFrame类" class="headerlink" title="MainFrame类"></a>MainFrame类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 窗体设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 7:31 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//java中有准备好的窗体类，继承即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Snake snake; <span class="comment">//蛇</span></span><br><span class="line">    <span class="keyword">private</span> JPanel jPanel; <span class="comment">//游戏棋盘</span></span><br><span class="line">    <span class="keyword">private</span> Timer timer; <span class="comment">//定时器，在指定时间内调用蛇移动的方法</span></span><br><span class="line">    <span class="keyword">private</span> Node food; <span class="comment">//食物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化窗体参数</span></span><br><span class="line">        <span class="keyword">this</span>.initFrame();</span><br><span class="line">        <span class="comment">//初始化游戏棋盘</span></span><br><span class="line">        <span class="keyword">this</span>.initGamePanel();</span><br><span class="line">        <span class="comment">//初始化蛇</span></span><br><span class="line">        <span class="keyword">this</span>.initSnake();</span><br><span class="line">        <span class="comment">//初始化食物</span></span><br><span class="line">        initFood();</span><br><span class="line">        <span class="comment">//初始化定时器</span></span><br><span class="line">        initTimer();</span><br><span class="line">        <span class="comment">//设置键盘监听，让蛇随着上下左右移动</span></span><br><span class="line">        setKeyListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建窗体对象，并显示</span></span><br><span class="line">        MainFrame mainFrame = <span class="keyword">new</span> MainFrame();</span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        food = <span class="keyword">new</span> Node();</span><br><span class="line">        food.random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKeyListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addKeyListener(<span class="keyword">new</span> KeyAdapter() &#123;</span><br><span class="line">            <span class="comment">//当键盘按下时会自动调用此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//键盘中每一个键都有一个编号</span></span><br><span class="line">                <span class="keyword">switch</span> (e.getKeyCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_UP:  <span class="comment">// 上键</span></span><br><span class="line">                        <span class="comment">//修改蛇的运动方向不能与当前方向相反</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.DOWN) &#123;</span><br><span class="line">                            <span class="comment">//修改蛇的运动方向</span></span><br><span class="line">                            snake.setDirection(Direction.UP);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_DOWN:  <span class="comment">// 下键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.UP) &#123;</span><br><span class="line">                            snake.setDirection(Direction.DOWN);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_LEFT:  <span class="comment">//左键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.RIGHT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.LEFT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_RIGHT:  <span class="comment">// 右键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.LEFT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.RIGHT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//吃食物：判断蛇头是否和食物重合</span></span><br><span class="line">                Node head = snake.getBody().getFirst();</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123;</span><br><span class="line">                    snake.eat(food);</span><br><span class="line">                    food.random();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        snake = <span class="keyword">new</span> Snake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化游戏棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        jPanel = <span class="keyword">new</span> JPanel() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//清空棋盘</span></span><br><span class="line">                g.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Graphics g 相当于一个画笔，用于绘制</span></span><br><span class="line">                <span class="comment">//绘制横线</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    g.drawLine(<span class="number">0</span>, i * <span class="number">15</span>, <span class="number">600</span>, i * <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制竖线</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">40</span>; j++) &#123;</span><br><span class="line">                    g.drawLine(j * <span class="number">15</span>, <span class="number">0</span>, j * <span class="number">15</span>, <span class="number">600</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制蛇</span></span><br><span class="line">                LinkedList&lt;Node&gt; body = snake.getBody();</span><br><span class="line">                <span class="keyword">for</span> (Node node : body) &#123;</span><br><span class="line">                    g.fillRect(node.getX() * <span class="number">15</span>, node.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制食物</span></span><br><span class="line">                g.fillRect(food.getX() * <span class="number">15</span>, food.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把棋盘添加到窗体中</span></span><br><span class="line">        <span class="keyword">this</span>.add(jPanel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化窗体参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置窗体标题</span></span><br><span class="line">        <span class="keyword">this</span>.setTitle(<span class="string">&quot;贪吃蛇&quot;</span>);</span><br><span class="line">        <span class="comment">//设置窗体宽高</span></span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>, <span class="number">615</span>);</span><br><span class="line">        <span class="comment">//设置窗体位置</span></span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置关闭按钮的作用（退出程序）</span></span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//设置窗体大小不可变</span></span><br><span class="line">        <span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 节点类：每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:14 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成横坐标</span></span><br><span class="line">        <span class="keyword">this</span>.x = random.nextInt(<span class="number">40</span>);</span><br><span class="line">        <span class="comment">//随机生成纵坐标</span></span><br><span class="line">        <span class="keyword">this</span>.y = random.nextInt(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Snake类"><a href="#Snake类" class="headerlink" title="Snake类"></a>Snake类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置，采用链表的方式构建蛇</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">    <span class="comment">//蛇的身体</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; body;</span><br><span class="line">    <span class="comment">//蛇的运动方向：默认向左</span></span><br><span class="line">    <span class="keyword">private</span> Direction direction = Direction.LEFT;</span><br><span class="line">    <span class="comment">//蛇是否活着</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLiving = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，在创建Snake对象时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化蛇身</span></span><br><span class="line">        initSnake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇身</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        body = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建节点，添加到集合中</span></span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">16</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">17</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">18</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">19</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//蛇会沿着蛇头的方向移动</span></span><br><span class="line">    <span class="comment">//控制蛇移动：蛇头添加节点，蛇尾删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLiving) &#123;</span><br><span class="line">            <span class="comment">//获取蛇头</span></span><br><span class="line">            Node head = body.getFirst();</span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEFT:</span><br><span class="line">                    <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RIGHT:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除最后的节点</span></span><br><span class="line">            body.removeLast();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">            head = body.getFirst();</span><br><span class="line">            <span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">                isLiving = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否碰到自己的身体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">                Node node = body.get(i);</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">                    isLiving = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">getDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDirection</span><span class="params">(Direction direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//吃食物：沿着蛇头的移动方向添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Node food)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取蛇头</span></span><br><span class="line">        Node head = body.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Direction类"><a href="#Direction类" class="headerlink" title="Direction类"></a>Direction类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:53 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    UP, DOWN, LEFT, RIGHT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201208145319260.png" alt="image-20201208145319260" style="zoom: 67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java：贪吃蛇游戏笔记&quot;&gt;&lt;a href=&quot;#Java：贪吃蛇游戏笔记&quot; class=&quot;headerlink&quot; title=&quot;Java：贪吃蛇游戏笔记&quot;&gt;&lt;/a&gt;Java：贪吃蛇游戏笔记&lt;/h2&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;</summary>
      
    
    
    
    <category term="Game" scheme="https://asteroidcs.github.io/categories/Game/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
    <category term="游戏" scheme="https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Java语言概述</title>
    <link href="https://asteroidcs.github.io/undefined/e28.html"/>
    <id>https://asteroidcs.github.io/undefined/e28.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-08T07:03:50.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识图解"><a href="#基础知识图解" class="headerlink" title="基础知识图解"></a>基础知识图解</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/766D3894-DEF8-4EDD-8F15-A13171BFFF33.png" alt="766D3894-DEF8-4EDD-8F15-A13171BFFF33"  /><h2 id="软件开发介绍"><a href="#软件开发介绍" class="headerlink" title="软件开发介绍"></a>软件开发介绍</h2><h3 id="基础常识"><a href="#基础常识" class="headerlink" title="基础常识"></a>基础常识</h3><ol><li>软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件<ul><li>系统软件：Windows，Mac os，linux，unix，android，iOS…</li><li>应用软件：word，ppt，画图板…</li></ul></li><li>人机交互方式：图形化界面 vs 命令行方式</li><li>应用程序 = 算法 ➕ 数据结构</li></ol><h3 id="常用的DOS指令"><a href="#常用的DOS指令" class="headerlink" title="常用的DOS指令"></a>常用的DOS指令</h3><ul><li>dir：列出当前目录下的文件以及文件夹</li><li>md：创建目录</li><li>rd；删除目录</li><li>cd：进入目录</li><li>cd..：返回到上一级目录</li><li>cd\：退回到根目录</li><li>del：删除文件</li><li>exit：推出dos命令行</li><li>ech javase&gt;：创建文件，如：ech javase&gt;1.doc，ech javase &gt; 1.jpg</li></ul><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li>⬅️ ➡️：移动光标</li><li>⬆️ ⬇️：调阅历史操作命令</li><li>Delete 和 Backspace：删除字符</li></ul><h3 id="计算机语言的发展迭代史"><a href="#计算机语言的发展迭代史" class="headerlink" title="计算机语言的发展迭代史"></a>计算机语言的发展迭代史</h3><ul><li><p>第一代：机器语言：指令以二进制代码形式存在</p><p>第二代：汇编语言：使用助记符表示一条机器指令</p><p>第三代：高级语言：</p><ul><li>面向过程：C、Pascal、Fortran</li><li>面向对象：Java、JS、Python、Scala…</li></ul></li></ul><h4 id="Java语言应用的领域"><a href="#Java语言应用的领域" class="headerlink" title="Java语言应用的领域"></a>Java语言应用的领域</h4><ul><li>Java Web开发：后台开发</li><li>大数据开发：</li><li>Android应用程序开发：客户端开发</li></ul><h3 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h3><ol><li>面向对象性： </li><li><ul><li>两个要素：类、对象</li><li>三个特征：封装、继承、多态</li></ul></li><li>健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏</li><li>跨平台型：write once，run anywhere：一次编译，到处运行</li><li>原理：只需要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM JAVA Virtual Machine）即可。由JVM来负责Java程序在该系统中的运行。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/2C3E0C74-6AE1-4F69-80A7-1587ABFECFC0.png" alt="2C3E0C74-6AE1-4F69-80A7-1587ABFECFC0"></p><h2 id="Java核心机制"><a href="#Java核心机制" class="headerlink" title="Java核心机制"></a>Java核心机制</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ul><li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器</li><li>对于不同的平台，由不同的虚拟机</li><li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li><li>java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/57F1EE3D-6203-4996-B532-87DC650C407D.png" alt="57F1EE3D-6203-4996-B532-87DC650C407D" style="zoom: 33%;" /><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>不再使用的内存空间应回收——垃圾回收</li><li>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预</li><li>Java程序==还会出现内存泄漏和内存溢出问题==</li></ul><h2 id="Java语言的环境搭建"><a href="#Java语言的环境搭建" class="headerlink" title="Java语言的环境搭建"></a>Java语言的环境搭建</h2><h3 id="什么是JDK，JRE"><a href="#什么是JDK，JRE" class="headerlink" title="什么是JDK，JRE"></a>什么是<strong>JDK</strong>，<strong>JRE</strong></h3><ol><li><p>JDK(Java Development Kit Java开发工具包)</p><ul><li><p>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了 JRE。所以安装了JDK，就不用在单独安装JRE了。</p><p>其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等</p></li></ul></li><li><p>RE(Java Runtime Environment Java运行环境)</p><ul><li>包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等， 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li></ul></li></ol><h3 id="Java语言的环境搭建-JDK、JRE、JVM关系"><a href="#Java语言的环境搭建-JDK、JRE、JVM关系" class="headerlink" title="Java语言的环境搭建:JDK、JRE、JVM关系"></a><strong>Java</strong>语言的环境搭建:<strong>JDK</strong>、<strong>JRE</strong>、<strong>JVM</strong>关系</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207143107565.png" alt="image-20201207143107565" style="zoom: 33%;" /><h2 id="开发体验—-HelloWorld"><a href="#开发体验—-HelloWorld" class="headerlink" title="开发体验— HelloWorld"></a>开发体验— HelloWorld</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207143254624.png" alt="image-20201207143254624" style="zoom: 33%;" /><h2 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释(Comment)"></a>注释(Comment)</h2><h3 id="Java中的注释类型"><a href="#Java中的注释类型" class="headerlink" title="Java中的注释类型"></a>Java中的注释类型</h3><ul><li>//单行注释</li><li>/* <em>多行注释</em> */</li><li>/** <em>文档注释（Java特有）</em> **/</li></ul><h3 id="单行和多行注释的作用"><a href="#单行和多行注释的作用" class="headerlink" title="单行和多行注释的作用"></a>单行和多行注释的作用</h3><ol><li>对所写程序进行解释说明，增强可读性，方便自己和别人。</li><li>调试所写代码（注释掉不需要运行部分）。</li><li>特点：单行和多行注释掉的内容不参与编译，编译以后生成的.class文件中不包含注释掉的信息。</li></ol><h3 id="文档注释的使用"><a href="#文档注释的使用" class="headerlink" title="文档注释的使用"></a>文档注释的使用</h3><ol><li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</li><li>操作方式<ul><li>&gt;javadoc -d [生成文件名] -author -version [解析文件名.java]（-author和-version分别为注释当中@author和@version后面的内容）</li></ul></li></ol><ul><li><strong>注意：多行注释不能嵌套使用</strong></li></ul><h2 id="第1个Java代码"><a href="#第1个Java代码" class="headerlink" title="第1个Java代码"></a>第1个Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//arguments参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对第一个Java程序总结"><a href="#对第一个Java程序总结" class="headerlink" title="对第一个Java程序总结"></a>对第一个Java程序总结</h3><ol><li>java程序的编写-编译-运行的过程<ul><li>编写：我们将编写的java代码保存在以“.java”结尾的源文件中</li><li>编译：使用javac.exe来编译我们的java源文件。格式：javac 源文件名.java</li><li>运行：使用java.exe解释运行我们的字节码文件（.class)。格式：java 类名</li></ul></li><li>在一个java源文件中可以声明多个类（class），但是只能有一个类声明为public的，而且要求声明为public的类的类名必须与源文件名必须相同。</li><li>程序的入口是main()方法，格式是固定的。可以写成：public static void main(String[] args)或public static void main(String[] a)或public static void main(String a[])</li><li>输出语句<ul><li>System.out.println()：输出后换行，无内容则只换行</li><li>System.out.print()：输出后不换行</li></ul></li><li>每一个执行语句都以分号结尾，每个执行语句只要以分号隔开即使不换行也不影响执行</li><li>编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。</li></ol><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ol><li>java语言的特点是什么？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面向对象性：两个基本概念：类、对象；三大特性：封装、继承、多态</span><br><span class="line">健壮性：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</span><br><span class="line">跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”</span><br></pre></td></tr></table></figure><ol start="2"><li>System.out.println()和System.out.print()有什么区别？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前者输出内容后换行，后者输出后不换行。</span><br></pre></td></tr></table></figure><ol start="3"><li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：可以。但最多只有一个类名声明为<span class="keyword">public</span>，与文件名相同。</span><br></pre></td></tr></table></figure><ol start="4"><li>JDK,JRE和JVM的关系是什么？以及JDK、JRE包含的主要结构有哪些？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系：JDK包含JRE，JRE包含JVM</span><br><span class="line">JDK = JRE + Java开发工具（javac.exe、java.exe、javadoc.exe）</span><br><span class="line">JRD = JVM + Java核心类库</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础知识图解&quot;&gt;&lt;a href=&quot;#基础知识图解&quot; class=&quot;headerlink&quot; title=&quot;基础知识图解&quot;&gt;&lt;/a&gt;基础知识图解&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/asteroidcs/pic-go-cloud/raw/m</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第三章 数组</title>
    <link href="https://asteroidcs.github.io/undefined/4fb4.html"/>
    <id>https://asteroidcs.github.io/undefined/4fb4.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-08T07:03:50.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h2><ul><li>数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。</li></ul><h3 id="数组的常见概念"><a href="#数组的常见概念" class="headerlink" title="数组的常见概念"></a>数组的常见概念</h3><ol><li>数组名</li><li>标（或索引）</li><li>元素</li><li>数组的长度：元素的个数</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>数组是有序排列的；</li><li>数组属于引用数据类型，但是数组的元素既可以是基本数据类型，也可以是引用数据类型；</li><li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址；</li><li>数组的长度一旦确定，就不能修改；</li><li>可以通过下标（或索引）的方式调用指定位置的元素，速度很快。</li></ol><h3 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3><ol><li>按照维数：一维数组、二维数组……</li><li>按照数组元素类型分类：基本数据类型元素的素组、引用数据类型元素的数组。</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p></li><li><p>数据的存储结构：</p><ul><li><p>线性表：顺序表（比如：数组）、链表、栈、队列</p></li><li><p>树形结构：二叉树</p></li><li><p>图形结构：</p></li></ul></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>排序算法</li><li>搜（检索）索算法</li></ol><h2 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h2><h3 id="一维数组的声明和初始化"><a href="#一维数组的声明和初始化" class="headerlink" title="一维数组的声明和初始化"></a>一维数组的声明和初始化</h3><ol><li>声明：<code>int[] ins;</code></li><li>静态初始化：数组的初始化和数组的赋值操作同时进行。<ul><li><code>int ids = new int[]&#123;1001,1002,1003,1004&#125;;</code></li></ul></li><li>动态初始化：数组的初始化和数组的赋值操作分开进行<ul><li><code>String[] names = new String[5];</code></li></ul></li><li>错误写法<ul><li><code>int[] arr1 = new int[];</code></li><li><code>int[5] arr2 = new int[5];</code></li><li><code>int [] arr3 = new int[3]&#123;1,2,3&#125;;</code></li></ul></li><li>总结：数组一旦初始化完成，其长度就确定了。</li></ol><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定函数指定位置的函数<ul><li>通过索引（角标）的方式调用，索引（角标）从0开始，直到数组的长度-1结束</li></ul></li><li>如何获取数组的长度<ul><li>属性：length</li><li>使用：<code>names.length</code></li></ul></li><li>遍历数组<ul><li><code>for(int i = 0; i &lt; names.length; i++)&#123;&#125;</code></li></ul></li></ol><h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207154420142.png" alt="image-20201207154420142" style="zoom:33%;" /><h3 id="数组的内存解析"><a href="#数组的内存解析" class="headerlink" title="数组的内存解析"></a>数组的内存解析</h3><ol><li>栈（stack）：存放局部变量</li><li>堆（heap)：存放new出来的结构（对象数组）</li><li>方法区：常量池、静态域</li></ol><h4 id="内存的简化结构"><a href="#内存的简化结构" class="headerlink" title="内存的简化结构"></a>内存的简化结构</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207154613393.png" alt="image-20201207154613393" style="zoom: 33%;" /><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200802215212.png" alt="img" style="zoom: 67%;" /><ul><li>栈中的所有地址为Java虚拟机计算出来的哈希地址，并非真正的内存地址</li></ul><h2 id="多维数组的使用"><a href="#多维数组的使用" class="headerlink" title="多维数组的使用"></a>多维数组的使用</h2><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ol><li>理解：对于二维数组的理解，可以看成是一维数组array1的元素而存在。从数组底层的运行机制来看，其实没有多维数组。</li><li>二维数组的使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];<span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误情况</span></span><br><span class="line"></span><br><span class="line">String[][] arr4 = <span class="keyword">new</span> String[][<span class="number">4</span>];</span><br><span class="line">String[<span class="number">4</span>][<span class="number">3</span>] arr5 = <span class="keyword">new</span> String[][];</span><br><span class="line"><span class="keyword">int</span>[][] arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li>Tips：中括号（[]）的位置可以放在类名或者变量名后面；或者类名后面放一个，变量名后面放一个（二维数组）。</li><li>类型推断：<code>int[][] arr7 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; //省略new int[][]</code></li></ul><h3 id="数组的基本操作-1"><a href="#数组的基本操作-1" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定位置的函数<ul><li><code>arry[i][j]; //第i行第j列的元素</code></li></ul></li><li>如何获取数组长度<ul><li><code>arr4.length;</code></li><li><code>arr4[0].length;</code></li></ul></li><li>如何遍历数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; a &lt;= arr4.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= arr4[i].length)&#123;</span><br><span class="line">        <span class="comment">//执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组元素的默认初始化值-1"><a href="#数组元素的默认初始化值-1" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><ol><li><p>规定：二维数组分为外层数组的元素和内层数组的元素</p><p><code>int[][] arr = new int[4][3];</code></p></li><li><p>外层元素：arr[0]，arr[1]等；</p></li><li><p>内层元素：arr[0][0]，arr[1][2]等；</p></li><li><p>初始化方式一：<code>int[][] arr = new int[4][3];</code></p><ul><li>外层元素的初始化值为：地址值</li><li>内层元素的初始化值：与一维数组初始化情况相同</li></ul></li><li><p>初始化方式二：<code>int[][] arr = new int[4][];</code></p><ul><li>外层元素的初始化值为：null</li><li>内层元素的初始化值为：不能调用，否则报错</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155151188.png" alt="image-20201207155151188" style="zoom: 67%;" /><h2 id="数组中涉及到的常见算法"><a href="#数组中涉及到的常见算法" class="headerlink" title="数组中涉及到的常见算法"></a>数组中涉及到的常见算法</h2><ol><li>数组元素的赋值（杨辉三角、回形书等）（面试常考）</li><li>求数值型数组中元素的最大值、最小值、平均数、总数等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求数值型数组中元素的最大值、最小值、平均数、总和等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-27        22:14:07</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            array[i] = (<span class="keyword">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        minValue = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / array.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n最大值为：&quot;</span> + maxValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值为：&quot;</span> + minValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数为：&quot;</span> + avg);</span><br><span class="line">        System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>数组的复制、反转、查找（线性查找、二分法查找）（面试会考）</p><ul><li><p>复制：通过遍历元素的方式进行复制操作，赋值只能使得新数组值相同一块内存区域，修改其中一个，原数组就得一起改变，相当于Linux中的硬链接</p></li><li><p>反转：通过中间变量实现反转</p></li><li><p>查找</p><ul><li>线性查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String dest = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定元素，位置为：&quot;</span> + i);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没找到！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二分法查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有要查找的数组必须有序</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dest1 = -<span class="number">34</span>;</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;<span class="comment">//初始首索引</span></span><br><span class="line"><span class="keyword">int</span> end = arr2.length - <span class="number">1</span>;<span class="comment">//初始末索引</span></span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (head + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(dest1 == arr2[mid])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + mid);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr2[mid] &gt; dest1)&#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;很遗憾，没有找到！&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组元素的排序算法（面试最常考）</p><ul><li>排序：假设含有n个记录的序列为(R1, R2,…, Rn)，其相应的关键字序列为(K1, K2,…, Kn)。将这些记录重新排序为(Ri1, Ri2,…, Rin)，使得相应的关键字满足条件Ki1 &lt;= Ki2 &lt;=…&lt;= Kin，这样的一种操作成为排序。<ul><li>通常来说，排序的目的是快速查找。</li></ul></li><li>衡量排序算法的优劣<ul><li>时间复杂度：分析关键字的比较次数和记录的移动次数。</li><li>空间复杂度：分析排序算法中徐需要多少辅助内存。</li><li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B先后次序保持不变，则称这种排序算法是稳定的。</li></ul></li></ul></li></ol><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><ol><li>内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。</li><li>十大内部排序算法（和具体语言无关），前八种较常用 (数据结构与算法中学)</li></ol><h3 id="各种排序算法的比较"><a href="#各种排序算法的比较" class="headerlink" title="各种排序算法的比较"></a>各种排序算法的比较</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155818904.png" alt="image-20201207155818904"  /><ol><li>从平均时间而言：快速排序最佳，但在最坏的情况下，时间性能不如堆排序和归并排序。</li><li>从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li><li>从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序。</li><li>从待排序的记录数n的大小看：n较小时，宜采用简单排序；而n较大时，宜采用改进排序。</li></ol><h3 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h3><ol><li>若n较小（如n≤50），可采用直接插入或直接选择排序。</li><li>当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。</li><li>若文件初始状态基本有序（正序），则应选用直接插入、冒泡或随机的快速排序为宜。</li><li>若n较大，则应采用时间复杂度为O（nlgn）的排序方法：快速排序、堆排序或归并排序</li></ol><h3 id="算法五大特征"><a href="#算法五大特征" class="headerlink" title="算法五大特征"></a>算法五大特征</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155937296.png" alt="image-20201207155937296" style="zoom: 33%;" /><h2 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h2><ol><li>java.util.Arrays类即为操作数组的工具类，它包含了用来操作数组（比如排序和搜索）的各种方法。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160246169.png" alt="image-20201207160246169"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> java.util.Arrays：操作数组的共工具类，里面定义了很多操作数组的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-28        16:56:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isEquals = Arrays.equals(arr1,arr2);</span><br><span class="line">        System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.String toString(int[] a):输出数组信息</span></span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.void fill(int[] a,int val):将指定的值填充到数组中</span></span><br><span class="line">        Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.void sort(int[] a):对数组进行排序</span></span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.int binarySearch(int[] a,int key):对排序后的数组进行二分法检索指定的值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">333</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中常见的一异常"><a href="#数组中常见的一异常" class="headerlink" title="数组中常见的一异常"></a>数组中常见的一异常</h2><ul><li>注意：编译时不会报错</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160446090.png" alt="image-20201207160446090" style="zoom: 33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组的概述&quot;&gt;&lt;a href=&quot;#数组的概述&quot; class=&quot;headerlink&quot; title=&quot;数组的概述&quot;&gt;&lt;/a&gt;数组的概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第四章 面向对象（上）</title>
    <link href="https://asteroidcs.github.io/undefined/df1b.html"/>
    <id>https://asteroidcs.github.io/undefined/df1b.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-08T07:03:50.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java面对对象学习的三条主线"><a href="#Java面对对象学习的三条主线" class="headerlink" title="Java面对对象学习的三条主线"></a>Java面对对象学习的三条主线</h2><ol><li>Java类及类的成员：属性、方法、构造器；代码块、内部类；</li><li>面向对象的三大特征：封装性、继承性、多态性（、抽样性）；</li><li>其他关键字：this、super、final、abstract、interface、package、import等。</li></ol><h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><h3 id="面向过程与面向对象区别"><a href="#面向过程与面向对象区别" class="headerlink" title="面向过程与面向对象区别"></a>面向过程与面向对象区别</h3><ol><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ol><h3 id="面对对象的三大特征"><a href="#面对对象的三大特征" class="headerlink" title="面对对象的三大特征"></a>面对对象的三大特征</h3><ol><li>封装（Encapsulation）</li><li>继承（Inheritance）</li><li>多态（Polymorphism）</li></ol><h3 id="面对对象的思想概述"><a href="#面对对象的思想概述" class="headerlink" title="面对对象的思想概述"></a>面对对象的思想概述</h3><ol><li>程序员从面向过程的执行者转化成了面向对象的指挥者。</li><li>面对对象分析问题的思路和步骤：<ul><li>根据问题需要，选择问题所针对的现实世界中的实体。</li><li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li><li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li><li>将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。</li></ul></li></ol><h2 id="Java基本元素：类和对象"><a href="#Java基本元素：类和对象" class="headerlink" title="Java基本元素：类和对象"></a>Java基本元素：类和对象</h2><h3 id="面对对象的思想概述-1"><a href="#面对对象的思想概述-1" class="headerlink" title="面对对象的思想概述"></a>面对对象的思想概述</h3><ol><li>类（Class）和对象（Object）是面向对象的核心概念。<ul><li>类是对一类事物的描述，是抽象的、概念上的定义</li><li>对象是实际存在的该类事物的每个个体，因而也称为实例（instance）</li></ul></li><li>万物皆对象<ul><li>面对对象程序设计的重点是类的设计</li><li>类的设计，其实就是类的成员的设计</li></ul></li></ol><h3 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a>Java类及类的成员</h3><ol><li>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多不同功能的类构成的。</li><li>现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质……那么，Java中用类来描述事物也是如此。常见类的成员有：<ul><li>属性：对应类中的成员变量</li><li>行为：对应类中的成员方法</li></ul></li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160922776.png" alt="image-20201207160922776"></p><h2 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h2><h3 id="面对对象思想的实现"><a href="#面对对象思想的实现" class="headerlink" title="面对对象思想的实现"></a>面对对象思想的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dawn333.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>    一、类和对象的使用（面对对象思想落地的实现）：</span></span><br><span class="line"><span class="comment"> * 1、创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> * 2、创建类的对象</span></span><br><span class="line"><span class="comment"> * 3、通过“对象.属性”或“对象.方法”调用对象的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     二、如果创建了多个对象，则每个对象都独立的拥有一套属性。（非static）</span></span><br><span class="line"><span class="comment"> *     意味着，如果改一个对象的属性a，不影响另一个对象属性a的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-30    16:32:18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象、</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：对象.属性</span></span><br><span class="line">        p1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：对象.方法</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//************************</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p2.name);<span class="comment">//null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//************************</span></span><br><span class="line">        Person p3 = p1;</span><br><span class="line">        <span class="comment">//将p1变量保存的地址赋给p3，导致p1和p3指向了堆空间中的同一个对象实体。</span></span><br><span class="line">        System.out.println(p3.name);<span class="comment">//Tom</span></span><br><span class="line">        p3.age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(p1.age);<span class="comment">//10        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以说话，使用的语言是：&quot;</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207161029802.png" alt="image-20201207161029802" style="zoom:67%;" /><ol><li>堆（heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</li><li>通常所说的栈（stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（bolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</li><li>方法区（method area），用于存储已被虚拟机加载类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>对象内存解析</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200803230516.png" alt="03对象的内存解析" style="zoom: 50%;" /><h4 id="内存解析的说明"><a href="#内存解析的说明" class="headerlink" title="内存解析的说明"></a>内存解析的说明</h4><ol><li>引用类型的变量，只可能存储两类值：null或地址值（含变量的类型）</li><li>对象数组的内存解析</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806155821.png" alt="img" style="zoom:50%;" /><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><ol><li>关注书籍：《JVM规范》</li><li>虚拟机栈即为平时提到的栈结构，我们将局部变量存储在栈结构中。</li><li>堆，我们将new出来的结构（比如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中。</li></ol><h3 id="理解“万事万物皆对象”"><a href="#理解“万事万物皆对象”" class="headerlink" title="理解“万事万物皆对象”"></a>理解“万事万物皆对象”</h3><ol><li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。<ul><li>Scanner，String等</li><li>文件：File</li><li>网络资源：URL</li></ul></li><li>涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li></ol><h3 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h3><ol><li>理解：我们创建的对象没有显示的赋给一个变量名， 即为匿名对象。</li><li>特征：匿名对象只能代用一次。</li><li>使用：如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.triabin.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 匿名对象的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-6    16:04:02</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;正常调用：&quot;</span>);</span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象只能代用一次：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象的使用：&quot;</span>);</span><br><span class="line">        PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"><span class="comment">//        mall.show(p);</span></span><br><span class="line">        mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的价格为：&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h2><h3 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h3><ol><li>语法格式:</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207161549477.png" alt="image-20201207161549477" style="zoom: 33%;" /><ol start="2"><li>说明：<ul><li>说明<strong>1:</strong> 修饰符<ul><li>常用的权限修饰符有:private、缺省、protected、public</li><li>其他修饰符:static、final (暂不考虑) </li></ul></li><li>说明<strong>2</strong>:数据类型<ul><li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li></ul></li><li>说明<strong>3</strong>:属性名<ul><li>属于标识符，符合命名规则和规范即可。</li></ul></li></ul></li><li>举例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">//声明private变量 age</span></span><br><span class="line"><span class="keyword">public</span> String name = “Lila”; <span class="comment">//声明public变量 name &#125;</span></span><br></pre></td></tr></table></figure><h3 id="变量的分类-成员变量与局部变量"><a href="#变量的分类-成员变量与局部变量" class="headerlink" title="变量的分类:成员变量与局部变量"></a>变量的分类:成员变量与局部变量</h3><ol><li>成员变量：在方法体外，类体内声明的变量。</li><li>局部变量：在方法体内部声明的变量称。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806153535.png" alt="img"></p><ol start="3"><li><p>注意:二者在初始化值方面的异同**:**</p><ul><li><p>同:都有生命周期</p><p>异:局部变量除形参外，均需显式初始化。</p></li></ul></li><li><p>区别：</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207162027745.png" alt="image-20201207162027745" style="zoom: 50%;" /></li><li><p>代码示例：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.triabin.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类中属性的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-5    14:49:47</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(u1.name);</span><br><span class="line">        System.out.println(u1.age);</span><br><span class="line">        System.out.println(u1.isMale);</span><br><span class="line">        u1.talk(<span class="string">&quot;日语&quot;</span>);<span class="comment">//特别的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性（或成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;<span class="comment">//形参，也是局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我们使用&quot;</span> + language +<span class="string">&quot;进行交流。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String food = <span class="string">&quot;烙饼&quot;</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;北方人喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之二-方法-method"><a href="#类的成员之二-方法-method" class="headerlink" title="类的成员之二: 方法(method)"></a>类的成员之二: 方法(method)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java面对对象学习的三条主线&quot;&gt;&lt;a href=&quot;#Java面对对象学习的三条主线&quot; class=&quot;headerlink&quot; title=&quot;Java面对对象学习的三条主线&quot;&gt;&lt;/a&gt;Java面对对象学习的三条主线&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java类及类的成员：属</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Java基本语法</title>
    <link href="https://asteroidcs.github.io/undefined/2136.html"/>
    <id>https://asteroidcs.github.io/undefined/2136.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-08T07:03:50.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><h3 id="关键字（keyword）"><a href="#关键字（keyword）" class="headerlink" title="关键字（keyword）"></a>关键字（keyword）</h3><ol><li>定义：被Java语言赋予特殊含义，用作专门用途的字符（单词）。</li><li>特点：关键字中所有字母都为小写。</li><li>官方地址：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html</a></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207144700839.png" alt="image-20201207144700839" style="zoom: 33%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207144740355.png" alt="image-20201207144740355" style="zoom:33%;" /><h3 id="保留字（reserved-word）"><a href="#保留字（reserved-word）" class="headerlink" title="保留字（reserved word）"></a>保留字（reserved word）</h3><ul><li><p>ava保留字:现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字</p><p>goto 、const</p></li></ul><h2 id="标识符（Identifier）"><a href="#标识符（Identifier）" class="headerlink" title="标识符（Identifier）"></a>标识符（Identifier）</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ol><li>ava对各种变量、方法和类等要素命名时使用的字符序列称为标识符。</li><li>比如：类名、变量名、方法名、接口名、包名……</li><li>技巧：凡是自己可以取名字的地方都叫标识符。</li></ol><h3 id="定义合法标识符规则（必须遵守）"><a href="#定义合法标识符规则（必须遵守）" class="headerlink" title="定义合法标识符规则（必须遵守）"></a>定义合法标识符规则（必须遵守）</h3><ol><li>由26个英文字母大小写，0-9，_或$组成；</li><li>数字不可开头；</li><li>不可以使用关键字和保留字，但可以包含关键字和保留字；</li><li>Java中严格区分大小写，长度无限制；</li><li>标识符不能包含空格。</li></ol><h3 id="Java中名称命名规范（建议遵守）"><a href="#Java中名称命名规范（建议遵守）" class="headerlink" title="Java中名称命名规范（建议遵守）"></a>Java中名称命名规范（建议遵守）</h3><ol><li>包名：多单词组成时所有字母都小写：xxxyyyzzz；</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ；</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz；</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ；</li><li>注意<ul><li>注意1：在取名字时，为提高阅读性，要尽量有意义（见名知意）</li><li>注意2：Java采用unicode字符集，因此标识符也可以使用汉字声明，但不建议使用</li></ul></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h3><ol><li>内存中的一个存储区域；</li><li>该区域的数据可在同一类型范围内不断变化；</li><li>变量是程序中最基本的存储单元。包含变量类型（强类型：必须先声明）、变量名和存储的值。<ul><li>定义变量的格式：数据类型 变量名 = 变量值<ul><li>例：<code>int myAge = 18;</code></li></ul></li></ul></li></ol><h3 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h3><ol><li>ava中每个变量必须先声明，后使用；</li><li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了。“一对{}”即为一个作用域；</li><li>同一个作用域内，不能声明两个同名的变量。</li><li>Java定义的数据类型（按数据类型分）：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间</li></ol><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><ol><li>按数据类型：对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207145345147.png" alt="image-20201207145345147" style="zoom: 33%;" /><ul><li><p>(1) 数值型</p><ul><li><p>整数类型</p><ul><li><p>byte</p><ul><li>占用存储空间：1字节 = 8bit位</li><li>表数范围：-128~127（27），最高位为符号位（0正1负），故为7次方</li></ul></li><li><p>short</p><ul><li>占用存储空间：2字节</li><li>表数范围：-215~215-1</li></ul></li><li><p>int</p><ul><li>占用存储空间：4字节</li><li>表数范围：-231~231-1（约21亿）</li></ul></li><li><p>long</p><ul><li>占用存储空间：8字节</li><li>表数范围：-263~263-1</li></ul></li><li><p>==注意==</p><ul><li>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性</li><li>Java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’</li><li>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long </li></ul></li></ul></li><li><p>浮点类型</p><ul><li>单精度float<ul><li>占用存储空间：4字节</li><li>表数范围：-3.403E38~3.403E38</li></ul></li><li>双精度double<ul><li>占用存储空间：8字节</li><li>表数范围：-1.798E308~1.798E308</li></ul></li><li>注意：与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响</li><li>浮点型常量有两种表示形式<ul><li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li><li>科学计数法形式:如：5.12e2、512E2、100E-2</li></ul></li><li>float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求</li><li>double：双精度，精度是float的两倍。通常采用此类型</li><li>Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’</li><li>float表示的数值范围比long还大，是因为它使用科学计数法来计数，但是精度不够</li></ul></li></ul><p>(2) 字符型</p><ul><li>char<ul><li>1字符 = 2字节</li><li>声明或定义char型变量，通常使用一对单引号（’’），内部只能写一个字符</li><li>转义字符（例如：换行符\n、制表符\t、unicode编号等）</li></ul></li><li>布尔型<ul><li>boolean<ul><li>只能取两个值之一：true、false</li><li>常用于判断、循环结构</li><li>boolean类型数据只允许取值true和false，无null</li><li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同</li><li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替：true用1表示，false用0表示</li></ul></li></ul></li></ul></li><li><p>引用数据类型（reference type）</p><ul><li>类（class）</li><li>接口（interface）</li><li>数组（[]）</li></ul></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150009761.png" alt="image-20201207150009761"  /><h2 id="基本数据类型之间的运算规则"><a href="#基本数据类型之间的运算规则" class="headerlink" title="基本数据类型之间的运算规则"></a>基本数据类型之间的运算规则</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>这里只讨论7种基本数据类型变量间的运算，不包含boolean类型的。</li></ul><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3><ul><li>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150210307.png" alt="image-20201207150210307" style="zoom: 33%;" /><ul><li>多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。</li><li>byte、char、short三种类型变量做运算时，结果为int类型，即这三个变量之间的运算结果至少要拿一个int型去接收。原因：可能是防止溢出，并且整形常量默认类型为int型，运算时如果直接加减数字的话编译不通过。</li><li>boolean类型不能与其它数据类型运算。</li><li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。</li></ul><h3 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型:String"></a>字符串类型:<strong>String</strong></h3><ul><li>String不是基本数据类型，属于引用数据类型</li><li>使用方式与基本数据类型一致。例如:String str = “abcd”;</li><li>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。</li><li>使用时要加上强制转换符:()，但可能造成精度降低或溢出,格外要注意</li><li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150718306.png" alt="image-20201207150718306" style="zoom: 33%;" /><ul><li>boolean类型不可以转换为其它的数据类型。</li></ul><h2 id="进制（了解内容）"><a href="#进制（了解内容）" class="headerlink" title="进制（了解内容）"></a>进制（了解内容）</h2><ul><li>所有数字在计算机底层都以二进制形式存在</li></ul><h3 id="整数的四种表示方式"><a href="#整数的四种表示方式" class="headerlink" title="整数的四种表示方式"></a>整数的四种表示方式</h3><ol><li>二进制(binary)：0,1 ，满2进1，以0b或0B开头；</li><li>十进制(decimal)：0-9 ，满10进1；</li><li>八进制(octal)：0-7 ，满8进1，以数字0开头表示；</li><li>十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0。</li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><ol><li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</li><li>二进制的整数有如下三种形式：<ul><li>原码：直接将一个数值换成二进制数。最高位是符号位。</li><li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li><li>负数的补码：其反码加1。</li><li>计算机以二进制补码的形式存所有的整数。<ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul></li></ul></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>概念：运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151105715.png" alt="image-20201207151105715" style="zoom: 33%;" /><ol><li>整形数相除后默认结果为整形<ul><li>需要精确结果进行运算前需要先进行类型转换（自动转换或者强制类型转换）</li></ul></li><li>取模（余）运算（%）<ul><li>结果符号与被模（除）数相同</li></ul></li><li>自增（减）<ul><li>（前）++：先自增1，后运算</li><li>（后）++：先运算，后自增1</li><li>自减（略）</li><li>注意：自增（减）不会改变变量本身数据类型</li></ul></li></ol><h3 id="赋值运算符（-）"><a href="#赋值运算符（-）" class="headerlink" title="赋值运算符（=）"></a>赋值运算符（=）</h3><ol><li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li><li>支持连续赋值<ul><li><code>int i1, j1;</code></li><li><code>i1 = j1 = 10;</code></li></ul></li></ol><h3 id="比较（关系）运算符"><a href="#比较（关系）运算符" class="headerlink" title="比较（关系）运算符"></a>比较（关系）运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151222679.png" alt="image-20201207151222679" style="zoom: 33%;" /><ol><li>比较运算符的运算结果都是boolean型，也就是要么是true，要么false</li><li>区分“=”和“==”</li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151301938.png" alt="image-20201207151301938" style="zoom:33%;" /><ol><li>区分逻辑与（&amp;）和短路与（&amp;&amp;）<ul><li>相同点：运算结果相同；党符号左边为true时，都会执行符号右边的内容</li><li>不同点：当左边为false时，&amp;&amp;不会执行符号右边的运算（短路）</li><li>开发中优先使用短路与（&amp;&amp;）</li></ul></li><li>区分逻辑或（|）和短路或（||）<ul><li>相同点：运算结果相同；当符号右边为false时，二者都会执行符号右边的内容</li><li>不同点：当符号左边为true时，|| 不会执行符号右边的运算（短路）</li><li>开发中优先使用短路或（||）</li></ul></li><li>逻辑非（!）</li><li>逻辑异或（^）<ul><li>相同为true，不同为false</li></ul></li></ol><h3 id="位运算符（用得较少）"><a href="#位运算符（用得较少）" class="headerlink" title="位运算符（用得较少）"></a>位运算符（用得较少）</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151342011.png" alt="image-20201207151342011" style="zoom:33%;" /><h4 id="位运算符细节："><a href="#位运算符细节：" class="headerlink" title="位运算符细节："></a><strong>位运算符细节：</strong></h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151420395.png" alt="image-20201207151420395" style="zoom:33%;" /><ol><li>位运算符是直接对整数的二进制进行的运算</li><li>位运算符操作的都是整形的数据</li><li>&lt;&lt;：在一定范围内，每向左移n位，相当于*2n</li><li>&gt;&gt;：在一定范围内，每向右移n位，相当于/2n<ul><li>面试题：如何最高效的计算2*8？<ul><li>2 &lt;&lt; 3 或 8 &lt;&lt; 1</li></ul></li><li>注意：无&lt;&lt;&lt;</li></ul></li><li>&amp;、|、^运算</li></ol><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ol><li>格式：</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151612571.png" alt="image-20201207151612571"></p><ul><li>条件表达式的结果为boolean类型</li><li>表达式1和表达式2为<strong>同种类型</strong></li><li>三元运算符可嵌套使用</li></ul><ol start="2"><li>三元运算符与if-else的联系与区别<ul><li>三元运算符可简化if-else语句，因此能用三元运算符的地方尽量用三元运算符</li><li>三元运算符要求必须返回一个结果</li><li>if后的代码块可有多个语句</li><li>凡是可以使用三元运算符的地方都可以改写成if-else，反之则不一定行</li></ul></li><li>练习：获取3个数中的最大值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max1 = (a &gt; b)? a : b;</span><br><span class="line"><span class="keyword">int</span> max2 = (max1 &gt; c)? max1 : c;</span><br></pre></td></tr></table></figure><h3 id="运算符的优先等级"><a href="#运算符的优先等级" class="headerlink" title="运算符的优先等级"></a>运算符的优先等级</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151825396.png" alt="image-20201207151825396" style="zoom: 50%;" /><ol><li>运算符有不同优先级，所谓优先级就是表达式 运算中的运算顺序</li><li>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</li></ol><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块</li></ul><h3 id="如何从键盘-控制台获取不同类型的变量：需要使用Scanner类"><a href="#如何从键盘-控制台获取不同类型的变量：需要使用Scanner类" class="headerlink" title="如何从键盘/控制台获取不同类型的变量：需要使用Scanner类"></a>如何从键盘/控制台获取不同类型的变量：需要使用Scanner类</h3><ol><li>导包：<code>import java.util.Scanner;</code></li><li>Scanner的实例化：<code>Scanner scan = new Scanner(System.in);</code></li><li>调用Scanner的相关方法，来获取指定类型的变量。</li><li>对于char类型的获取，Scanner没有提供相关的方法，只能获取一个字符串。</li><li>如果一定要获取char类型，可用charAt(0)获取字符串索引为0位置上的字符。</li></ol><ul><li>注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配，则出现异常：InputMisMatchException，导致程序中断。容量小的可自动提升；</li></ul><h3 id="如何获取随机数"><a href="#如何获取随机数" class="headerlink" title="如何获取随机数"></a>如何获取随机数</h3><ul><li><code>double value = Math.random()</code>：返回一个[0.0, 1.0)之间的double型的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取[a,b]之间的<span class="keyword">int</span>型随机数：(<span class="keyword">int</span>)(Math.random() * (b - a + <span class="number">1</span>) + a)</span><br></pre></td></tr></table></figure><h3 id="流程控制方式结构化程序设计中规定的三种基本流程结构"><a href="#流程控制方式结构化程序设计中规定的三种基本流程结构" class="headerlink" title="流程控制方式结构化程序设计中规定的三种基本流程结构"></a>流程控制方式结构化程序设计中规定的三种基本流程结构</h3><ol><li>顺序结构<ul><li>程序从上到下逐行执行，中间没有任何判断和跳转</li></ul></li><li>分支结构<ul><li>根据条件，选择性地执行某段代码</li><li>有if-else和switch-case两种分支语句</li></ul></li><li>循环结构<ul><li>根据循环条件，重复性地执行某段代码</li><li>有while、do…while、for三种循环语句</li><li>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素</li></ul></li></ol><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h4 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h4><ol><li>第一种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二选一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>多选一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">执行表达式n</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用说明</p><ul><li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。</li><li>语句块只有一条执行语句时，一对{}可以省略，<strong>但建议保留</strong></li><li>if-else语句结构，根据需要可以嵌套使用（一般不超过3层，超过3层未解决则停下来想其他办法）。</li><li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。</li><li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。</li><li>当多个条件是“包含”关系时，“小上大下 /子上父下”。</li><li>if (80 &lt; core &lt;= 99)报错原因：前面的(80 &lt; core)的结果为一个boolean类型，boolean类型不能与int类型做大小关系对比。</li></ul></li><li><p>针对于条件表达式：</p><ul><li>如果多个表达式之间是”互斥“关系（或没有交集的关系），判断和执行语句的上下顺序不影响。</li><li>如果多个表达式之间有交集的关系，则需要根据实际情况来决定哪个声明在上面。</li><li>如果多个表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则范围小的就没机会执行了。</li><li>就近原则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//上述语句相当于：</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//以上误判源于省略了单行执行语句的&#123;&#125;，所以尽量不要省略&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207152637213.png" alt="image-20201207152637213" style="zoom: 33%;" /><ol><li><p>说明：</p><ul><li>根据switch表达式中的值，依次匹配各个case中的常量。一旦配成功，则进入相应的case结构中，调用其执行语句，当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</li><li>break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。</li><li>switch结构中的表达式，只能是如下六种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。</li><li>case之后只能声明常量，尤其不能是一个范围。</li><li>break关键字是可选的。</li><li>default：相当于if-else中的else，也是可选的，且default位置是可选的，一般还是写在末尾。</li><li>如果switch-case结构中多个case的执行语句相同，则可以考虑进行合并，即写完多行执行语句相同的case以后只写1行执行语句。</li><li>凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。</li><li>写分支结构时，如果既可以使用if-else，又可以使用switch-case（switch中表达式的取值情况不太多），优先选择使用switch-case。原因：switch-case执行效率稍高。</li></ul></li><li><p>示例：输入日期，返回日期是那一年的第几天。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDays</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入月份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> month = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入日期：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> day = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (month)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                days += <span class="number">29</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                days += <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            days += day;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span> + year +<span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;号是&quot;</span> + year + <span class="string">&quot;年的第&quot;</span> + days + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;\n输入有误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol><li><p>在某些条件满足得情况下，反复执行特定代码的功能</p></li><li><p>循环语句的四个组成部分</p><ul><li><p>初始化部分（init_statement）</p></li><li><p>循环条件部分（test_exp）–&gt; boolean类型</p></li><li><p>循环体部分（body_statement）</p></li><li><p>迭代部分（alter_statement）</p></li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207152959974.png" alt="image-20201207152959974" style="zoom: 67%;" /><ol start="3"><li><p>通常情况下，循环结束都是因为②中循环条件返回了false</p><ul><li><p>循环语句分类</p><ul><li>for循环</li><li>结构</li></ul></li><li><p>for(① ; ② ; ④){</p><p> ③</p><p>}</p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt; 直到②不再返回true，跳出循环</p></li><li><p>例题：遍历100以内的偶数，输出所有偶数的和，输出所有偶数的个数。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErgodicEvenNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                count += <span class="number">1</span>;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;0-100内偶数有&quot;</span> + count + <span class="string">&quot;个，它们的和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i在for循环内有效，出了for循环就失效了</span></span><br></pre></td></tr></table></figure><ul><li>例题：输入两个正整数m和n，求其最大公约数和最小公倍数。比如，12和20的最大公约数是4，最小公倍数是60。<ul><li>说明break的作用：跳出循环体</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetGcdLcm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入第二个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> min = (m &lt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\n&quot;</span> + m + <span class="string">&quot;和&quot;</span> + n + <span class="string">&quot;的最大公约数为&quot;</span> + i + <span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = (m &gt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &lt;= m * n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % m == <span class="number">0</span> &amp;&amp; i % n == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最小公倍数为&quot;</span> + i + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>while循环</p><ul><li>结构</li></ul><p><code>①初始化部分</code></p><p><code>while(②循环条件部分)&#123;</code></p><p> <code>③循环体部分;</code></p><p> <code>④迭代部分;</code></p><p><code>&#125;</code></p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt;②</p><ul><li>说明<ul><li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li><li>for循环和while循环可以相互转换</li><li>for循环和while循环初始化条件的作用范围不同。</li><li>i 出了while循环后可以继续使用，原因：①初始化部分在循环外。</li></ul></li></ul></li><li><p>do-while</p><ul><li><p>结构</p><p><code>①</code></p><p><code>do&#123;</code></p><p><code>③；</code></p><p><code>④；</code></p><p><code>&#125;while(②)；</code></p><p>执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② …… -&gt;②</p></li><li><p>特点</p><ul><li>先执行再判断，至少执行一次循环体。</li><li>开发中较少使用do-while，for和while使用较多。</li></ul></li></ul></li></ol><p>循环语句综合题：从键盘输入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时，结束程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CirCom</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> negNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> alter = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (alter &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                posNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (alter &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的正数个数为：&quot;</span> + posNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的负数个数为：&quot;</span> + negNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>while(true)就相当于for(;;)</li><li>结束循环的几种方式<ul><li>循环条件部分返回false；</li><li>在循环体中执行break。</li></ul></li></ul></li></ul><ol start="7"><li>嵌套循环<ul><li>嵌套循环的使用<ul><li>嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环。</li><li>外层循环：循环结构B。</li><li>内层循环：循环结构A。</li></ul></li><li>说明<ul><li>内层循环结构遍历一遍，只相当于外层循环结构循环一次。</li><li>假设外层循环需要执行m次，内层循环需要执行n次，此时内存层循环的循环体需要执行m*n次。</li></ul></li><li>技巧：外层循环控制行数，内层循环控制列数。</li></ul></li></ol><p>例题1：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiTable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印几行？（1-9）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> line = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot;x&quot;</span> + j + <span class="string">&quot;=&quot;</span> + i * j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题2：100以内所有质数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)        &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//获取当前时间距1970-01-01 00:00:00的毫秒数（long型）</span></span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="comment">//for (int j = 2; j &lt; i; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++)&#123;<span class="comment">//优化二：一个数如果在2到它本身开方的范围内没有商，则为质数</span></span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//优化一：只对本身非质数的自然数是有效的。加break前后对比：20181ms/2174ms = 9.28</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;质数的个数：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;所花费的时间：&quot;</span> + (start - end));</span><br><span class="line">        <span class="comment">//优化前：17916ms 优化一：1629ms 优化二：16ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊关键字的使用"><a href="#特殊关键字的使用" class="headerlink" title="特殊关键字的使用"></a>特殊关键字的使用</h3><ol><li>break<ul><li>使用范围：switch-case、循环结构中</li><li>循环中使用的作用：结束当前循环</li><li>默认跳出包裹此关键字最近的一层循环</li><li>结束指定标识的一层循环结构</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>continue</p><ul><li><p>使用范围：循环结构中</p></li><li><p>循环中使用的作用：结束当次循环</p></li><li><p>结束指定标识的一层循环结构的当次循环</p><p><code>countinue label;</code></p></li></ul></li></ol><ul><li>注意：以上两个关键字后面不能声明执行语句</li></ul><ol start="3"><li><p>return</p><ul><li>并非专门用于结束循环的，它的的功能是结束一个方法。当一个方法执行到一个return时，这个方法将被结束。</li><li>与break、continue不同的是吗，return直接结束整个方法，不管这个return处于多少层循环之内。</li></ul></li><li><p>补充：衡量一个功能代码的优劣</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关键字与保留字&quot;&gt;&lt;a href=&quot;#关键字与保留字&quot; class=&quot;headerlink&quot; title=&quot;关键字与保留字&quot;&gt;&lt;/a&gt;关键字与保留字&lt;/h2&gt;&lt;h3 id=&quot;关键字（keyword）&quot;&gt;&lt;a href=&quot;#关键字（keyword）&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十七章 Java9&amp;10&amp;11新特性</title>
    <link href="https://asteroidcs.github.io/undefined/1e12.html"/>
    <id>https://asteroidcs.github.io/undefined/1e12.html</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-12-06T13:03:29.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-9-的新特性"><a href="#Java-9-的新特性" class="headerlink" title="Java 9 的新特性"></a>Java 9 的新特性</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206091903388.png" alt="image-20201206091903388" style="zoom: 50%;" /><h3 id="JDK-和-JRE-目录结构的改变"><a href="#JDK-和-JRE-目录结构的改变" class="headerlink" title="JDK 和 JRE 目录结构的改变"></a>JDK 和 JRE 目录结构的改变</h3><ol><li>JDK 8 的目录结构</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206092159297.png" alt="image-20201206092159297" style="zoom: 50%;" /><ol start="2"><li>JDK 9 的目录结构</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206092310282.png" alt="image-20201206092310282" style="zoom:50%;" /><h3 id="模块化系统-Jigsaw-——-gt-Modularity"><a href="#模块化系统-Jigsaw-——-gt-Modularity" class="headerlink" title="模块化系统: Jigsaw ——&gt; Modularity"></a>模块化系统: Jigsaw ——&gt; Modularity</h3><ol><li><p>用模块来管理各个package，通过声明某个package 暴露，==模块(module)的概念==，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。</p></li><li><p>实现目标</p><ul><li>模块化的主要目的在于减少内存的开销</li><li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护</li><li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li><li>改进其安全性，可维护性，提高性能</li></ul></li><li><p>模块将由通常的类和新的模块声明文件(module-info.java)组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。</p></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206094326092.png" alt="image-20201206094326092" style="zoom: 50%;" /><ol start="4"><li><p>要想在java9demo模块中调用java9test模块下包中的结构：</p><ul><li>需要在java9test的module-info.java中声明:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206095559123.png" alt="image-20201206095559123" style="zoom:50%;" /><ul><li>对应在java 9demo 模块的src 下创建module-info.java文件:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206095726793.png" alt="image-20201206095726793" style="zoom:50%;" /><h3 id="Java的REPL工具：jShell命令"><a href="#Java的REPL工具：jShell命令" class="headerlink" title="Java的REPL工具：jShell命令"></a>Java的REPL工具：jShell命令</h3><ul><li>调出jShell</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100242680.png" alt="image-20201206100242680"></p><ul><li>获取帮助</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100324402.png" alt="image-20201206100324402" style="zoom:67%;" /><ul><li>基本使用</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100418854.png" alt="image-20201206100418854"></p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101004699.png" alt="image-20201206101004699"  /><ul><li>导入指定的包</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101058508.png" alt="image-20201206101058508"></p><ul><li>默认已经导入如下的所有包：(包含java.lang包)</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101153232.png" alt="image-20201206101153232"></p><p>==Tips==：在 JShell 环境下，语句末尾的“;” 是可选的。但推荐还是最好加上。提高代码可读 性。</p><ul><li>只需按下 Tab 键，就能自动补全代码</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101454526.png" alt="image-20201206101454526"  /><ul><li>列出当前 session 里所有有效的代码片段</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101605180.png" alt="image-20201206101605180"></p><ul><li>查看当前 session 下所有创建过的变量</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101650915.png" alt="image-20201206101650915"></p><ul><li>查看当前 session 下所有创建过的方法</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101741784.png" alt="image-20201206101741784"></p><p>Tips：我们还可以重新定义相同方法名和参数列表的方法，即为对现有方法的修改(或 覆盖)。</p><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102019032.png" alt="image-20201206102019032"></p><ul><li>使用/open命令调用:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102146113.png" alt="image-20201206102146113" style="zoom:50%;" /><ul><li>没有受检异常(编译时异常)</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102241899.png" alt="image-20201206102241899" style="zoom: 50%;" /><ul><li>退出jShell</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102339008.png" alt="image-20201206102339008"></p><h3 id="语法改进"><a href="#语法改进" class="headerlink" title="语法改进"></a>语法改进</h3><h4 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h4><ol><li>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 10:28 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如下三个方法放入权限修饰符都是public</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Java 8中此处报错，在java 9中就不会出现问题</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Java 9中，接口更加的灵活和强大，==连方法的访问权限修饰符都可 以声明为private的了==，此时方法将不会成为你对外暴露的API的一部分</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 10:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImp</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口中的静态方法只能由接口自己调用</span></span><br><span class="line">        MyInterface.methodStatic();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以调用默认方法</span></span><br><span class="line">        MyInterfaceImp imp = <span class="keyword">new</span> MyInterfaceImp();</span><br><span class="line">        imp.methodDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//无法调用私有方法，只能接口自己用</span></span><br><span class="line">        <span class="comment">//imp.methodPrivate(); </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="钻石操作符使用升级"><a href="#钻石操作符使用升级" class="headerlink" title="钻石操作符使用升级"></a>钻石操作符使用升级</h4><ul><li><p>能够与匿名实现类共同使用钻石操作符(diamond operator)</p></li><li><p>在Java 8中如下的操作是会报错的:</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206110852894.png" alt="image-20201206110852894" style="zoom:50%;" /><ul><li>Java 9中如下操作可以正常执行通过:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206110931300.png" alt="image-20201206110931300" style="zoom:50%;" /><h4 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h4><ul><li>Java 8 中，可以实现资源的==自动关闭==，但是==要求执行后必须关闭的所有资源必须在try子句中初始化==，否则编译不通过。如下例所示：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206111331957.png" alt="image-20201206111331957" style="zoom:50%;" /><ul><li>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206111407721.png" alt="image-20201206111407721" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 11:06 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java9Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//java 8之前的资源关闭操作</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java 8中的资源关闭操作:自动关闭</span></span><br><span class="line">        <span class="comment">//要求自动关闭的资源的初始化必须放在try的一对小括号中</span></span><br><span class="line">        <span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java 9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一对小括号外</span></span><br><span class="line">        <span class="comment">//此时的资源属性是常量，声明为final，不可修改</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        <span class="keyword">try</span> (reader) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h3><ul><li>String 再也不用 char[] 来存储，改成了 byte[] 加上编码标记，节约 了一些空间。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114110122.png" alt="image-20201206114110122" style="zoom: 50%;" /><ul><li>那StringBuffer 和 StringBuilder 是否仍无动于衷呢?</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114147541.png" alt="image-20201206114147541" style="zoom:50%;" /><h3 id="集合工厂方法：快速创建只读集合"><a href="#集合工厂方法：快速创建只读集合" class="headerlink" title="集合工厂方法：快速创建只读集合"></a>集合工厂方法：快速创建只读集合</h3><ol><li>以前要创建一个==只读、不可改变==的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114603325.png" alt="image-20201206114603325" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114803975.png" alt="image-20201206114803975" style="zoom:50%;" /><ol start="2"><li>Java 9因此引入了方便的方法，这使得类似的事情更容易表达。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206115759239.png" alt="image-20201206115759239"></p><ol start="3"><li>调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的:在 创建后，继续添加元素到这些集合会导致“UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206115931236.png" alt="image-20201206115931236" style="zoom:50%;" /><h3 id="InputStream-加强"><a href="#InputStream-加强" class="headerlink" title="InputStream 加强"></a>InputStream 加强</h3><ul><li>InputStream 终于有了一个非常有用的方法：==transferTo==，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206132150043.png" alt="image-20201206132150043" style="zoom:50%;" /><h3 id="增强的-Stream-API"><a href="#增强的-Stream-API" class="headerlink" title="增强的 Stream API"></a>增强的 Stream API</h3><ol><li>Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。</li><li>在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法: <ul><li>takeWhile</li><li> dropWhile,</li><li>ofNullable</li><li>iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</li></ul></li><li>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。</li></ol><h4 id="takeWhile-的使用"><a href="#takeWhile-的使用" class="headerlink" title="takeWhile()的使用"></a>takeWhile()的使用</h4><ul><li>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，==takeWhile 返回从开头开始的尽量多的元素==。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// takeWhile 返回从开头开始的按照指定规则尽量多的元素</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">        list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);  <span class="comment">// 45  43</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);  <span class="comment">// 1  2  3  4</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="dropWhile-的使用"><a href="#dropWhile-的使用" class="headerlink" title="dropWhile()的使用"></a>dropWhile()的使用</h4><ul><li>dropWhile 的行为与 takeWhile 相反，返回剩余的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">        list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ofNullable-的使用"><a href="#ofNullable-的使用" class="headerlink" title="ofNullable()的使用"></a>ofNullable()的使用</h4><ul><li>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报NullPointerException，of()参数不能存储单个null值</span></span><br><span class="line">        <span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line">        <span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不报异常，允许通过</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(stringStream.count()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不报异常，允许通过</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(list.stream().count()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ofNullable():允许值为null</span></span><br><span class="line">        Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(stream1.count());<span class="comment">// 0</span></span><br><span class="line">        </span><br><span class="line">        Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(stream.count()); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="iterate-重载的使用"><a href="#iterate-重载的使用" class="headerlink" title="iterate()重载的使用"></a>iterate()重载的使用</h4><ul><li>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原来的控制终止方式:</span></span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 现在的终止方式:</span></span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Optional获取Stream的方法"><a href="#Optional获取Stream的方法" class="headerlink" title="Optional获取Stream的方法"></a>Optional获取Stream的方法</h3><ul><li>Optional类中stream()的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class="line">        Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">        stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript引擎升级：Nashorn"><a href="#Javascript引擎升级：Nashorn" class="headerlink" title="Javascript引擎升级：Nashorn"></a>Javascript引擎升级：Nashorn</h3><ul><li>Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。</li><li>JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。</li></ul><h2 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h2><h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a><strong>局部变量类型推断</strong></h3><ul><li><p>好处：减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！</p></li><li><p>举例如下：</p><ul><li><p><strong>场景一：类实例化时</strong>：作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第</p><p>一次用于声明变量类型，第二次用于构造器。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>场景二：返回值类型含复杂泛型结构：变量的声明类型书写复杂且较长，尤其是加上泛型的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure><ul><li><p><strong>场景三：</strong></p><p>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.atguigu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure></li><li><p><strong>适用于以下情况：</strong></p><ul><li>局部变量的初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>增强for循环中的索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传统for循环中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在局部变量中使用时，如下情况不适用：</strong></p><ul><li>初始值为null</li><li>Lambda表达式</li><li>方法引用</li><li>为数组静态初始化</li></ul></li><li><p><strong>不适用以下的结构中：</strong></p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206180853363.png" alt="image-20201206180853363" style="zoom:50%;" /><ul><li><p>==<strong>工作原理</strong>==</p><p>在处理 var时，==编译器先是查看表达式右边部分==，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。 </p></li><li><p>==<strong>注 意</strong>==</p><ul><li><strong>var</strong>不是一个关键字</li><li><strong>这不是</strong>JavaScript，var并不会改变Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206181503242.png" alt="image-20201206181503242" style="zoom: 33%;" /></li></ul><h3 id="集合新增创建不可变集合的方法"><a href="#集合新增创建不可变集合的方法" class="headerlink" title="集合新增创建不可变集合的方法"></a><strong>集合新增创建不可变集合的方法</strong></h3><ul><li>自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206181706108.png" alt="image-20201206181706108" style="zoom: 50%;" /><ul><li><p>示例1和2代码基本一致，为什么一个为true,一个为false?</p><p>结论：copyOf(Xxx coll)：如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前coll；如果参数coll不是只读集合，则copyOf返回一个新的只读集合，这个集合只读。</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206182127916.png" alt="image-20201206182127916" style="zoom: 33%;" /><h2 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h2><h3 id="新增了一系列字符串处理方法"><a href="#新增了一系列字符串处理方法" class="headerlink" title="新增了一系列字符串处理方法"></a><strong>新增了一系列字符串处理方法</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206183941103.png" alt="image-20201206183941103" style="zoom: 50%;" /><h3 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a><strong>Optional</strong> <strong>加强</strong></h3><ul><li>可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206184524889.png" alt="image-20201206184524889" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;Object&gt; op = Optional.empty();</span><br><span class="line">        System.out.println(op.isPresent());</span><br><span class="line">        System.out.println(op.isEmpty());</span><br><span class="line"></span><br><span class="line">        op = Optional.of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        Object o = op.orElseThrow();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// op = Optional.empty();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//or:value非空，返回对应的Optional；value为空，返回形参封装的Optional</span></span><br><span class="line">        Optional&lt;Object&gt; op2 = op.or(() -&gt; op1);</span><br><span class="line">        System.out.println(op2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量类型推断升级"><a href="#局部变量类型推断升级" class="headerlink" title="局部变量类型推断升级"></a><strong>局部变量类型推断升级</strong></h3><ul><li>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样=的语法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line">        <span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正确的形式:</span></span><br><span class="line">        <span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。</span></span><br><span class="line">        Consumer&lt;String&gt; con2 = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="全新的-HTTP-客户端-API"><a href="#全新的-HTTP-客户端-API" class="headerlink" title="全新的 HTTP 客户端 API"></a>全新的 HTTP 客户端 API</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206191100225.png" alt="image-20201206191100225" style="zoom: 50%;" /><h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a><strong>更简化的编译运行程序</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206191831700.png" alt="image-20201206191831700" style="zoom: 50%;" /><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a><strong>ZGC</strong></h3><ol><li>优势：<ul><li>GC暂停时间不会超过10ms</li><li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li><li>和G1相比, 应用吞吐能力不会下降超过15% </li><li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li><li>初始只支持64位系统</li></ul></li><li>==ZGC的设计目标是==：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</li></ol><h3 id="其它新特性"><a href="#其它新特性" class="headerlink" title="其它新特性"></a><strong>其它新特性</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206192312496.png" alt="image-20201206192312496" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-9-的新特性&quot;&gt;&lt;a href=&quot;#Java-9-的新特性&quot; class=&quot;headerlink&quot; title=&quot;Java 9 的新特性&quot;&gt;&lt;/a&gt;Java 9 的新特性&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/asteroidc</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十六章 Java8的其他新特性</title>
    <link href="https://asteroidcs.github.io/undefined/1e12.html"/>
    <id>https://asteroidcs.github.io/undefined/1e12.html</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-12-06T13:02:53.835Z</updated>
    
    <content type="html"><![CDATA[<img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/3424242423.png" alt="3424242423" /><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>速度更快</li><li>代码更少(增加了新的语法:Lambda 表达式)  强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常:Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ol><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3><ol><li>并行流：就是把一个内容分成多个数据块，并用不同的线程分别处理每个数 据块的流。</li><li>相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流 之间进行切换</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="为什么使用-Lambda-表达式"><a href="#为什么使用-Lambda-表达式" class="headerlink" title="为什么使用 Lambda 表达式"></a>为什么使用 Lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以 传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</span><br></pre></td></tr></table></figure><ol><li>从匿名类到 Lambda 的转换举例1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 11:02 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我爱吃红烧肉！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        runnable.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; System.out.println(<span class="string">&quot;我爱喝排骨汤！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        runnable1.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从匿名类到 Lambda 的转换举例2</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; integerComparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> compare = integerComparator.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; integerComparator1 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">        <span class="comment">//Comparator&lt;Integer&gt; integerComparator1 = Integer :: compare;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> compare1 = integerComparator.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda-表达式：语法"><a href="#Lambda-表达式：语法" class="headerlink" title="Lambda 表达式：语法"></a>Lambda 表达式：语法</h3><ol><li>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<ul><li>左侧:指定了 Lambda 表达式需要的参数列表（其实就是接口中的抽象方法的形参列表）</li><li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。</li></ul></li></ol><h3 id="Lambda-表达式的使用（分6种情况）"><a href="#Lambda-表达式的使用（分6种情况）" class="headerlink" title="Lambda 表达式的使用（分6种情况）"></a>Lambda 表达式的使用（分6种情况）</h3><ol><li>语法格式一:无参，无返回值</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120459028.png" alt="image-20201202120459028" style="zoom:50%;" /><ol start="2"><li>语法格式二：:Lambda 需要一个参数，但是没有返回值。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120532056.png" alt="image-20201202120532056" style="zoom: 67%;" /><ol start="3"><li>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120615006.png" alt="image-20201202120615006" style="zoom: 67%;" /><ol start="4"><li>语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120652505.png" alt="image-20201202120652505" style="zoom:67%;" /><ol start="5"><li>语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120803484.png" alt="image-20201202120803484" style="zoom:50%;" /><ol start="6"><li>语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120830859.png" alt="image-20201202120830859" style="zoom: 67%;" /><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>左边：Lambda形参列表的参数类型可以省略（类型推断），若Lambda形参列表只有一个参数，其中一对（）也可以省略</li><li>右边：Lambda体应该用一对{}包裹；如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return</li></ul><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>​    上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序 的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于 上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202121451988.png" alt="image-20201202121451988" style="zoom:50%;" /><h2 id="函数式-Functional-接口"><a href="#函数式-Functional-接口" class="headerlink" title="函数式(Functional)接口"></a>函数式(Functional)接口</h2><h3 id="什么是函数式-Functional-接口"><a href="#什么是函数式-Functional-接口" class="headerlink" title="什么是函数式(Functional)接口"></a>什么是函数式(Functional)接口</h3><ol><li>只包含==一个抽象方法==的接口，称为==函数式接口==。</li><li>可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda 表达式抛出一个受检异常(即:非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。</li><li>可以在一个接口上使用 ==@FunctionalInterface==注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li><li>在java.util.function包下定义了Java 8 的丰富的函数式接口</li></ol><h3 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title="如何理解函数式接口"></a>如何理解函数式接口</h3><ol><li>java 不但可以支持OOP还 可以支持OOF (面向函数编程)</li><li>在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。</li><li>在Java8中，==Lambda表达式就是一个函数式接口的实例==。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。</li><li>==以前用匿名实现类表示的现在都可以用Lambda表达式来写。==</li></ol><h3 id="Java-内置四大核心函数式接口"><a href="#Java-内置四大核心函数式接口" class="headerlink" title="Java 内置四大核心函数式接口"></a>Java 内置四大核心函数式接口</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202124949640.png" alt="image-20201202124949640" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 11:57 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        happyTime(<span class="number">500</span>, <span class="keyword">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;购物花了&quot;</span> + aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        happyTime(<span class="number">400</span>, money -&gt; System.out.println(<span class="string">&quot;购物花了&quot;</span> + money));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyTime</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class="line">        consumer.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;东京&quot;</span>, <span class="string">&quot;西京&quot;</span>);</span><br><span class="line">        List&lt;String&gt; filterString = filterString(list, <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(filterString);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterString1 = filterString(list, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterString1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.test(s))&#123;</span><br><span class="line">                filterList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202125020900.png" alt="image-20201202125020900" style="zoom:50%;" /><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用-Method-References"><a href="#方法引用-Method-References" class="headerlink" title="方法引用(Method References)"></a>方法引用(Method References)</h3><ol><li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用!</li><li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li><li>==要求==：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致!</li><li>==格式==：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</li><li>如下三种主要使用情况：<ul><li>对象：：实例方法名</li><li>类：：静态方法名</li><li>类：：实例方法名</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205192602281.png" alt="image-20201205192602281" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205192934376.png" alt="image-20201205192934376" style="zoom:50%;" /><ol start="6"><li>==注意==：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时:ClassName::methodName</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况三：类：：实例方法</span></span><br><span class="line">    <span class="comment">//Comparator中的int compare(T t1, T t2)</span></span><br><span class="line">    <span class="comment">//String中的int t1.compareTo(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(comparator.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; comparator1 = String::compareTo;</span><br><span class="line">        System.out.println(comparator1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><ol><li>格式:：ClassName：：new<ul><li>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205195947990.png" alt="image-20201205195947990" style="zoom:50%;" /><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><ol><li>格式: type[] :: new<ul><li>可以把数组看作是一个特殊的类，则写法与构造器引用一致</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205200005415.png" alt="image-20201205200005415" style="zoom:50%;" /><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><ol><li>Java8中有两大最为重要的改变。第一个是：Lambda 表达式，另外一个则是：Stream API。</li><li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。</li></ol><h3 id="为什么要使用Stream-API"><a href="#为什么要使用Stream-API" class="headerlink" title="为什么要使用Stream API"></a>为什么要使用Stream API</h3><ul><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。</li><li>Stream 和 Collection 集合的区别：<ul><li>Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。</li><li>前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。</li></ul></li></ul><h3 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h3><ol><li>数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。<ul><li>“集合讲的是数据，Stream讲的是计算！”</li></ul></li><li>注意：<ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ul></li></ol><h3 id="Stream-的操作三个步骤"><a href="#Stream-的操作三个步骤" class="headerlink" title="Stream 的操作三个步骤"></a>Stream 的操作三个步骤</h3><ol><li>步骤：<ul><li>创建 Stream：一个数据源(如:集合、数组)，获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205202942831.png" alt="image-20201205202942831" style="zoom:50%;" /><h4 id="创建-Stream方式"><a href="#创建-Stream方式" class="headerlink" title="创建 Stream方式"></a>创建 Stream方式</h4><ol><li>方式一：通过集合<ul><li>Java8 中的 Collection 接口被扩展，提供了两个获取流 的方法:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205210640.png" alt="image-20201205205210640" style="zoom:50%;" /><ol start="2"><li>方式二：通过数组<ul><li>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205724317.png" alt="image-20201205205724317" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205808435.png" alt="image-20201205205808435" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        IntStream stream = Arrays.stream(arr);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>方式三:通过Stream的of()<ul><li>可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210125888.png" alt="image-20201205210125888" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>方式四：创建无限流（用的较少，了解即可）</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210300832.png" alt="image-20201205210300832" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h4><p>​        多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则==中间操作不会执行任何的处理!而在终止操作时一次性全 部处理，称为“惰性求值”==</p><ol><li>筛选与切片</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210937302.png" alt="image-20201205210937302" style="zoom:50%;" /><ol start="2"><li>映 射</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211238734.png" alt="image-20201205211238734" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toCharArray()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>排序</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211315019.png" alt="image-20201205211315019" style="zoom:50%;" /><h4 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h4><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如:List、Integer，甚至是 void 。</li><li>流进行了终止操作后，不能再次使用。</li></ul><ol><li>匹配与查找</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211532968.png" alt="image-20201205211532968" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211602753.png" alt="image-20201205211602753" style="zoom:50%;" /><ol start="2"><li>归约</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211638535.png" alt="image-20201205211638535" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名</p><ol start="3"><li>收集</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211750079.png" alt="image-20201205211750079" style="zoom:50%;" /><p>​    Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)</p><ol start="4"><li>Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表：</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205213813629.png" alt="image-20201205213813629" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205213837908.png" alt="image-20201205213837908" style="zoom:50%;" /><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><ul><li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></li><li><p>Optional类的Javadoc描述如下:这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。</p></li><li><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p></li><li><p>创建Optional类对象的方法:</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214213547.png" alt="image-20201205214213547" style="zoom:50%;" /><ul><li>判断Optional容器中是否包含对象：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214243635.png" alt="image-20201205214243635" style="zoom:50%;" /><ul><li>获取Optional容器的对象:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214312644.png" alt="image-20201205214312644" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); <span class="comment">// 如果女朋友存在就打印女朋友的信息 opt.ifPresent(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); <span class="comment">// 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了</span></span><br><span class="line">        Girl girl = opt.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;嫦娥&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;他的女朋友是:&quot;</span> + girl.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>)); <span class="comment">//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空 Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000); System.out.println(emp);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>)); <span class="comment">//如果opt中员工对象不为空，就涨薪10%</span></span><br><span class="line">        Optional&lt;Employee&gt; emp = opt.map(e -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.setSalary(e.getSalary() % <span class="number">1.1</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/3424242423.png&quot; alt=&quot;3424242423&quot; /&gt;

&lt;h3 id=&quot;优点：&quot;&gt;&lt;a href=&quot;#优点：&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十五章 反射机制</title>
    <link href="https://asteroidcs.github.io/undefined/a7d1.html"/>
    <id>https://asteroidcs.github.io/undefined/a7d1.html</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-12-06T12:55:18.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构"><a href="#重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构" class="headerlink" title="重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构"></a>重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h3><ol><li><p><strong>Reflection(反射)**是被视为</strong>$\color{red}{动态语言}$**的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p></li><li><p>补充：动态语言 vs 静态语言</p><ul><li><p>动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><ul><li>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang</li></ul></li><li><p>静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。</p></li></ul></li><li><p>Java不是动态语言，但Java可以称之为$\color{yellow}{“准动态语言”}$。即Java有一定的动态性，可以利用$\color{red}{反射机制、字节码操作}$获得类似动态语言的特性。 </p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。</p><ul><li>$\color{red}{我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，故形象的称之为：反射}$</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201105916507.png" alt="image-20201201105916507"  /><ol start="5"><li><p>Java反射机制提供的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象 </li><li>在运行时判断任意一个类所具有的成员变量和方法 </li><li>在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 </li><li>在运行时处理注解</li><li>生成动态代理</li></ul></li><li><p>反射相关的主要API</p><ul><li><p>java.lang.Class：代表一个类</p></li><li><p>java.lang.reflect.Method：代表类的方法</p></li><li><p>java.lang.reflect.Field：代表类的成员变量</p><p>java.lang.reflect.Constructor：代表类的构造器</p></li></ul></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Person"><a href="#Person" class="headerlink" title="Person"></a>Person</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-01 12:00 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，我是一个人！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是：&quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射前对于类的操作"><a href="#反射前对于类的操作" class="headerlink" title="反射前对于类的操作"></a>反射前对于类的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射前对于类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建Person类的实例化</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过对象，调用其内部的属性、方法</span></span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    p1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Person类的外部，不可以通过Person类的对象调用其内部私有结构</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射后对于类的操作"><a href="#反射后对于类的操作" class="headerlink" title="反射后对于类的操作"></a>反射后对于类的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类的对象</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person person = constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调属性</span></span><br><span class="line">    Field age = personClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(person, <span class="number">10</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//调方法</span></span><br><span class="line">    Method show = personClass.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(person);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构。如：私有的构造器、方法、属性</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor1 = personClass.getDeclaredConstructor(String.class);</span><br><span class="line">    constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person person1 = constructor1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    Field name = personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(person1, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    Method showNation = personClass.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object nation = showNation.invoke(person1, <span class="string">&quot;中国&quot;</span>);<span class="comment">// 相当于p1.showNation(&quot;中国&quot;）</span></span><br><span class="line">    System.out.println(nation);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？"><a href="#疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？" class="headerlink" title="疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？"></a>疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建议直接用<span class="keyword">new</span>的方式</span><br><span class="line"><span class="comment">//什么时候用：放射的方式。————&gt; 反射的特征：动态性</span></span><br></pre></td></tr></table></figure><h4 id="疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？"><a href="#疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？" class="headerlink" title="疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？"></a>疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？</h4><h2 id="理解Class类-并-获取Class的实例"><a href="#理解Class类-并-获取Class的实例" class="headerlink" title="理解Class类 并 获取Class的实例"></a>理解Class类 并 获取Class的实例</h2><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><ol><li>类的加载过程<ul><li>程序经过Java.exe命令以后，会生成一个或多个字节码文件(.class结尾)</li><li>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存。此过程就称为类的加载。加载到内存中的类，就称为运行时的类，此时运行时的类就作为C lass的一个实例</li></ul></li><li>换句话说，Class的实例就对应着一个运行时类</li><li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li><li>在Object类中定义了以下的方法，此方法将被所有子类继承<ul><li>public final Class getClass()</li></ul></li><li>以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201125814351.png" alt="image-20201201125814351" style="zoom:50%;" /><ol start="6"><li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息<ul><li>Class本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul></li></ol><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201131201652.png" alt="image-20201201131201652" style="zoom: 50%;" /><h3 id="获取Class类的实例-四种方法"><a href="#获取Class类的实例-四种方法" class="headerlink" title="获取Class类的实例(四种方法)"></a>获取Class类的实例(四种方法)</h3><ol><li>前提:若已知具体的类，通过类的class属性获取，该方法最为安全可靠， 程序性能最高</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = String.class;</span><br></pre></td></tr></table></figure><ol start="2"><li>前提:已知某个类的实例，调用该实例的getClass()方法获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = “www.atguigu.com”.getClass();</span><br></pre></td></tr></table></figure><ol start="3"><li>前提:已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(“java.lang.String”)</span><br></pre></td></tr></table></figure><ol start="4"><li>其他方式(不做要求)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader(); Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class的实例方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">        Class clazz1 = Person.class;</span><br><span class="line">        System.out.println(clazz1);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过运行时类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Class clazz2 = p1.getClass();</span><br><span class="line">        System.out.println(clazz2);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;lesson.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz3);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四：使用类的加载器：ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">        Class clazz4 = classLoader.loadClass(<span class="string">&quot;lesson.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz4);  <span class="comment">// class lesson.Person</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象?"></a>哪些类型可以有Class对象?</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201141515986.png" alt="image-20201201141515986" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = <span class="keyword">int</span>[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c10 = a.getClass();</span><br><span class="line">Class c11 = b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);</span></span><br></pre></td></tr></table></figure><h2 id="类的加载-与-ClassLoader的理解"><a href="#类的加载-与-ClassLoader的理解" class="headerlink" title="类的加载 与 ClassLoader的理解"></a>类的加载 与 ClassLoader的理解</h2><h3 id="类的加载过程（了解）"><a href="#类的加载过程（了解）" class="headerlink" title="类的加载过程（了解）"></a>类的加载过程（了解）</h3><p>​    当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201142014269.png" alt="image-20201201142014269" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201142125015.png" alt="image-20201201142125015" style="zoom:50%;" /><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据$\color{yellow}{转换成方法区的运行时数据结构}$，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143129820.png" alt="image-20201201143129820" style="zoom: 67%;" /><h3 id="ClassLoader-了解"><a href="#ClassLoader-了解" class="headerlink" title="ClassLoader(了解)"></a>ClassLoader(了解)</h3><ol><li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143216184.png" alt="image-20201201143216184" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143453630.png" alt="image-20201201143453630" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143519125.png" alt="image-20201201143519125" style="zoom:50%;" /><h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="有了Class对象，能做什么"><a href="#有了Class对象，能做什么" class="headerlink" title="有了Class对象，能做什么?"></a>有了Class对象，能做什么?</h3><ol><li><p>创建类的对象：调用Class对象的newInstance()方法。要求：</p><ul><li><p>类必须有一个无参数的构造器。</p></li><li><p>类的构造器的访问权限需要足够，通常设置为public</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        newInstance():调用此方法，创建对应的运行时类的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Person obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在javabean中要求提供一个public的空参构造器。原因：<ul><li>便于通过反射，创建运行时类的对象</li><li>便于子类继承次运行时类时，默认调用super()时，保证父类有此构造器</li></ul></li><li>难道没有无参的构造器就不能创建对象了吗? ————&gt; NO，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下:<ul><li>通过Class类的$\color{red}{getDeclaredConstructor(Class … parameterTypes)}$取得本类的指定形参类 型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体现反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;lesson.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object instance = getInstance(classPath);</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(classPath);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201155339974.png" alt="image-20201201155339974"  /><p>使用反射可以取得:</p><ol><li>实现的全部接口：确定此对象所表示的类或接口实现的接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()</span><br></pre></td></tr></table></figure><ol start="2"><li>所继承的父类：返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br></pre></td></tr></table></figure><ol><li><p>全部的构造器</p><ul><li>返回此 Class 对象所表示的类的所有public构造方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br></pre></td></tr></table></figure><ul><li>返回此 Class 对象表示的类声明的所有构造方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br></pre></td></tr></table></figure><p>Constructor类中:</p><ul><li>取得修饰符: </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得方法名称: </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得参数的类型:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br></pre></td></tr></table></figure></li><li><p>全部的方法</p><ul><li>返回此Class对象所表示的类或接口的全部方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br></pre></td></tr></table></figure><ul><li>返回此Class对象所表示的类或接口的public的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods()</span><br></pre></td></tr></table></figure><p>Method类中:</p><ul><li>取得全部的返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()</span><br></pre></td></tr></table></figure><ul><li>取得全部的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()</span><br></pre></td></tr></table></figure><ul><li>取得修饰符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>取得异常信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()</span><br></pre></td></tr></table></figure></li><li><p>全部的Field</p><ul><li>返回此Class对象所表示的类或接口的public的Field。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br></pre></td></tr></table></figure><ul><li>返回此Class对象所表示的类或接口的全部Field。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br></pre></td></tr></table></figure><p>Field方法中:</p><ul><li>以整数形式返回此Field的修饰符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>得到Field的属性类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType()</span><br></pre></td></tr></table></figure><ul><li>返回Field的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取属性结构：</span></span><br><span class="line">        <span class="comment">//getFields():能够获取当前运行时类及其所有父类当中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性，不包含父类中声明的属性</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="keyword">int</span> modifier = f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifier) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Annotation相关</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">get <span class="title">Annotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span></span><br><span class="line"><span class="function"><span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>泛型相关</p><ul><li>获取父类泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParameterizedType</span><br></pre></td></tr></table></figure><ul><li>获取实际的泛型类型参数数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getActualTypeArguments()</span><br></pre></td></tr></table></figure></li><li><p>类所在的包</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Package <span class="title">getPackage</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ol><li>在实际的操作中，取得类的信息的操作代码，并不会经常开发。 </li><li>一定要熟悉java.lang.reflect包的作用，反射机制。 </li><li>如何取得属性、方法、构造器的名称，修饰符等。</li></ol><h2 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h2><h3 id="调用指定方法"><a href="#调用指定方法" class="headerlink" title="调用指定方法"></a>调用指定方法</h3><p>​    通过反射，调用类中的方法，通过Method类完成。步骤:</p><ol><li>通过Class类的  ==getMethod(String name,Class…parameterTypes)==  方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用  ==Object invoke(Object obj, Object[] args)==  进行调用，并向方法中 传递要设置的obj对象的参数信息。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201215911851.png" alt="image-20201201215911851" style="zoom: 67%;" /><ol start="3"><li>Object invoke(Object obj, Object … args)，说明：<ul><li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li><li>若原方法若为静态方法，此时形参Object obj可为null</li><li>若原方法形参列表为空，则Object[] args为null</li><li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定属性</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        id.set(person, <span class="number">1001</span>);</span><br><span class="line">        Object o = id.get(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        age.set(person, <span class="number">18</span>);</span><br><span class="line">        Object o1 = age.get(person);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line">        <span class="comment">// 获取指定的某个方法</span></span><br><span class="line">        <span class="comment">//getDeclaredMethod(): 参数1：指明获取的方法的名称  参数2：指明获取的方法形参列表</span></span><br><span class="line">        Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//保证当前方法时可访问的</span></span><br><span class="line">        show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//调用invoke()方法：参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line">        <span class="comment">//invoke()的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line">        Object o = show.invoke(person, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">      </span><br><span class="line">     System.out.println(<span class="string">&quot;*************调用静态方法***************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Method showDesc = clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">        showDesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        showDesc.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用指定属性"><a href="#调用指定属性" class="headerlink" title="调用指定属性"></a>调用指定属性</h3><p>​    在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201220154222.png" alt="image-20201201220154222" style="zoom: 50%;" /><h3 id="关于setAccessible方法的使用"><a href="#关于setAccessible方法的使用" class="headerlink" title="关于setAccessible方法的使用"></a>关于setAccessible方法的使用</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201220256922.png" alt="image-20201201220256922" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定属性</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        id.set(person, <span class="number">1001</span>);</span><br><span class="line">        Object o = id.get(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        age.set(person, <span class="number">18</span>);</span><br><span class="line">        Object o1 = age.get(person);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射的应用：动态代理"><a href="#反射的应用：动态代理" class="headerlink" title="反射的应用：动态代理"></a>反射的应用：动态代理</h2><ol><li>代理设计模式的原理:<ul><li>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上</li></ul></li><li>静态代理：特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:20 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClothFactory factory;  <span class="comment">// 用被代理的对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        NikeClothFactory nike = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态代理：是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p></li><li><p>动态代理使用场合：</p><ul><li>调试</li><li>远程方法调用</li></ul></li><li><p>动态代理相比于静态代理的优点：</p><ul><li>抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li></ul></li></ol><h3 id="Java动态代理相关API"><a href="#Java动态代理相关API" class="headerlink" title="Java动态代理相关API"></a>Java动态代理相关API</h3><ol><li><p>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。</p></li><li><p>供用于创建动态代理类和动态代理对象的静态方法</p><ul><li>创建一个动态代理类所对应的Class对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</span><br></pre></td></tr></table></figure><ul><li>直接创建一个动态代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202091232315.png" alt="image-20201202091232315" style="zoom: 50%;" /></li></ol><h3 id="动态代理步骤"><a href="#动态代理步骤" class="headerlink" title="动态代理步骤"></a>动态代理步骤</h3><ol><li>创建一个实现接口. InvocationHandler. 的类，它必须实现invoke方法，以完成代理的具体操作。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202094849540.png" alt="image-20201202094849540" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101431301.png" alt="image-20201202101431301"></p><ol start="2"><li>创建被代理的类以及接口</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101502146.png" alt="image-20201202101502146" style="zoom:50%;" /><ol start="3"><li>通过Proxy的静态方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101626255.png" alt="image-20201202101626255" style="zoom: 50%;" /><ol start="4"><li>通过 Subject代理调用RealSubject实现类的方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101648873.png" alt="image-20201202101648873" style="zoom:50%;" /><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 动态代理的举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:30 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I believe I can fly!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;  <span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 赋值时，需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);  <span class="comment">// 反射</span></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中invoke(）的返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance：代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法</span></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;麻辣香锅&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理与AOP-Aspect-Orient-Programming"><a href="#动态代理与AOP-Aspect-Orient-Programming" class="headerlink" title="动态代理与AOP(Aspect Orient Programming)"></a>动态代理与AOP(Aspect Orient Programming)</h3><ol><li>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102356348.png" alt="image-20201202102356348" style="zoom:50%;" /><ol start="2"><li>改进后的说明:代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和 一个特定的方法A耦合了!最理想的效果是:代码块1、2、3既可以执行方法A，又无须在程序 中以硬编码的方式直接调用深色代码的方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102458808.png" alt="image-20201202102458808" style="zoom: 50%;" /><ol start="3"><li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理</li><li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异: ==AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理==</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102635867.png" alt="image-20201202102635867" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 动态代理的举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:30 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I believe I can fly!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================通用方法一===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================通用方法二===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;  <span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 赋值时，需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        HumanUtil util = <span class="keyword">new</span> HumanUtil();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);  <span class="comment">// 反射</span></span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中invoke(）的返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance：代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法</span></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;麻辣香锅&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构&quot;&gt;&lt;a href=&quot;#重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构&quot; class=&quot;headerlink&quot; title=&quot;重点掌握：获取Class实例、创建运行时</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
