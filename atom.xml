<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asteroid</title>
  
  
  <link href="https://asteroidcs.github.io/atom.xml" rel="self"/>
  
  <link href="https://asteroidcs.github.io/"/>
  <updated>2020-12-15T01:44:31.426Z</updated>
  <id>https://asteroidcs.github.io/</id>
  
  <author>
    <name>Komorebi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十章 枚举类与注解</title>
    <link href="https://asteroidcs.github.io/undefined/df1b.html"/>
    <id>https://asteroidcs.github.io/undefined/df1b.html</id>
    <published>2020-12-12T02:37:20.086Z</published>
    <updated>2020-12-15T01:44:31.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h2><ol><li>$\color{red}{类的对象只有有限个，确定的}$。如</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215085702947.png" alt="image-20201215085702947" style="zoom: 33%;" /><ol start="2"><li><p>$\color{gold}{当需要定义一组常量时，强烈建议使用枚举类。}$</p></li><li><p>如果枚举类中只有一个对象，则可以作为一种单例模式的实现方式</p></li><li><p><strong>枚举类的属性：</strong></p><ul><li><p>$\color{gold}{枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰}$</p></li><li><p>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</p></li><li><p>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</p></li></ul></li><li><p><strong>注意：</strong></p><ul><li><p>私有化类的构造器，保证不能在类的外部创建其对象</p></li><li><p>在类的内部创建枚举类的实例。声明为：$\color{blue}{public static final}$</p></li><li><p>对象如果有实例变量，应该声明为$\color{blue}{private final}$，并在构造器中初始化</p></li></ul></li></ol><h3 id="如何自定义枚举类"><a href="#如何自定义枚举类" class="headerlink" title="如何自定义枚举类"></a>如何自定义枚举类</h3><ol><li>方式一：JDK 5.0之前，自定义枚举类</li><li>方式二：JDK 5.0时，可以是可以使用$\color{blue}{enum关键字}$定义枚举类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义枚举类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-14 12:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season spring = Season.SPRING;</span><br><span class="line">        System.out.println(spring);<span class="comment">//Season&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器，并给对象属性初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求2：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">详细描述</th></tr></thead><tbody><tr><td align="center">valueOf</td><td align="center">传递枚举类型的Class对象和枚举常量名称给静态方法valueOf，会的到与参数匹配的枚举常量</td></tr><tr><td align="center">toString</td><td align="center">得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读</td></tr><tr><td align="center">equals</td><td align="center">在枚举类型中可以直接使用“==”来比较两个枚举常量是否相等。Enum提供的这个equals()方法也是直接使用“==”实现的。它的存在是为了在Set、List和Map中使用。<strong>注意：</strong>equals()是不可变的。</td></tr><tr><td align="center">hashCode</td><td align="center">Enum实现了hashCode()来和equals()保持一致，它也是不可变的。</td></tr><tr><td align="center">getDeclaringClass</td><td align="center">得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。</td></tr><tr><td align="center">name</td><td align="center">得到当前枚举常量的名称。建议优先使用toString()。</td></tr><tr><td align="center">ordinal</td><td align="center">得到当前枚举常量的次序。</td></tr><tr><td align="center">compareTo</td><td align="center">枚举类型实现了Comparable接口这样可以比较两个枚举常量的大小(按照声明的顺序排列)</td></tr><tr><td align="center">clone</td><td align="center">枚举类型不能被Clone。为了防止子类实现克隆方法。Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()。</td></tr></tbody></table><ul><li>$\color{red}{values()方法：}$返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li><li>$\color{red}{valueOf(String str)：}$返回枚举类对象名是str的对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</li><li>$\color{red}{toString()：}$返回当前枚举类对象常量的名称。</li></ul><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h3><ul><li>和普通 Java 类一样，枚举类可以实现一个或多个接口。</li><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。</li></ul><p>情况一：实现接口，在enum类中实现抽象方法。直接在接口类中重写抽象方法即可。</p><p>情况二：让枚举类的对象分别实现接口中的抽象方法。需要在每一个枚举对象后重写具有针对性的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line"> &#125; &#125;,</span><br><span class="line">SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><h3 id="注解-Annotation-概述"><a href="#注解-Annotation-概述" class="headerlink" title="注解(Annotation)概述"></a>注解(Annotation)概述</h3><ul><li>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)。</li><li>Annotation其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li><li>Annotation可以像修饰符一样被使用, 可用于$\color{red}{修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, }$这些信息被保存在Annotation的“name=value”对中。</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li><li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：$\color{gold}{框架 = 注解 + 反射 + 设计模式。}$</li></ul><h3 id="常见的Annotation示例"><a href="#常见的Annotation示例" class="headerlink" title="常见的Annotation示例"></a>常见的Annotation示例</h3><ul><li>使用Annotation时要在其前面增加@符号, 并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素。</li><li>$\color{gold}{示例一：生成文档相关的注解}$<ul><li>@author 标明开发该类模块的作者，多个作者之间使用,分割</li><li>@version 标明该类模块的版本</li><li>@see 参考转向，也就是相关主题</li><li>@since 从哪个版本开始增加的</li><li>@param 对方法中某参数的说明，如果没有参数就不能写</li><li>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</li><li>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</li><li>其中：<ul><li>@param @return 和 @exception 这三个标记都是只用于方法的。</li><li>@param的格式要求：@param 形参名 形参类型 形参说明。</li><li>@return 的格式要求：@return 返回值类型 返回值说明。</li><li>@exception的格式要求：@exception 异常类型 异常说明。</li><li>@param和@exception可以并列多个。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavadocTest</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 求圆面积的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.PI * radius * radius; </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>$\color{gold}{示例二：在编译时进行格式检查(JDK内置的三个基本注解)}$</p><ul><li><p><strong>@Override:</strong> 限定重写父类方法, 该注解只能用于方法。</p></li><li><p>**@Deprecated: ** 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。</p></li><li><p><strong>@SuppressWarnings:</strong> 抑制编译器警告。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>; </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$\color{gold}{示例三：跟踪代码依赖性，实现替代配置文件功能}$<ul><li>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。</li><li>spring框架中关于“事务”的管理。</li></ul></li></ul><h3 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h3><ul><li>定义新的 Annotation 类型使用 @interface 关键字。</li><li>自定义注解自动继承了java.lang.annotation.Annotation接口。</li><li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</li><li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字。</li><li>如果只有一个参数成员，建议使用参数名为value。</li><li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”。</li><li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation。</li><li>$\color{red}{<strong>注意：</strong>自定义注解必须配上注解的信息处理流程(使用反射)才有意义。}$</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._02annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何自定义注解：参照<span class="doctag">@SuppressWarnings</span>定义</span></span><br><span class="line"><span class="comment"> *  ① 注解声明为<span class="doctag">@interface</span></span></span><br><span class="line"><span class="comment"> *  ② 内部定义成员，通常使用value表示</span></span><br><span class="line"><span class="comment"> *  ③ 可以指定成员的默认值，使用default定义</span></span><br><span class="line"><span class="comment"> *  ④ 如果自定义注解没有成员，表明是一个表标识作用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果注解有成员，在使用注解时，需要指明成员的值。</span></span><br><span class="line"><span class="comment"> *  应用：<span class="doctag">@MyAnnotation</span>(value=&quot;自己指定值，未指定则为default值&quot;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-14 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK的元注解"><a href="#JDK的元注解" class="headerlink" title="JDK的元注解"></a>JDK的元注解</h3><ol><li><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义。</p></li><li><p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p><p> ①Retention</p><p> ②Target</p><p> ③Documented</p><p> ④Inherited</p></li><li><p>$\color{red}{@Retention：}$只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值:</p><ul><li>RetentionPolicy.SOURCE：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</li><li>RetentionPolicy.CLASS：在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值。</li><li>RetentionPolicy.RUNTIME：在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215093348578.png" alt="image-20201215093348578" style="zoom: 50%;" /><ol start="4"><li>$\color{red}{@Target：}$用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215093547060.png" alt="image-20201215093547060" style="zoom: 50%;" /><ol start="5"><li>@Documented：用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。<ul><li>定义为Documented的注解必须设置Retention值为RUNTIME。</li></ul></li><li>@Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。<ul><li>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解。</li><li>实际应用中，使用较少。</li></ul></li></ol><h3 id="利用反射获取注解信息-在反射部分涉及"><a href="#利用反射获取注解信息-在反射部分涉及" class="headerlink" title="利用反射获取注解信息(在反射部分涉及)"></a>利用反射获取注解信息(在反射部分涉及)</h3><h3 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h3><ul><li><p>Java 8对注解处理提供了两点改进：$\color{red}{可重复的注解}$及$\color{red}{可用于类型的注解}$。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。</p></li><li><p><strong>可重复注解：</strong></p><ul><li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class；</li><li>MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</li></ul></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215094034532.png" alt="image-20201215094034532" style="zoom: 50%;" /><ul><li><p><strong>类型注解：</strong></p><ul><li><p>DK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE </p><p>①ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。</p><p>②ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p></li></ul></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215094150569.png" alt="image-20201215094150569" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201215094226615.png" alt="image-20201215094226615" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举类的使用&quot;&gt;&lt;a href=&quot;#枚举类的使用&quot; class=&quot;headerlink&quot; title=&quot;枚举类的使用&quot;&gt;&lt;/a&gt;枚举类的使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;$\color{red}{类的对象只有有限个，确定的}$。如&lt;/li&gt;
&lt;/ol&gt;
&lt;img s</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第九章 常用类</title>
    <link href="https://asteroidcs.github.io/undefined/f1a6.html"/>
    <id>https://asteroidcs.github.io/undefined/f1a6.html</id>
    <published>2020-12-12T02:36:33.038Z</published>
    <updated>2020-12-14T08:23:50.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串相关的类：String"><a href="#字符串相关的类：String" class="headerlink" title="字符串相关的类：String"></a>字符串相关的类：String</h2><h3 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h3><ol><li>String类：代表字符串。Java程序中所有的字符串面值（如”abc”）都作为此类的实例实现。</li><li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li><li>String内部定义了final char[] value用于存储字符串数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="comment">/**    The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**    Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//Default to 0</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>String实现了Serializable接口：表示字符串是支持序列化的；</p><p>实现了Comparable接口：表示String可以比较大小。</p></li><li><p>String是一个final类，代表不可改变的字符序列。体现：</p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201101150047.png" alt="img" style="zoom:50%;" /><ol start="6"><li>通过字面量的方式（区别于new）给一个字符赋值，此时的字符串值生命在字符串常量池中。</li><li>字符串常量池中是不会存储相同内容的字符串的。</li></ol><h3 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value,value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);</span><br><span class="line"></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure><p><strong>String的实例化方式：</strong></p><ol><li>方式一：通过字面量定义的方式</li><li>方式二：通过 new + 构造器 的方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的实例化方式</span></span><br><span class="line"><span class="comment"> * 方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二：通过 new + 构造器 的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过字面量定义的方式：此时的s1和s2的数据JavaEE声明在方法区的字符串常量池中。</span></span><br><span class="line">    String s1 = <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 new + 构造器 的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201101160255.png" alt="img" style="zoom:50%;" /><p><strong>面试题：</strong><code>String str1 = &quot;abc&quot;;</code>与<code>String str2 = new String (&quot;abc&quot;);</code>的区别？</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201101155731.png" alt="img" style="zoom: 50%;" /><h3 id="字符串对象是如何存储的"><a href="#字符串对象是如何存储的" class="headerlink" title="字符串对象是如何存储的"></a>字符串对象是如何存储的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;********************&quot;</span>);</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(p1.name.equals(p2.name));<span class="comment">//true</span></span><br><span class="line">    System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201101161856.png" alt="img" style="zoom:50%;" /><p><strong>面试题：</strong><code>String s = new String(&quot;abc&quot;);</code>方式创建对象，在内存中创建了几个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：<span class="number">2</span>个。一个是堆空间中<span class="keyword">new</span>的结构，另一个是<span class="keyword">char</span>[]对应的常量池中的数据（”abc”）。</span><br></pre></td></tr></table></figure><p><strong>练习题：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;JavaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;JavaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;JavaEE&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    String s8 = s5.intern();<span class="comment">//返回值得到的s8使用的是常量池中已经存在的“JavaEEhadoop”</span></span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201101171156.png" alt="img" style="zoom:50%;" /><p><strong>结论：</strong></p><ul><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li><li>只要其中有一个变量，结果就在堆空间中。</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ul><h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><ol><li><p>nt length()：返回字符串的长度： return value.length。</p></li><li><p>char charAt(int index)：返回某索引处的字符：return value[index]。</p></li><li><p>boolean isEmpty()：判断是否是空字符串：return value.length == 0。</p></li><li><p>String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写。</p></li><li><p>String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写。</p></li><li><p>String trim()：返回字符串的副本，忽略前导空白和尾部空白。</p></li><li><p>boolean equals(Object obj)：比较字符串的内容是否相同。</p></li><li><p>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写。</p></li><li><p>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”。</p></li><li><p>int compareTo(String anotherString)：比较两个字符串的大小。</p></li><li><p>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</p></li><li><p>String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</p></li><li><p>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</p></li><li><p>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</p></li><li><p>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</p></li><li><p>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true。</p></li><li><p>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引。</p></li><li><p>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p></li><li><p>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引。</p></li><li><p>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1。</p></li><li><p>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p></li><li><p>String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p></li><li><p>String replaceAll(String regex, String replacement)：使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p></li><li><p>String replaceFirst(String regex, String replacement)：使 用 给 定 的eplacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p></li><li><p>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</p></li><li><p>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</p></li><li><p>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p></li></ol><h3 id="String与基本数据类型转换"><a href="#String与基本数据类型转换" class="headerlink" title="String与基本数据类型转换"></a>String与基本数据类型转换</h3><ul><li><p>字符串 → 基本数据类型、包装类</p><p>① Integer包装类的public static int parseInt(String s)：可将由“数字”字符组成的字符串转换为整形。</p><p>② 类似的，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</p></li><li><p>基本数据类型、包装类 → 字符串</p><p>① 调用String类的public String valueOf(int n)可将int型转换为字符串。</p><p>② 相应的，valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型2到字符串的转换。</p></li><li><p>字符数组 → 字符串</p><p>① String类的构造器：String(char[])和String(char[], int offset, int length)分别用字符数组中的全部字符和部分字符创建字符串对象。</p></li><li><p>字符串 → 字符数组</p><p>① public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</p><p>② public void getChars(int srcBegin, int srcEnd, char dst, int dstBegin)：提供了将制定索引范围内的字符串存放到数组中的方法。</p></li><li><p>字节数组 → 字符串</p><p>① String(byte[])：通过使用平台的默认字符集解码指定的byte数组，构造一个新的String。</p><p>② String(byte[], int offset, int length)：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构成一个字符串对象。</p></li><li><p>字符串 → 字节数组</p><p>① public byte[] getBytes()：使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中。</p><p>② public byte[] getBytes(String charsetName)：使用指定的字符集将此String编码到byte序列，并将结果存储到新的byte数组。</p><p>实际应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._01string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 涉及到String类与其他结构之间的转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-03 14:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String与基本数据类型、包装类之间的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//字符串 → 基本数据类型、包装类</span></span><br><span class="line">        String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(str1);<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本数据类型、包装类 → 字符串</span></span><br><span class="line">        String str2 = String.valueOf(num);<span class="comment">//&quot;123&quot;</span></span><br><span class="line">        String str3 = num + <span class="string">&quot;&quot;</span>;<span class="comment">//&quot;123&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String与char[]之间的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc123&quot;</span>;<span class="comment">//题目：反转字符串指定部分字母，例：a21cb3</span></span><br><span class="line">        <span class="comment">//Sting → char[]：调用String的toCharArray()方法</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = str1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            System.out.println(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//char[] → Sting：调用String的构造器</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(arr);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String与byte[]之间的转换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 编码：字符串 → 字节</span></span><br><span class="line"><span class="comment">     * 解码：解码的逆过程，字节 → 字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 说明：解码时，要求解码使用的字符集必须与编码使用的字符集一致，否则会出现乱码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;原字符串str1：&quot;</span> + str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String → byte[]：调用String的getBytes()方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用默认的字符集(UTF-8)编码str1为bytes：&quot;</span> + Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用gbk编码str1为gbks：&quot;</span> + Arrays.toString(gbks));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//byte[] → String：</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(bytes);<span class="comment">//使用默认的字符集，进行解码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用默认字符集(UTF-8)解码bytes：&quot;</span> + str2);</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(gbks);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用默认字符集(UTF-8)解码gbks：&quot;</span> + str3);<span class="comment">//出现乱码，原因：编码集和解码集不一致</span></span><br><span class="line"></span><br><span class="line">        String str4 = <span class="keyword">new</span> String(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//指定解码方式为gbk</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用gbk解码gbks：&quot;</span> + str4);<span class="comment">//没有出现乱码，原因：编码集与解码集一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="StringBuffer与StringBuilder类"><a href="#StringBuffer与StringBuilder类" class="headerlink" title="StringBuffer与StringBuilder类"></a>StringBuffer与StringBuilder类</h3><ol><li><strong>String/StringBuffer、StringBuilder三者的异同？</strong><ul><li>String：不可变的字符序列；底层结构使用char[]存储。</li><li>StringBuffer：可变的字符序列；线程安全的，效率低；底层结构使用char[]存储。</li><li>StringBuilder：可变的字符序列；JDK 5.0新增的，线程不安全的，效率高；底层结构使用char[]存储。</li></ul></li><li><strong>源码分析：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String();<span class="comment">//char[] value = new char[];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//char[] value = new char[16];底层创建了一个长度为16的数组。</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;c&#x27;</span>);<span class="comment">//value[2] = &#x27;c&#x27;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length + 16];</span></span><br></pre></td></tr></table></figure><p><strong>问题1</strong> <code>System.out.println(sb2.length());//3</code></p><p><strong>问题2</strong> 扩容问题，如果要添加的数据底层数组存不下了，那就需要扩容底层数组。<br>默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p><ul><li><strong>指导意义：</strong>开发中建议使用StringBuffer(int capacity)或StringBuilder(int capacity)以指定长度，避免扩容浪费资源，降低效率。</li></ul><h4 id="StringBuffer的常用方法：（StringBuilder与它相同）"><a href="#StringBuffer的常用方法：（StringBuilder与它相同）" class="headerlink" title="StringBuffer的常用方法：（StringBuilder与它相同）"></a><strong>StringBuffer的常用方法：（StringBuilder与它相同）</strong></h4><ol><li>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接。</li><li>StringBuffer delete(int start,int end)：删除指定位置的内容。</li><li>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str。</li><li>StringBuffer insert(int offset, xxx)：在指定位置插入xxx。</li><li>StringBuffer reverse() ：把当前字符序列逆转。</li><li>public int indexOf(String str)：返回字符串第一次出现的索引。</li><li>public String substring(int start,int end)：返回一个从start开始到end索引结束的左闭右开区间的子字符串。</li><li>public int length()：</li><li>public char charAt(int n)</li><li>public void setCharAt(int n ,char ch)</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>增：append(xxx)</li><li>删：delete(int start,int end)</li><li>改：setCharAt(int n ,char ch)修改一个字符，replace(int start, int end, String str)修改一个字符串</li><li>查：char charAt(int n)</li><li>插：insert(int offset, xxx)</li><li>长度：length()</li><li>*遍历：for() + charAt()、toString()</li></ol><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._01string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于StringBuffer和StringBuilder的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-03 15:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String/StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment">    String：不可变的字符序列；底层结构使用char[]存储；</span></span><br><span class="line"><span class="comment">    StringBuffer：可变的字符序列；线程安全的，效率低；底层结构使用char[]存储；</span></span><br><span class="line"><span class="comment">    StringBuilder：可变的字符序列；JDK 5.0新增的，线程不安全的，效率高；底层结构使用char[]存储；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(sb1);<span class="comment">//mbc，可变</span></span><br><span class="line"></span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(sb2.length());<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuffer的常用方法：（StringBuilder与它相同）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.append(<span class="number">1</span>);</span><br><span class="line">        s1.append(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//abc12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        s1.delete(2,4);//ab2</span></span><br><span class="line"><span class="comment">//        s1.replace(2,4,&quot;hello&quot;);//abhello2</span></span><br><span class="line"><span class="comment">//        s1.insert(2,false);//abfalsec12,s1.length() = 10</span></span><br><span class="line"><span class="comment">//        s1.reverse();//21cba</span></span><br><span class="line">        String s2 = s1.substring(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//bc</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比String、StringBuffer、StringBuilder三者的效率</span></span><br><span class="line"><span class="comment">     * 从高到低：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始设置</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//开始对比</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            buffer.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            builder.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++)&#123;</span><br><span class="line">            text = text + i;</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK-8之前的日期时间API"><a href="#JDK-8之前的日期时间API" class="headerlink" title="JDK 8之前的日期时间API"></a>JDK 8之前的日期时间API</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201104222102.png" alt="img" style="zoom: 67%;" /><h3 id="java-lang-System类"><a href="#java-lang-System类" class="headerlink" title="java.lang.System类"></a>java.lang.System类</h3><ul><li><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p></li><li><p>此方法适于计算时间差。</p></li><li><p>计算世界时间的主要标准有</p><ul><li>UTC(Coordinated Universal Time)</li><li>GMT(Greenwich Mean Time)</li><li>CST(Central Standard Time)</li></ul></li><li><p>应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System类中的currentTimeMillis()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">    <span class="comment">//称为时间戳</span></span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="java-util-Date类"><a href="#java-util-Date类" class="headerlink" title="java.util.Date类"></a>java.util.Date类</h3><p>表示特定的瞬间，精确到毫秒。</p><ul><li><p>构造器：</p><p>① Date()：使用无参构造器创建的对象可以获取本地的当前时间。</p><p>② Date(long date)</p></li><li><p>常用方法</p><p>① getTime()：返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。</p><p>② toString()：把此Date对象转换成以下形式的String：dow mon dd hh:mm:ss zzz yyyy 其中：dow是一周中的某一天（Sun，Mon，Tue，Wed，Thu，Fri，Sat），zzz是时间标准。</p><p>③ 其他很多方法都过时了。</p></li><li><p>应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.util.Date类</span></span><br><span class="line"><span class="comment"> *      |---java.sql.Date类</span></span><br><span class="line"><span class="comment"> *  1.两个构造器的使用</span></span><br><span class="line"><span class="comment"> *      &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment"> *      &gt;构造器二：创建指定毫秒数的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2.两个方法的使用</span></span><br><span class="line"><span class="comment"> *      &gt;toString()：显示当前年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment"> *      &gt;getTime()：获取当前Date对象对应的的时间戳。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3.java.sql.Date对应着数据库中的日期类型变量</span></span><br><span class="line"><span class="comment"> *      &gt;如何实例化</span></span><br><span class="line"><span class="comment"> *      &gt;如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">    Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(date1.toString());<span class="comment">//Wed Nov 04 22:40:52 CST 2020</span></span><br><span class="line"></span><br><span class="line">    System.out.println(date1.getTime());<span class="comment">//1604500906084</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器二：创建指定毫秒数的对象</span></span><br><span class="line">    Date date2 = <span class="keyword">new</span> Date(<span class="number">1604500906084L</span>);</span><br><span class="line">    System.out.println(date2.toString());<span class="comment">//Wed Nov 04 22:41:46 CST 2020</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">    java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1604500906084L</span>);</span><br><span class="line">    System.out.println(date3);<span class="comment">//2020-11-04</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="comment">//情况一：</span></span><br><span class="line">    <span class="comment">//        Date date4 = new java.sql.Date(1604500906084L);</span></span><br><span class="line">    <span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">    <span class="comment">//情况二：</span></span><br><span class="line">    Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">    java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="java-text-SimpleDateFormat类"><a href="#java-text-SimpleDateFormat类" class="headerlink" title="java.text.SimpleDateFormat类"></a>java.text.SimpleDateFormat类</h3><p>​        SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析。</p><ul><li><p>两个操作</p><p>① 格式化：日期 → 字符串</p><p>② 解析：格式化的逆过程，字符串 → 日期</p></li><li><p>实例化</p></li><li><p>应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.两个操作：</span></span><br><span class="line"><span class="comment"> * 1.1 格式化：日期 --&gt; 字符串</span></span><br><span class="line"><span class="comment"> * 1.2 解析：格式化的逆过程，字符串 --&gt; 日期</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.SimpleDateFormat的实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化SimpleDateFormat：使用默认构造器</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化：日期 --&gt; 字符串</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">    String format = sdf.format(date);</span><br><span class="line">    System.out.println(format);<span class="comment">//20-11-6 下午10:13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：格式化的逆过程，字符串 --&gt; 日期</span></span><br><span class="line">    String str = <span class="string">&quot;20-11-6 下午10:13&quot;</span>;</span><br><span class="line">    Date date1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        date1 = sdf.parse(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(date1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//************按照指定的方式格式化和解析：调用带参的构造器*****************</span></span><br><span class="line">    <span class="comment">//        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);</span></span><br><span class="line">    SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss aaa&quot;</span>);</span><br><span class="line">    String format1 = sdf1.format(date);</span><br><span class="line">    System.out.println(format1);<span class="comment">//2020-11-06 10:23:14 下午</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：要求字符串必须符合SimpleDateFormat识别的格式（通过构造器参数体现）</span></span><br><span class="line">    Date date2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        date2 = sdf1.parse(<span class="string">&quot;2020-11-06 10:23:14 下午&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(date2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>练习：</strong>将字符串”2020-09-08”转换为java.sql.Date</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 练习一：字符串&quot;2020-09-08&quot;转换为java.sql.Date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String birth = <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    Date date = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        date = sdf.parse(birth);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ParseException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    java.sql.Date birthDate = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">    System.out.println(birthDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-util-Calender-日历-类"><a href="#java-util-Calender-日历-类" class="headerlink" title="java.util.Calender(日历)类"></a>java.util.Calender(日历)类</h3><ul><li>Calendar是一个抽象基类，主要用于完成日期字段之间相互操作的功能。</li></ul><ul><li><p>获取Calendar实例的方法：</p><p>① 使用Calendar.getInstance()方法</p><p>② 调用它的子类GregorianCalendar的构造器</p></li><li><p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND。</p><p>①pubilc void set(int field,int value)：field为本周/月/年的第几天，将今天改为指定周/月/年的第value天；</p><p>②public void add(int field,int amount)：将本周/月/年的第field天加/减amount天；</p><p>③public final Date getTime()：将Calendar类转换为Date类；</p><p>④public fianl void setTime(Date date)：将Date类转换为Calendar类。</p></li><li><p>注意：</p><p>①获取月份时：月是0，二月是1，以此类推，12月是11；</p><p>②获取星期时：周日是1，周一是2……周六是7。</p></li><li><p>实际应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calendar日历类（抽象类）的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalendar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.实例化</span></span><br><span class="line">    <span class="comment">//方式一：创建其子类（GregorianCalendar）的对象</span></span><br><span class="line">    <span class="comment">//方式二：调用其静态方法getInstance()</span></span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.常用方法</span></span><br><span class="line">    <span class="comment">//get()</span></span><br><span class="line">    <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//返回今天是本月的第几天</span></span><br><span class="line">    System.out.println(days);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//返回今天是今年的第几天</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set()</span></span><br><span class="line">    calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//将今天改为本月第22天</span></span><br><span class="line">    days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);<span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add()</span></span><br><span class="line">    calendar.add(Calendar.DAY_OF_MONTH,<span class="number">3</span>);</span><br><span class="line">    days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);<span class="comment">//25(22 + 3),减相应天数则将amount改为负数即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getTime()：日历类 --&gt; Date</span></span><br><span class="line">    Date date = calendar.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setTime()：Date --&gt; 日历类</span></span><br><span class="line">    Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">    calendar.setTime(date1);</span><br><span class="line">    days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDK-8中新日期时间API"><a href="#JDK-8中新日期时间API" class="headerlink" title="JDK 8中新日期时间API"></a>JDK 8中新日期时间API</h2><h3 id="新时间日期AP"><a href="#新时间日期AP" class="headerlink" title="新时间日期AP"></a>新时间日期AP</h3><ul><li>java.time：包含值对象的基础包；</li><li>java.time.chrono：提供对不同的日历系统的访问；</li><li>java.time.format – 格式化和解析时间和日期；</li><li>java.time.temporal – 包括底层框架和扩展特性；</li><li>java.time.zone – 包含时区支持的类。</li></ul><p>说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</p><ul><li><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><p>①LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</p><p>②LocalTime表示一个时间，而不是日期。</p><p>③LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201214160105744.png" alt="image-20201214160105744" style="zoom: 50%;" /><p><strong>应用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LocalDate、LocalTime、LocalDateTime的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1.LocalDateTime相较于LocalDate、LocalTime，使用频率更高。</span></span><br><span class="line"><span class="comment"> * 2.类似于Calendar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//now()：获取当前的日期、时间或日期+时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-11-13</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//12:16:39.144</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-11-13T12:16:39.144</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of()：设置指定的年、月、日、时、分、秒，没有偏移量</span></span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">59</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-11-12T12:14:59</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//13</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//FRIDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//NOVEMBER</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//11</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx()：设置相关属性</span></span><br><span class="line">    LocalDate localDate1 = localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-11-13</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-11-22</span></span><br><span class="line"></span><br><span class="line">    LocalDateTime localDateTime2 = localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-11-13T12:25:18.535</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-11-13T04:25:18.535</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//仍体现不可变性</span></span><br><span class="line">    LocalDateTime localDateTime3 = localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-11-13T12:28:01.609</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2021-02-13T12:28:01.609</span></span><br><span class="line"></span><br><span class="line">    LocalDateTime localDateTime4 = localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-11-13T12:30:29.578</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-11-07T12:30:29.578</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="瞬时：Instant"><a href="#瞬时：Instant" class="headerlink" title="瞬时：Instant"></a>瞬时：Instant</h3><ul><li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</li><li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li><li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li><li>(1 ns = 10-9 s) 1秒 = 1000毫秒 =106微秒=109纳秒。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201214160227110.png" alt="image-20201214160227110" style="zoom: 50%;" /><p><strong>应用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instant的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类似于java.util.Date类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//now()：获取本初子午线对应的标准时间</span></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-11-13T04:49:25.712Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-11-13T12:51:00.439+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli()：获取自1970-01-01 00:00:00(UTC)到当前时间的毫秒数 --&gt; 类似Date类的getTime()</span></span><br><span class="line">    <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1605243305678</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli()：通过给定的毫秒数，获取Instant实例 --&gt; 类似Date(long millis)</span></span><br><span class="line">    Instant instant1 = Instant.ofEpochMilli(<span class="number">1605243305678L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-11-13T04:55:05.678Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化与解析日期或时间"><a href="#格式化与解析日期或时间" class="headerlink" title="格式化与解析日期或时间"></a>格式化与解析日期或时间</h3><p>​        java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li><p>预定义的标准格式。如</p><p>ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p></li><li><p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p></li><li><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201214160402235.png" alt="image-20201214160402235" style="zoom: 50%;" /><p><strong>应用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DateTimeFormatter：格式化或解析日期、时间</span></span><br><span class="line"><span class="comment"> * 类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化方式一：预定义标准格式</span></span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化：日期 --&gt; 字符串</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    String str1 = formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-11-13T13:13:58.363</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//显示结果相同，只是类型变了</span></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt; 日期</span></span><br><span class="line">    TemporalAccessor parse = formatter.parse(<span class="string">&quot;2020-11-13T13:13:58.363&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2020-11-13T13:13:58.363</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化方式二：本地化相关的格式。如ofLocalDateTime()</span></span><br><span class="line">    <span class="comment">//FormatStyle.LONG/MEDIUM/SHORT：适用于LocalDateTime</span></span><br><span class="line">    DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    String str2 = formatter1.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年11月13日 下午01时35分39秒</span></span><br><span class="line">    <span class="comment">//解析略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofLocalDate()</span></span><br><span class="line">    <span class="comment">//FormatStyle.FULL/LONG/MEDIUM/SHORT</span></span><br><span class="line">    DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    String str3 = formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020年11月13日 星期五</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点：方式三：自定义格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss E&quot;)</span></span><br><span class="line">    DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    String str4 = formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(str4);<span class="comment">//2020-11-13 04:45:27</span></span><br><span class="line">    <span class="comment">//解析</span></span><br><span class="line">    TemporalAccessor parse1 = formatter3.parse(<span class="string">&quot;2020-11-13 04:45:27&quot;</span>);</span><br><span class="line">    System.out.println(parse1);<span class="comment">//&#123;HourOfAmPm=4, MinuteOfHour=45, SecondOfMinute=27, MilliOfSecond=0, NanoOfSecond=0, MicroOfSecond=0&#125;,ISO resolved to 2020-11-13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><ul><li><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris。</p></li><li><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p><ul><li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等。</li></ul></li><li><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p></li><li><p>持续时间：Duration，用于计算两个“时间”间隔。</p></li><li><p>日期间隔：Period，用于计算两个“日期”间隔。</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法。</p><p>(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。</p></li></ul><h3 id="参考：与传统日期处理的转换"><a href="#参考：与传统日期处理的转换" class="headerlink" title="参考：与传统日期处理的转换"></a>参考：与传统日期处理的转换</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201113221123.png" alt="img" style="zoom: 67%;" /><h2 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h2><p>负整数，如果当前对象this等于形参对象obj，则返回零。 </p><h3 id="方式一：自然排序-java-lang-Comparable"><a href="#方式一：自然排序-java-lang-Comparable" class="headerlink" title="方式一：自然排序(java.lang.Comparable)"></a>方式一：自然排序(java.lang.Comparable)</h3><ol><li><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </p></li><li><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</p><ul><li>如果当前对象this大 于形参对象obj，则返回正整数</li><li>如果当前对象this小于形参对象obj，则返回负整数</li><li>如果当前对象this等于形参对象obj，则返回零</li></ul></li><li><p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 </p></li><li><p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。</p></li><li><p><strong>Comparable</strong> <strong>的典型实现</strong>：(默认都是从小到大排列的) </p><ul><li>String：按照字符串中字符的Unicode值进行比较</li><li>Character：按照字符的Unicode值来进行比较</li></ul></li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;JJ&quot;</span>, <span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">//[Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=23.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：定制排序-java-util-Comparator"><a href="#方式二：定制排序-java-util-Comparator" class="headerlink" title="方式二：定制排序(java.util.Comparator)"></a>方式二：定制排序(java.util.Comparator)</h3><ol><li><p><strong>当元素的类型没有实现</strong>java.lang.Comparable接口而又不方便修改代码，**<em>或者实现了**</em>java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 <strong>Comparator</strong> <strong>的对象来排序</strong>，强行对多个对象进行整体排序的比较。</p></li><li><p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</p><ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul></li><li><p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），</p><p>从而允许在排序顺序上实现精确控制。 </p></li><li><p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的</p><p>顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p></li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;JJ&quot;</span>, <span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">        <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                String s1 = (String)o1;</span><br><span class="line">                String s2 = (String)o2;</span><br><span class="line">                <span class="keyword">return</span> -s1.compareTo(s2);<span class="comment">//从大到小</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));<span class="comment">//[MM, KK, JJ, GG, DD, CC, AA]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 练习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    arr[<span class="number">5</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先按照产品名称从高到低，在按照价格从高到低排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                Goods g1 = (Goods)o1;</span><br><span class="line">                Goods g2 = (Goods)o2;</span><br><span class="line">                <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">//[Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=22.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=23.0&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ol><li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p></li><li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p></li><li><p>成员变量：System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p></li><li><p>成员方法</p><ul><li><p>native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p></li><li><p>void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p></li><li><p>void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li><li><p>String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p></li></ul></li></ol><table><thead><tr><th align="center">属性名</th><th align="center">属性说明</th></tr></thead><tbody><tr><td align="center">java.version</td><td align="center">Java运行时环境版本</td></tr><tr><td align="center">java.home</td><td align="center">Java安装目录</td></tr><tr><td align="center">os.name</td><td align="center">操作系统名称</td></tr><tr><td align="center">os.version</td><td align="center">操作系统版本</td></tr><tr><td align="center">user.name</td><td align="center">用户的账户名称</td></tr><tr><td align="center">user.home</td><td align="center">用户的主目录</td></tr><tr><td align="center">user.dir</td><td align="center">用户的当前工作目录</td></tr></tbody></table><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System类的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-13 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String javaVersion = System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">        String javaHome = System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">        String osName = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">        String osVersion = System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">        String userName = System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">        String userHome = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">        String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>​        java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p><ol><li>abs：绝对值</li><li>acos,asin,atan,cos,sin,tan：三角函数</li><li>sqrt：平方根</li><li>pow(double a,doble b)：a的b次幂</li><li>log：自然对数</li><li>exp：e为底指数</li><li>max(double a,double b)：获取两数之中的较大值</li><li>min(double a,double b)：获取两数之中的较小值</li><li>random()：返回0.0到1.0的随机数</li><li>long round(double a)：double型数据a转换为long型（四舍五入）</li><li>toDegrees(double angrad)：弧度—&gt;角度</li><li>toRadians(double angdeg) 角度—&gt;弧度</li></ol><h2 id="BigInteger与BigDecimal"><a href="#BigInteger与BigDecimal" class="headerlink" title="BigInteger与BigDecimal"></a>BigInteger与BigDecimal</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><ul><li><p>nteger类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p></li><li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p></li><li><p>构造器</p><p>BigInteger(String val)：根据字符串构建BigInteger对象</p></li><li><p>常用方法</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201214162043173.png" alt="image-20201214162043173" style="zoom: 50%;" /></li></ul><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p></li><li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p></li><li><p>构造器</p><p>①public BigDecimal(double val)</p><p>②public BigDecimal(String val)</p></li><li><p>常用方法</p><p>①public BigDecimal add(BigDecimal augend)</p><p>②public BigDecimal subtract(BigDecimal subtrahend)</p><p>③public BigDecimal multiply(BigDecimal multiplicand)</p><p>④public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="keyword">package</span> top.triabin._07bigintegerdecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BigInteger和BigDecimal类常用方法的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-13 22:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InteDeciTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">        BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">        BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(bi);</span><br><span class="line">        <span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">        System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">        System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//保留15位小数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串相关的类：String&quot;&gt;&lt;a href=&quot;#字符串相关的类：String&quot; class=&quot;headerlink&quot; title=&quot;字符串相关的类：String&quot;&gt;&lt;/a&gt;字符串相关的类：String&lt;/h2&gt;&lt;h3 id=&quot;String的特性&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第七章 异常处理</title>
    <link href="https://asteroidcs.github.io/undefined/4aff.html"/>
    <id>https://asteroidcs.github.io/undefined/4aff.html</id>
    <published>2020-12-11T16:00:00.000Z</published>
    <updated>2020-12-12T02:33:10.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常概述与异常体系结构"><a href="#异常概述与异常体系结构" class="headerlink" title="异常概述与异常体系结构"></a>异常概述与异常体系结构</h2><ol><li><p>概念：在Java语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）。</p></li><li><p>Java程序在执行过程中所发生的的异常事件可分为两类：</p><p>$\color{blue}{Error：}$Java虚拟机无法解决的严重问题。如JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError（栈溢出）和OOM（java.lang.OutOfMeoryError，堆溢出）。一般不编写针对性的代码进行处理。</p><p>$\color{blue}{Exception：}$其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：</p><ul><li>$\color{red}{指针访问}$</li><li>$\color{red}{试图读取不存在的文件}$</li><li>$\color{red}{网络连接中断}$</li><li>$\color{red}{数组角标越界}$</li></ul></li><li><p>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法时由程序员在编写程序时，就考虑到错误的检测、错误消息提示，以及错误的处理。</p></li><li><p>捕获错误最理想的是在<strong>编译期间</strong>，但有的错误只有在<strong>运行时</strong>才会发生。比如：除数为0，数组下标越界等</p><p>分类：编译时异常和运行时异常</p><ul><li>红色：编译时异常，即受检(checked)异常。</li><li>蓝色：运行时异常，即非受检(unchecked)异常。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201003144226.png" alt="img"  /><ol start="5"><li>运行时异常<ul><li>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</li><li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响。</li></ul></li><li>编译时异常<ul><li>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</li><li>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</li></ul></li></ol><h3 id="面试题：常见的异常有哪些？举例说明"><a href="#面试题：常见的异常有哪些？举例说明" class="headerlink" title="面试题：常见的异常有哪些？举例说明"></a><strong>面试题：</strong>常见的异常有哪些？举例说明</h3><ol><li><p>编译时异常：</p><ul><li><p> IOException</p></li><li><p>FileNotFoundException</p></li><li><p> ClassNotFoundException</p></li></ul></li><li><p>运行时异常：</p><ul><li><p>NullPointerException（空指针异常）</p></li><li><p>ArrayIndexOutOfBoundsException（数组下标越界）</p></li><li><p>ClassCastException</p></li><li><p>NumberFormatException（数字格式化异常）</p></li><li><p>InputMismatchException（输入不匹配异常）</p></li><li><p>ArithmeticException（算数异常）</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">//************************编译时异常************************</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(file);//FileNotFoundException</span></span><br><span class="line"><span class="comment">//        int data = fis.read();//IOException</span></span><br><span class="line"><span class="comment">//        while(data !=-1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char)data);</span></span><br><span class="line"><span class="comment">//            data = fis.read();//IOException</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        fis.close();//IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//************************运行时异常************************</span></span><br><span class="line">    <span class="comment">//ArithmeticException:算术异常</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//InputMismatchException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> score = scan.nextInt();<span class="comment">//当输入类型不是int型时报错：InputMismatchException</span></span><br><span class="line">        System.out.println(score);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NumberFormatException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ClassCastException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">        String str = (String)obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//        System.out.println(arr[10]);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NullPointerException</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;null&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[][] arr = null;</span></span><br><span class="line"><span class="comment">//        System.out.println(arr[3]);</span></span><br><span class="line">        String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理机制一：try-catch-finally"><a href="#异常处理机制一：try-catch-finally" class="headerlink" title="异常处理机制一：try-catch-finally"></a>异常处理机制一：try-catch-finally</h2><h3 id="异常处理：抓抛模型"><a href="#异常处理：抓抛模型" class="headerlink" title="异常处理：抓抛模型"></a>异常处理：抓抛模型</h3><ol><li><p>过程一：“抛”，程序正常执行中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。</p><p>一旦抛出对象以后，其后的代码就不再执行。</p></li><li><p>过程二：“抓”，可以理解为异常的处理方式：① try-catch-finally ②throws</p></li></ol><h3 id="try-catch-finally的使用"><a href="#try-catch-finally的使用" class="headerlink" title="try-catch-finally的使用"></a>try-catch-finally的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h4><ol><li><p>finally是可选的</p></li><li><p>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。</p></li><li><p>一旦try中的异常对象匹配到某一个catch时，就进入到catch中进行异常处理。一旦处理完成，就跳出当前try-catch结构（没有写finally的情况），继续执行其后的代码。</p></li><li><p>catch中的异常类型如果没有子父类关系，则声明的先后（上下）无所谓；catch中的异常类型如果满足子父类关系，则要求一定先声明子类。否则，<strong>报错</strong>。</p></li><li><p>常用的异常对象处理方式：</p><ul><li><p>String getMessage() 获取异常信息，返回字符串</p></li><li><p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void。</p></li></ul></li><li><p>在try结构中声明的变量，在try结构外无法调用。</p><p> 如果确实要在外面调用，可以先在try结构上面初始化变量，再在try结构后面调用。</p></li><li><p>try-catch-finally结构可以嵌套。</p></li></ol><p>体会1：使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现。</p><p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，一定要考虑异常的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = Integer.parseInt(str);</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello--1&quot;</span>);<span class="comment">//未能执行此语句，因为程序遇到异常后直接抛出异常，停止执行后面的语句，转而执行catch操作，异常被catch解决后程序正常执行，所以后面的hello--2正常显示</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;出现数值转换异常了，莫慌……&quot;);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//String getMessage():</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getMessage());</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//printStackTrace():</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello--2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch-finally中finally的使用"><a href="#try-catch-finally中finally的使用" class="headerlink" title="try-catch-finally中finally的使用"></a>try-catch-finally中finally的使用</h3><ol><li>finally是可选的。</li><li>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</li><li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动地进行手动地进行资源的释放。此时的资源释放，就需要声明在finally中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//FileNotFoundException</span></span><br><span class="line">            <span class="keyword">int</span> data = fis.read();<span class="comment">//IOException</span></span><br><span class="line">            <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">                data = fis.read();<span class="comment">//IOException</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            fis.close();//IOException，将此结构放到finally结构中</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fis != <span class="keyword">null</span>)</span><br><span class="line">                    fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = method();</span><br><span class="line">        System.out.println(num);<span class="comment">//先执行finally中的内容，再执行catch中的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我一定会被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;楼主是真的帅！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理机制二：throws"><a href="#异常处理机制二：throws" class="headerlink" title="异常处理机制二：throws"></a>异常处理机制二：throws</h2><h3 id="throws-异常类型"><a href="#throws-异常类型" class="headerlink" title="throws + 异常类型"></a>throws + 异常类型</h3><ol><li><p>“throws + 异常类型” 写在方法的声明处。指明方法执行时可能会抛出的异常类型。</p><p>一旦方法执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时就会被抛出。异常代码后续代码就不再执行。</p></li><li><p>注意：try-catch-finally：真正将异常处理掉了。</p><p>throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p></li><li><p>开发中，如何选择使用try-catch-finally还是throws？</p><ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</li><li>执行的方法a中，先后有调用了另外的几个方法，这几个方法时递进关系执行的。则这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     异常处理的方式二：throws + 异常类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        method3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> data = fis.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>方法重写的规则之一：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     方法重写的规则之一：</span></span><br><span class="line"><span class="comment"> *     子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">        test.display(<span class="keyword">new</span> SubClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(SuperClass s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动抛出异常：throw"><a href="#手动抛出异常：throw" class="headerlink" title="手动抛出异常：throw"></a>手动抛出异常：throw</h2><h3 id="关于异常对象的产生"><a href="#关于异常对象的产生" class="headerlink" title="关于异常对象的产生"></a>关于异常对象的产生</h3><ol><li>系统自动生成的异常对象</li><li>手动生成一个异常对象，并抛出（throw）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            s.regist(-<span class="number">1001</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="comment">//手动抛出一个异常对象</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20201014132746.png" alt="img"></p><h2 id="用户自定义异常类"><a href="#用户自定义异常类" class="headerlink" title="用户自定义异常类"></a>用户自定义异常类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     如何自定义异常类？</span></span><br><span class="line"><span class="comment"> *     1. 继承现有的异常结构：RuntimeException、Exception</span></span><br><span class="line"><span class="comment"> *     2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> *     3. 提供重载构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li><p>编写应用程序EcmDef.java，接收命令行的两个参数，要求不能输入负数，计算两数相除。</p><p>对数据类型不一致（NumberFormatException）、缺少命令行参数（ArrayIndexOutOfBoundsException）、除以0（ArithmeticException）及输入负数（EcDef自定义的异常）进行处理。</p></li><li><p>提示：</p><p>(1) 在主类(EcmDef)中定义异常方法(ecm)完成两数相除功能。</p><p>(2) 在main()方法中使用异常处理语句进行异常处理。</p><p>(3) 在程序中，自定义对应输入负数的异常类(EcDef)。</p><p>(4) 运行时接受参数 <code>java EcmDef 20 10 //args[0]=“20” args[1]=“10”</code>。</p><p>(5) Interger类的static方法parseInt(String s)将s转换成对应的int值。</p><p> 如：<code>int a=Interger.parseInt(“314”); //a = 314</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._06userdefined.exercise1;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *    在程序中，自定义对应输入负数的异常类(EcDef)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcDef</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">           <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">33875164229948L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>(msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._06userdefined.exercise1;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcmDef</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">              <span class="keyword">int</span> j = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">              <span class="keyword">double</span> result = ecm(i,j);</span><br><span class="line">              System.out.println(result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;数据类型不一致&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;缺少命令行参数&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;除数为0&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (EcDef e) &#123;</span><br><span class="line">              System.out.println(e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">       * <span class="doctag">@author</span> Dawn Lee</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@data</span> 2020-10-1414:28:48</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> i 被除数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> j 除数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 商</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> EcDef</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ecm</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> EcDef</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EcDef(<span class="string">&quot;分子或分母为负数了！&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> i / j;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常概述与异常体系结构&quot;&gt;&lt;a href=&quot;#异常概述与异常体系结构&quot; class=&quot;headerlink&quot; title=&quot;异常概述与异常体系结构&quot;&gt;&lt;/a&gt;异常概述与异常体系结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概念：在Java语言中，将程序执行中发生的不正常情</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第八章 多线程 - Java</title>
    <link href="https://asteroidcs.github.io/undefined/2508.html"/>
    <id>https://asteroidcs.github.io/undefined/2508.html</id>
    <published>2020-12-11T16:00:00.000Z</published>
    <updated>2020-12-14T08:22:20.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念：程序、进程、线程"><a href="#基本概念：程序、进程、线程" class="headerlink" title="基本概念：程序、进程、线程"></a>基本概念：程序、进程、线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</li><li>进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡过程。——生命周期<ul><li>如：运行中的QQ，运行中的MP3播放器</li><li>程序是静止的，进程是动态的</li><li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</li></ul></li><li>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。<ul><li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li><li>线程作为调度和执行的单位，**每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小。</li><li>一个进程中的多个线程共享相同的内存单元/内存地址空间→它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简洁、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li></ul></li></ol><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201213104639895.png" alt="image-20201213104639895" style="zoom: 50%;" /><h3 id="单核CPU和多核CPU的理解"><a href="#单核CPU和多核CPU的理解" class="headerlink" title="单核CPU和多核CPU的理解"></a>单核CPU和多核CPU的理解</h3><ol><li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是因为CPU时间单元特别短，因此感觉不出来。</li><li>如果是多核的话，才能更好的发挥多线程的效率。</li><li>一个Java应用程序java.exe，$\color{gold}{其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。}$当然如果发生异常，会影响主线程。</li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ol><li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li><li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li></ol><h3 id="使用多线程的优点"><a href="#使用多线程的优点" class="headerlink" title="使用多线程的优点"></a>使用多线程的优点</h3><p>​        背景：以单核CPU为例，只是用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成的时间要短，为何仍需要多个线程呢？</p><ol><li>提高应用程序的响应。对图形化页面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率。</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li><li>何时需要用到多线程？<ul><li>程序需要同时执行两个或多个任务</li><li>程序要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时、</li></ul></li></ol><h2 id="线程调的创建和使用"><a href="#线程调的创建和使用" class="headerlink" title="线程调的创建和使用"></a>线程调的创建和使用</h2><ul><li>JDK1.5之前创建新执行线程有两种方法： <ul><li>继承Thread类的方式</li><li>实现Runnable接口的方式</li></ul></li></ul><h3 id="线程的创建和启动方式一：继承于Thread类"><a href="#线程的创建和启动方式一：继承于Thread类" class="headerlink" title="线程的创建和启动方式一：继承于Thread类"></a>线程的创建和启动方式一：继承于Thread类</h3><ol><li><p>Java语言的JVM允许程序运行多个线程它通过 java.lang.Thread 类来实现。</p></li><li><p>$\color{gold}{Thread类的特性：}$</p><ul><li><p>每个线程都是通过某个特定的Thread对象的run()方法来操作的，经常把run()方法的主体称为线程体。</p></li><li><p>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()。</p></li></ul></li><li><p><strong>构造器</strong> </p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201213105946190.png" alt="image-20201213105946190" style="zoom: 50%;" /></li><li><p>步骤</p><ul><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()方法 –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread子类对象，即创建了线程对象。</li><li>调用线程对象start方法：启动线程，调用run方法。</li></ul></li><li><p><strong>注意点</strong>：</p><ul><li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li><li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li><li>想要启动多线程，必须调用start方法。</li><li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。</li></ul></li><li><p>使用实例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  例子：遍历100以内所有偶数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-21-22:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">//    2、重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);<span class="comment">//Thread.currentThread().getName()，获取当前线程名称</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建Thread类的子类对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过对象调用start():①启动当前线程  ②调用当前线程的run()方法</span></span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line"><span class="comment">//      问题一：不能通过直接调用run()方法的方式启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      问题二：再启动一个线程，遍历100以内的偶数</span></span><br><span class="line"><span class="comment">//        t1.start();//不可以让已经start()的线程去执行，会报IllegalThreadStateException</span></span><br><span class="line">        <span class="comment">//需要重新创建一个线程对象</span></span><br><span class="line"><span class="comment">//        MyThread t2 = new MyThread();</span></span><br><span class="line"><span class="comment">//        t2.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下操作仍然是在main线程中执行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从运行结果可以看出，两个线程的执行结果交替显示，既两个线程并行执行。</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数。</p><ul><li>方式一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数</span><br><span class="line"> * @author DawnLee</span><br><span class="line"> * @create 2020-10-21-22:52</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread1().start();</span><br><span class="line">        new MyThread2().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 100;i++)&#123;</span><br><span class="line">            if(i % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 100;i++)&#123;</span><br><span class="line">            if(i % 2 !&#x3D; 0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：创建匿名子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="keyword">package</span> top.triabin._01.exer1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-21-22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><ol><li><p>void start()：启动线程并执行对象的run()方法。</p></li><li><p>run()：线程在被调度时执行的操作。</p></li><li><p>String getName()：返回线程的名称。</p></li><li><p>void setName(String name)：设置该线程名称。</p></li><li><p>static Thread courrentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和runnable实现类。</p></li><li><p>static void yield()：线程让步</p><p>① 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。</p><p>② 若队列中没有同优先级的线程，忽略此方法。</p></li><li><p>join()：当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止。</p><ul><li>低优先级的线程也可以获得执行</li></ul></li><li><p>static void sleep(long millis)：（指定时间：毫秒）</p><p>① 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队。</p><p>② 抛出InterruptedException异常</p></li><li><p>stop()：已过时。强制结束线程生命周期，不推荐使用。</p></li><li><p>boolean isAlive()：返回booleean，判断线程是否还活着。</p></li></ol><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><ol><li><p>调度策略</p><ul><li>时间片</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201213132653071.png" alt="image-20201213132653071"></p><ul><li>抢占式：高优先级的线程抢占CPU。</li></ul></li><li><p>Java的调度方法</p><ul><li><p>同优先级线程组成先进先出队列（先到服务），使用时间片策略。</p></li><li><p>对高优先级，使用优先调度的抢占式策略。</p></li></ul></li></ol><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ol><li><p>线程的优先等级(1~10)</p><p>① MAX_PRIORITY：10 → 最大优先级(Thread.MAX_PRIORITY == 10)</p><p>② MIN_PRIORITY：1 → 最小优先级(Thread.MIN_PRIORITY == 1)</p><p>③ NORM_PRIORITY：5 → 默认优先级</p></li><li><p>涉及的方法</p><p>① getPriority()：返回线程优先级</p><p>② setPriority(int newPriority)：改变线程的优先级</p></li><li><p>说明</p><p>① 线程创建时继承父线程的优先级</p><p>② $\color{gold}{低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。}$</p></li></ol><h3 id="线程的创建和启动方式二：实现Runnable接口"><a href="#线程的创建和启动方式二：实现Runnable接口" class="headerlink" title="线程的创建和启动方式二：实现Runnable接口"></a>线程的创建和启动方式二：实现Runnable接口</h3><ol><li>定义子类，实现Runnable接口。</li><li>子类中重写Runnable接口中的run方法。</li><li>通过Thread类含参构造器创建线程对象。</li><li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li><li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例子：遍历100以内的所有偶数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-23 22:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1、创建一个实现Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建实现类的对象</span></span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、通过Thread类的对象调用start()</span></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h3><ol><li><p>开发中：优先选择实现Runnable接口的方式</p><ul><li><strong>原因：</strong><ul><li>实现Runnable接口的方式没有单继承的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li></ul></li></ul></li><li><p><strong>联系：</strong>public class Thread implements Runnable（Thread类本身也实现了Runnable接口）</p></li><li><p><strong>相同点：</strong>两种方式都需要重写run()方法，将线程要执行的逻辑声明在run()中。</p></li></ol><h3 id="补充：线程的分类"><a href="#补充：线程的分类" class="headerlink" title="补充：线程的分类"></a>补充：线程的分类</h3><p>​        Java中，线程分为两类：一种是守护线程，一种是用户线程。</p><ol><li>它们几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</li><li>守护线程是用来服务用户线程的，通过在start()方法前调用Thread.setDaemon(true)可以把一个用户线变成一个守护线程。</li><li>Java垃圾回收站就是一个典型的守护线程。</li><li>若JVM中都是守护线程，当前JVM将退出。</li></ol><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li>JDK中用Thread.State类定义了线程的几种状态：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        想要实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p><ol><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。</li><li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能。</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201213133606193.png" alt="image-20201213133606193" style="zoom: 50%;" /><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>​    <strong>例子：</strong>创建三个窗口卖票，总票数为100张，现使用Runnable接口的方式</p><ol><li><p>问题：卖票过程中，出现了重票、错票 –&gt; 出现了线程的安全问题。</p></li><li><p>问题出现的原因：当年某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</p></li><li><p>如何解决：当线程a在操作ticket（共享数据）的时候，其他线程不能参与进来，直到线程a操作完ticket，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</p></li><li><p>在Java中，通过同步机制来解决线程的安全问题。</p><p><strong>方式一：</strong>同步代码块</p><p><strong>方式二：</strong>同步方法</p></li></ol><h3 id="方式一：同步代码快"><a href="#方式一：同步代码快" class="headerlink" title="方式一：同步代码快"></a>方式一：同步代码快</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>说明：</p><p>​    ① 操作共享数据的代码，即为需要被同步的代码</p><p>​    ② 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据</p><p>​    ③ 同步监视器，俗称：锁。任何一个类的对象都可以充当锁。</p></li><li><p>$\color{red}{要求：}$多个线程必须<strong>共用同一把锁</strong>。</p></li><li><p>补充：</p><ul><li>在实现Runnable接口创建多线程的方式中，可以考虑使用this充当同步监视器；在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类(类名.class)充当同步监视器。</li></ul></li></ol><ul><li>使用同步代码块解决实现Runnable接口中的线程安全问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子：创建三个窗口卖票，总票数为100张，现使用Runnable接口的方式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用同步代码块解决实现Runnable接口的线程安全问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 12:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    Object obj = new Object();</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//此时的this：唯一的Window的对象    //synchronized(obj) &#123;</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用代码块解决继承Thread类的线程安全问题</p><p>与1相似，只需将同步监视器改为 当前类.class 即可。</p></li></ul><h4 id="同步小结："><a href="#同步小结：" class="headerlink" title="同步小结："></a><strong>同步小结：</strong></h4><ol><li>同步的方式解决了线程的安全问题。（好处）</li><li>操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程过程，效率低。（局限性）</li></ol><h3 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h3><p>​        如果操作共享数据的代码完整的声明在一个方法中，可将此方法声明为同步的。</p><ol><li><p>使用同步方法解决实现Runnable接口中的线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="keyword">package</span> top.triabin._04threadsyn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步方法来解决实现Runnable接口的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Win win = <span class="keyword">new</span> Win();</span><br><span class="line"></span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(win);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(win);</span><br><span class="line">        Thread w3 = <span class="keyword">new</span> Thread(win);</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        w2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        w3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Win</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用同步方法处理继承Thread类的方式中的线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="keyword">package</span> top.triabin._04threadsyn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步方法处理继承Thread类的方式中的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 14:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Win2 w1 = <span class="keyword">new</span> Win2();</span><br><span class="line">        Win2 w2 = <span class="keyword">new</span> Win2();</span><br><span class="line">        Win2 w3 = <span class="keyword">new</span> Win2();</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        w2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        w3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Win2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步监视器：Win2.class</span></span><br><span class="line">    <span class="comment">//    private synchronized void show()&#123;//同步监视器：w1,w2,w3，此种解决方法是错误的</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="关于同步方法的总结："><a href="#关于同步方法的总结：" class="headerlink" title="关于同步方法的总结："></a><strong>关于同步方法的总结：</strong></h4><ol><li><p>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</p></li><li><p>非静态的同步方法，同步监视器是：this； </p><p>静态的同步方法，同步监视器是：当前类本身。</p></li></ol><h3 id="使用同步机制将单例模式中的懒汉式改写为线程安全的"><a href="#使用同步机制将单例模式中的懒汉式改写为线程安全的" class="headerlink" title="使用同步机制将单例模式中的懒汉式改写为线程安全的"></a>使用同步机制将单例模式中的懒汉式改写为线程安全的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._04threadsyn.lazysingletion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步机制将单例模式中的懒汉式改写为线程安全的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 15:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h3><ol><li><strong>死锁</strong><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。</li></ul></li><li>**解决方法<ul><li> 专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示线程的死锁问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 22:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三：Lock-锁-—-JDK5-0新增"><a href="#方式三：Lock-锁-—-JDK5-0新增" class="headerlink" title="方式三：Lock(锁) — JDK5.0新增"></a>方式三：Lock(锁) — JDK5.0新增</h3><ol><li><p>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p></li><li><p>java.util.concurrent.locks.Lock 是控制多个线程共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p></li><li><p>ReentrantLook类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁</p></li><li><p>步骤：</p><ul><li>实例化ReentrantLock</li><li>调用锁定方法lock()</li><li>调用解锁方法unlock()</li></ul></li><li><p><strong>实例：</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._04threadsyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题的方式三：Lock锁    --- JDK 5.0新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//2、调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 售票，票号为：&quot;</span> + ticket--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//3、调用解锁方法unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Windows windows = <span class="keyword">new</span> Windows();</span><br><span class="line"></span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(windows);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(windows);</span><br><span class="line">        Thread w3 = <span class="keyword">new</span> Thread(windows);</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        w2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        w3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a><strong>synchronized</strong> <strong>与</strong> <strong>Lock</strong> <strong>的对比</strong></h3><ol><li><p>同：二者都可解决线程安全问题</p></li><li><p>异：synchronized机制在执行完相应的同步代码块以后，自动的释放同步监视器；Lock需要手动的启动同步（lock()）和手动结束同步（unlock()）。</p></li><li><p>优先使用顺序：Lock → 同步代码块（已经进入了方法体，分配了相应资源） → 同步方法（在方法体之外</p></li></ol><ul><li>面试题：如何解决线程安全问题？有几种方式？</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>​    银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</p><p>​    问题：该程序是否有安全问题，如果有，如何解决？</p><p>【<strong>提示</strong>】</p><ol><li>明确哪些代码是多线程运行代码，须写入run()方法。</li><li>明确什么是共享数据。</li><li>明确多线程运行代码中哪些语句是操作共享数据的。</li></ol><p>拓展问题：可否实现两个储户交替存钱的操作？</p><ol><li><strong>分析：</strong><ul><li>是否是多线程问题？ 是，两个储户</li><li>是否有共享数据？ 有，账户（或账户余额）</li><li>是否有线程安全问题？ 有</li><li>需要考虑如何解决线程安全问题？ 同步机制：有三种方式</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._04threadsyn.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</span></span><br><span class="line"><span class="comment"> * 问题：该程序是否有安全问题，如果有，如何解决？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 23:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            balance += amt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存钱成功。余额为：&quot;</span> + balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Account acct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acct = acct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            acct.deposit(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account acct = <span class="keyword">new</span> Account(<span class="number">0</span>);</span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(acct);</span><br><span class="line">        Customer c2 = <span class="keyword">new</span> Customer(acct);</span><br><span class="line"></span><br><span class="line">        c1.setName(<span class="string">&quot;甲&quot;</span>);</span><br><span class="line">        c2.setName(<span class="string">&quot;乙&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><h3 id="线程通信实例：使用两个线程交替打印1-100"><a href="#线程通信实例：使用两个线程交替打印1-100" class="headerlink" title="线程通信实例：使用两个线程交替打印1-100"></a>线程通信实例：使用两个线程交替打印1-100</h3><p><strong>涉及到的三个方法：</strong></p><ol><li>wait(): 一旦执行此方法，当前线程就进入阻塞状态。并释放同步监视器。</li><li>notify(): 一旦执行习方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</li></ol><p><strong>说明：</strong></p><ol><li>上述三个方法必须使用在同步代码块或同步方法中。</li><li>三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常。</li><li>三个方法定义在java.lang.Object类中。</li></ol><p><strong>面试题：</strong>sleep()和wait()的异同？</p><ol><li><p>相同点：一旦执行方法，都可以使当前线程进入阻塞状态。</p></li><li><p>不同点：1）两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()；</p><ul><li><p>调用的范要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中；</p></li><li><p>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，而wait()会。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05threadcommunication.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信实例：使用两个线程交替打印1-100。</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-24 23:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span>(number &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + number++);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//使得调用如下wait()方法的线程进入阻塞状态</span></span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(number);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="经典例题：生产者-消费者问题"><a href="#经典例题：生产者-消费者问题" class="headerlink" title="经典例题：生产者/消费者问题"></a>经典例题：生产者/消费者问题</h3><ol><li><p>生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如人：20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p></li><li><p>这里可能出现两个问题：</p><ul><li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li><li>消费者比生产者快时，消费者会取相同的数据。</li></ul></li></ol><p><strong>分析：</strong></p><ol><li>是否是多线程问题？ 是，生产者线程，消费者线程</li><li>是否有共享数据？ 是，店员（或产品）</li><li>如何解决线程的安全问题？ 同步机制，有三种方法</li><li>是否涉及到线程的通信？ 是</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05threadcommunication.exer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 经典例题：生产者/消费者问题</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-25 19:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始生产第&quot;</span> + ++productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始消费第&quot;</span> + productCount-- + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;: 开始生产产品……&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//消费者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;: 开始消费产品……&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK5-0新增线程创建方式"><a href="#JDK5-0新增线程创建方式" class="headerlink" title="JDK5.0新增线程创建方式"></a>JDK5.0新增线程创建方式</h2><h3 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h3><p><strong>步骤：</strong></p><ol><li>创建一个Callable接口的实现类；</li><li>重写call()方法，将此线程需要执行的操作声明在call()方法中;</li><li>创建Callable接口实现类的对象;</li><li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask类的对象;</li><li>将FutureTask类的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法;</li><li>获取Callable中call()方法的返回值。（如果需要）</li></ol><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li>call()可以有返回值。</li><li>call()可以抛出异常，被外面的操作捕获，获取异常信息。</li><li>Callable支持泛型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._06newway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的实现方式三：实现Callable接口    --- JDK 5.0新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例子：遍历100以内的偶数，并返回偶数和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-25 20:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1、创建一个Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2、重写call()方法，将此线程需要执行的操作声明在call()方法中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4、将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask类的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5、将FutureTask类的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6、获取Callable中call()方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增方式二：使用线程池"><a href="#新增方式二：使用线程池" class="headerlink" title="新增方式二：使用线程池"></a>新增方式二：使用线程池</h2><ol><li><p><strong>背景：</strong>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p></li><li><p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。</p></li><li><p><strong>好处：</strong></p><ul><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</p></li><li><p>便于线程管理：</p><p>① corePoolSize：核心池的大小</p><p>② maximumPoolSize：最大线程数</p><p>③ keepAliveTime：线程没有任务时最多保持多长时间后会终止</p></li></ul></li><li><p><strong>线程池相关API：</strong></p></li></ol><ul><li><p>JDK 5.0起提供了线程池相关的API：ExecutorService和Excutors。</p></li><li><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor。</p><p>① void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable；</p><p>② <T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable；</p><p>③ void shutdown()：关闭连接池。</p></li><li><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</p><p>① Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池；</p><p>② Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池；</p><p>③ Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池；</p><p>④ Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期运行。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._06newway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式四：使用线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？    4种</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-29 16:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">        System.out.println(service.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适用于Callable</span></span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点问答"><a href="#知识点问答" class="headerlink" title="知识点问答"></a>知识点问答</h2><h3 id="sleep-和wait-的区别。"><a href="#sleep-和wait-的区别。" class="headerlink" title="sleep()和wait()的区别。"></a>sleep()和wait()的区别。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()；</span><br><span class="line">调用的范要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中；</span><br><span class="line">关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，而wait()会。</span><br></pre></td></tr></table></figure><h3 id="创建多线程有哪几种方式？"><a href="#创建多线程有哪几种方式？" class="headerlink" title="创建多线程有哪几种方式？"></a>创建多线程有哪几种方式？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类</span><br><span class="line">实现Runnable接口</span><br><span class="line">实现Callable接口</span><br><span class="line">线程池：提高响应速度，提高了资源的重用率，便于管理</span><br></pre></td></tr></table></figure><h3 id="Java中有几种方法可以实现一个线程-jdk5-0之前-？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？"><a href="#Java中有几种方法可以实现一个线程-jdk5-0之前-？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？" class="headerlink" title="Java中有几种方法可以实现一个线程(jdk5.0之前)？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？"></a>Java中有几种方法可以实现一个线程(jdk5.0之前)？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：有两种实现方法，分别是继承Thread类与实现Runnable接口，使用<span class="keyword">synchronized</span>关键字修饰同步方法。</span><br><span class="line">反对使用stop()方法，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们，结果很难检查出真正的问题所在。</span><br><span class="line">反对使用suspend()方法，是因为它容易发生死锁。调用suspend()方法的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定，此时，其他任何线程都不能访问锁定的资源，就会造成死锁。所以不应该使用suspend()，而应该在自己的Thread类中置入一个标志，指出线程应该活动还是挂起，便用wait()命令其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</span><br></pre></td></tr></table></figure><h3 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：如果数据将在线程间共享，例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</span><br><span class="line">当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法返回时，就应该使用异步编程，在很多情况下采用异步编程往往更有效率。</span><br></pre></td></tr></table></figure><h3 id="启动一个线程是用run-还是start-？"><a href="#启动一个线程是用run-还是start-？" class="headerlink" title="启动一个线程是用run()还是start()？"></a>启动一个线程是用run()还是start()？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：启动一个线程是调用start()方法，使线程所代表的的虚拟机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法就是正常的对象调用方法的执行，并不是使用分线程来执行的。</span><br></pre></td></tr></table></figure><h3 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：不能，一个对象的<span class="keyword">synchronized</span>方法只能由一个线程访问。</span><br></pre></td></tr></table></figure><h3 id="请说出你所知道的线程同步的方法。"><a href="#请说出你所知道的线程同步的方法。" class="headerlink" title="请说出你所知道的线程同步的方法。"></a>请说出你所知道的线程同步的方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait()：使一个线程处于等待状态，并释放所有对象的lock。</span><br><span class="line"></span><br><span class="line">②sleep()：使一个正在运行的线程处于睡眠状，是一个静态方法，调用此方法要捕捉InterruptedException异常。</span><br><span class="line"></span><br><span class="line">③notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候并不能确切地唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</span><br><span class="line"></span><br><span class="line">④notifyAll()：唤醒所有处于等待状态的线程，注意并不是给所有线程一个对象的锁，而是让它们竞争。</span><br></pre></td></tr></table></figure><h3 id="多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？"><a href="#多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？" class="headerlink" title="多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？"></a>多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：实现方法有两种，分别是继承Thread类与实现Runnable接口；同步的实现方面有两种，分别是<span class="keyword">synchronized</span>与wait-notify。</span><br></pre></td></tr></table></figure><h3 id="简述synchronized和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized和java.util.concurrent.locks.Lock的异同？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相同点：Lock能完成<span class="keyword">synchronized</span>所实现的所有功能。</span><br><span class="line"></span><br><span class="line">不同点：Lock有比<span class="keyword">synchronized</span>更精准的线程语义和性能。<span class="keyword">synchronized</span>会自动释放锁，而Lock一定要求程序员手动释放，并且必须在<span class="keyword">finally</span>语句中释放。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念：程序、进程、线程&quot;&gt;&lt;a href=&quot;#基本概念：程序、进程、线程&quot; class=&quot;headerlink&quot; title=&quot;基本概念：程序、进程、线程&quot;&gt;&lt;/a&gt;基本概念：程序、进程、线程&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>第六章 面向对象（下）</title>
    <link href="https://asteroidcs.github.io/undefined/d5b3.html"/>
    <id>https://asteroidcs.github.io/undefined/d5b3.html</id>
    <published>2020-12-11T16:00:00.000Z</published>
    <updated>2020-12-12T02:33:15.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字：static"><a href="#关键字：static" class="headerlink" title="关键字：static"></a>关键字：static</h2><h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><ol><li><p>static：静态的。</p></li><li><p>可以用来修饰：属性、方法、代码块、内部类。</p></li><li><p>==使用static来修饰属性:静态变量==</p><p>属性：按是否使用是static修饰，又分为静态属性和非静态属性（实例变量）</p><ul><li>==实例变量==：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样属性值的修改。</li><li>==静态变量==：我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用次静态变量时，是修改过的。</li></ul><p>static修饰属性的其他说明：</p><ul><li>静态变量随着类的加载而加载，可以通过“类.静态变量”的方式调用；</li><li>静态变量的加载要早于对象的创建；</li><li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ul></li><li><p>==使用static来修饰方法：静态方法==</p><ul><li>随着类的加载而加载，可以通过“类.静态方法”的方式进行调用;</li><li>静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用静态的方法或属性，也可以调用非静态的方法或属性。</li></ul></li><li><p>static注意点：</p><ul><li>在静态方法内不能使用this关键字和super关键字;</li><li>关于静态属性和静态方法的使用，都从生命周期的角度去解释。</li></ul></li><li><p>开发中，如何确定一个属性是否要声明为static的？</p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static。</li></ul></li><li><p>开发中，如何确定一个方法是否要声明为static的？</p><ul><li>操作静态属性的方法,通常设置为static的；</li><li>工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections。</li></ul></li></ol><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._01static;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static关键字的使用：代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chinese.nation = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        Chinese c1 = <span class="keyword">new</span> Chinese();</span><br><span class="line">        System.out.println(<span class="string">&quot;通过“类.静态变量”的方式赋值的静态变量：&quot;</span> + c1.nation);</span><br><span class="line">        c1.name = <span class="string">&quot;姚明&quot;</span>;</span><br><span class="line">        c1.age = <span class="number">40</span>;</span><br><span class="line">        c1.nation = <span class="string">&quot;CHN&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        Chinese c2 = <span class="keyword">new</span> Chinese();</span><br><span class="line">        c2.name = <span class="string">&quot;马龙&quot;</span>;</span><br><span class="line">        c2.age = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(c1.nation + <span class="string">&quot;  \t&quot;</span> +c2.nation );<span class="comment">//CHN      CHN</span></span><br><span class="line">        c2.nation = <span class="string">&quot;CHINA&quot;</span>;</span><br><span class="line">        System.out.println(c1.nation + <span class="string">&quot;\t&quot;</span> +c2.nation);<span class="comment">//CHINA    CHINA</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        Chinese.name = &quot;张继科&quot;;//编译不通过，不能使用类去调用非静态属性</span></span><br><span class="line">        </span><br><span class="line">        c1.eat();</span><br><span class="line">        Chinese.show();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        Chinese.eat();//编译不通过，不能使用类去调用非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String nation;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中国人吃中餐&quot;</span>);</span><br><span class="line">        <span class="comment">//调用非静态结构</span></span><br><span class="line">        <span class="keyword">this</span>.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">        <span class="comment">//调用静态结构</span></span><br><span class="line">        walk();</span><br><span class="line">        System.out.println(<span class="string">&quot;nation: &quot;</span> + Chinese.nation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个中国人！&quot;</span>);</span><br><span class="line"><span class="comment">//        eat();//静态方法中，只能调用静态的方法或属性</span></span><br><span class="line"><span class="comment">//        name = &quot;Triabin&quot;</span></span><br><span class="line">        System.out.println(Chinese.nation);<span class="comment">//可以调用静态的属性或方法，属性前可以省略了“类名.”（Chinese.）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;,age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200819203408.png" alt="img"></p><h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        Circle c2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        Circle c3 = <span class="keyword">new</span> Circle(<span class="number">3.4</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;c1的id：&quot;</span> + c1.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2的id：&quot;</span> + c2.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;c3的id：&quot;</span> + c3.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;创建圆的个数为：&quot;</span> + Circle.getTotal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;<span class="comment">//记录创建圆的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> init = <span class="number">1001</span>;<span class="comment">//static声明的属性被所有对象所共享</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = init++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200819203554.png" alt="img"></p><h3 id="单例（Singleton）设计模式"><a href="#单例（Singleton）设计模式" class="headerlink" title="单例（Singleton）设计模式"></a>单例（Singleton）设计模式</h3><ol><li><p><strong>设计模式</strong>是在$\color{red}{大量的实践中总结和理论化之后优选的代码结构、编程风格、 以及解决问题的思考方式。}$设计模免去我们自己再思考和摸索。就像是经典 的棋谱，不同的棋局，我们用不同的棋谱。”套路”</p></li><li><p>设计模式：</p><ul><li>创建型模式，共5种：工厂方法模式、抽象工厂模式、$\color{red}{单例模式}$、创造者模式、原型模式；</li><li>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式；</li><li>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><p><strong>PS：</strong>设计模式是独立于语言之外的，就像数据结构与算法。</p></li><li><p>单例设计模式只是上述设计模式中的一种。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。 如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p></li><li><p>$\color{red}{如何实现？}$</p><ul><li>饿汉式实现<ul><li>坏处：直接加载对象，对象加载时间过长；</li><li>好处：饿汉式是线程安全的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(bank1 == bank2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 内部创建类的对象</span></span><br><span class="line">    <span class="comment">//4. 此对象必须声明为static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 提供公共的静态的方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式实现<ul><li>好处：到需要时才加载对象，延迟对象的创建；</li><li>目前写法坏处：线程不安全。—&gt; 到多线程内容时再修改</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(order1 == order2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 声明当前类对象没有初始化</span></span><br><span class="line">    <span class="comment">//4. 此对象也必须声明为static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 声明public、static的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单例模式的优点：由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p></li><li><p>$\color{gold}{单例设计模式应用场景}$</p><ul><li>$\color{blue}{网站的计数器}$，一般也是单例模式实现，否则难以同步。</li><li>$\color{blue}{应用程序的日志应用}$，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li><li>$\color{blue}{数据库连接池)$的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li><li>项目中，$\color{blue}{读取配置文件的类}$，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li><li>$\color{blue}{Application也是单例的典型应用}$。</li><li>Windows的$\color{blue}{Task Manager(任务管理器)}$就是很典型的单例模式。</li><li>Windows的$\color{blue}{Recycle Bin (回收站)}$也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li></ul></li></ol><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>编写一个类实现银行账户的概念，包含的属性有“账号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。账号要自动生成。</p><p>编写主类，使用银行账户类，输入、输出3个储户的上述信息。</p><p>考虑：哪些属性可以设计成static属性。</p><ul><li>Account类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._01exercise1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后练习题1：Account类</span></span><br><span class="line"><span class="comment"> * 编写一个类实现银行账户的概念，包含的属性有“账号”、“密码”、“存款余额”、“利率”、</span></span><br><span class="line"><span class="comment"> * “最小余额”，定义封装这些属性的方法。账号要自动生成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String pwd = <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> minBalance = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> iterId = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = iterId++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String pwd,<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getInterestRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interestRate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInterestRate</span><span class="params">(<span class="keyword">double</span> interestRate)</span> </span>&#123;</span><br><span class="line">        Account.interestRate = interestRate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMinBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minBalance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMinBalance</span><span class="params">(<span class="keyword">double</span> minBalance)</span> </span>&#123;</span><br><span class="line">        Account.minBalance = minBalance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account [id=&quot;</span> + id + <span class="string">&quot;, pwd=&quot;</span> + pwd + <span class="string">&quot;, balance=&quot;</span> + balance + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主类Bank</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._01exercise1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后练习题1主类：Bank、</span></span><br><span class="line"><span class="comment"> * 编写主类，使用银行账户类，输入、输出3个储户的上述信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account a1 = <span class="keyword">new</span> Account();</span><br><span class="line">        a1.setBalance(<span class="number">201314</span>);</span><br><span class="line">        Account a2 = <span class="keyword">new</span> Account(<span class="string">&quot;quqian&quot;</span>,<span class="number">2000</span>);</span><br><span class="line">        Account a3 = <span class="keyword">new</span> Account(<span class="string">&quot;123455&quot;</span>,<span class="number">1314</span>);</span><br><span class="line">        Account.setInterestRate(<span class="number">3.5</span>);</span><br><span class="line">        Account.setMinBalance(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        System.out.println(a2);</span><br><span class="line">        System.out.println(a3);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小余额 = &quot;</span> + Account.getMinBalance());</span><br><span class="line">        System.out.println(<span class="string">&quot;账户数量 = &quot;</span> + Account.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;利率 = &quot;</span> + Account.getInterestRate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200819214034.png" alt="img"></p></li></ol><h2 id="理解main方法的语法"><a href="#理解main方法的语法" class="headerlink" title="理解main方法的语法"></a>理解main方法的语法</h2><h3 id="main-方法的使用说明"><a href="#main-方法的使用说明" class="headerlink" title="main()方法的使用说明"></a>main()方法的使用说明</h3><ol><li>main()作为程序的入口。</li><li>main()方法也是一个普通的静态方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._02main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main.main(<span class="keyword">new</span> String[<span class="number">100</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++) &#123;</span><br><span class="line">            args[i] = <span class="string">&quot;args_&quot;</span> + i;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行时会询问将哪一个main()方法作为程序入口</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200820100255.png" alt="img" style="zoom:80%;" /><ol start="3"><li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._02main;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main()方法与控制台交互示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainInteract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;String型：&quot;</span> + args[i]);</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(args[i]);</span><br><span class="line">            System.out.println(<span class="string">&quot;int型：&quot;</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之四：代码块"><a href="#类的成员之四：代码块" class="headerlink" title="类的成员之四：代码块"></a>类的成员之四：代码块</h2><h3 id="基本概念和作用"><a href="#基本概念和作用" class="headerlink" title="基本概念和作用"></a>基本概念和作用</h3><ol><li><p>代码块的作用：用来初始化类、对象。</p></li><li><p>代码块如果有修饰，只能是static。</p></li><li><p>分类：静态代码块、非静态代码块。</p></li><li><p>静态代码块：</p><ul><li>内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次</li><li><strong>作用：初始化类信息</strong></li><li>如果一个类中定义了多个代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行优于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul></li><li><p>非静态代码块：</p><ul><li>内部可以有输出语句</li><li>随着对象的创建而执行</li><li>每创建一个对象，就执行一次非静态代码块</li><li><strong>作用：可以在创建对象时，对对象的属性进行初始化</strong></li><li>非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法</li></ul></li><li><p>代码示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._03codeblock;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的成员之四：代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 代码块的作用：用来初始化类、对象。</span></span><br><span class="line"><span class="comment"> * 2. 代码块如果有修饰，只能是static。</span></span><br><span class="line"><span class="comment"> * 3. 分类：静态代码块、非静态代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. 静态代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5. 非静态代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String descr = Person.descr;</span><br><span class="line">        System.out.println(descr);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p1.age);</span><br><span class="line">        Person.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String descr = <span class="string">&quot;我是一个人&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="comment">//static代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,static block_1!&quot;</span>);</span><br><span class="line">        <span class="comment">//调用静态结构</span></span><br><span class="line">        descr = <span class="string">&quot;我是一个爱学习的人1&quot;</span>;</span><br><span class="line">        info();</span><br><span class="line"><span class="comment">//        eat();</span></span><br><span class="line"><span class="comment">//        name = &quot;Triabin&quot;;//不能调用非静态结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,static block_2!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非static代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,block!&quot;</span>);</span><br><span class="line">        <span class="comment">//调用非静态结构</span></span><br><span class="line">        age = <span class="number">1</span>;</span><br><span class="line">        eat();</span><br><span class="line">        <span class="comment">//调用静态结构</span></span><br><span class="line">        descr = <span class="string">&quot;我是一个爱学习的人&quot;</span>;</span><br><span class="line">        info();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个快乐的人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用举例-1"><a href="#应用举例-1" class="headerlink" title="应用举例"></a>应用举例</h3><ol><li>先父后子，静态先行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> top.triabin._03codeblock;</span><br><span class="line">   <span class="comment">//总结：先父后子，静态先行</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">           <span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">           <span class="keyword">this</span>();</span><br><span class="line">           System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">               + msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">       &#125;    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">           <span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Leaf(); </span><br><span class="line">           System.out.println();</span><br><span class="line">           <span class="keyword">new</span> Leaf();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>对属性可以赋值的位置总结：</p><ul><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>有了对象以后，可以通过“对象.属性”或“对象.方法”的方式，进行赋值</li><li>在代码块中赋值</li></ul><p>执行的先后顺序：① - ② / ⑤ - ③ - ④，②和⑤谁写在前面就先执行谁。</p></li></ol><h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><h3 id="基本概念和使用"><a href="#基本概念和使用" class="headerlink" title="基本概念和使用"></a>基本概念和使用</h3><ol><li>final可以用来修饰的结构：类、方法、变量</li><li>$\color{gold}{final用来修饰一个类}$：此类不能被其他类继承。<ul><li>比如：String类、System类、StringBuffer类</li></ul></li><li>$\color{gold}{final用来修饰方法}$：表明此方法不可以被重写。<ul><li>比如：Object类中的getClass()</li></ul></li><li>$\color{gold}{final用来修饰变量}$：此时的”变量“就称为是一个常量<ul><li>final修饰属性：可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不能重新赋值。</li></ul></li><li>static final用来修饰属性：全局常量</li><li>static final用来修饰方法：不可重写的静态方法</li></ol><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li>面试题：排错</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;<span class="comment">//错误</span></span><br><span class="line">        <span class="comment">//return x + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Other o = <span class="keyword">new</span> Other();</span><br><span class="line">        <span class="keyword">new</span> Something().addOne(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span></span>&#123;</span><br><span class="line">        <span class="comment">//o = new Other();//错误</span></span><br><span class="line">        o.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>随着继承层次的中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫抽象类。</li></ul><h3 id="abstract关键字的使用"><a href="#abstract关键字的使用" class="headerlink" title="abstract关键字的使用"></a>abstract关键字的使用</h3><ol><li><p>abstract可以用来修饰：类、方法。</p></li><li><p>abstract修饰类：抽象类</p><ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作</li></ul></li><li><p>abstract修饰方法：抽象方法</p><ul><li><p>抽象方法只有方法的声明，没有方法体</p></li><li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。</p></li><li><p>若子类重写了父类中所有抽象方法后，此子类可实例化</p><p>若子类没有重写父类中所有抽象方法，则次子类也是一个抽象类，需要使用abstract修饰</p></li></ul></li><li><p>abstract使用上的注意点：</p><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法、final的方法</li></ul></li><li><p>代码示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05abstract;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * abstract关键字的使用：</span></span><br><span class="line"><span class="comment"> * 1. abstract：抽象的</span></span><br><span class="line"><span class="comment"> * 2. abstract可以用来修饰：类、方法</span></span><br><span class="line"><span class="comment"> * 3. abstract修饰类：抽象类</span></span><br><span class="line"><span class="comment"> * 4. abstract修饰方法：抽象方法</span></span><br><span class="line"><span class="comment"> * 5. abstract使用上的注意点：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一旦Person类抽象了，就不可实例化</span></span><br><span class="line"><span class="comment">//        Person p1 = new Person();//Cannot instantiate the type Person</span></span><br><span class="line"><span class="comment">//        p1.eat();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不是抽象方法</span></span><br><span class="line"><span class="comment">//    public void eat() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//必须重写父类中所有的抽象方法，否则子类无法实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类的匿名子类"><a href="#抽象类的匿名子类" class="headerlink" title="抽象类的匿名子类"></a>抽象类的匿名子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Person为抽象类、Person的eat()和breath()为抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//创建匿名子类的对象：p</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    method(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建匿名子类的匿名对象</span></span><br><span class="line">method(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="多态的应用：模板方法设计模式（TemplateMethod）"><a href="#多态的应用：模板方法设计模式（TemplateMethod）" class="headerlink" title="多态的应用：模板方法设计模式（TemplateMethod）"></a>多态的应用：模板方法设计模式（TemplateMethod）</h3><ol><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</li><li>解决的问题：<ul><li>当功能内部的一部分实现是确定的，一部分实现是不确定的。这时可以吧不确定的部分暴露出去，让子类去实现。</li><li>换句话说，在软件开发在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li></ul></li><li>举例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Template t = <span class="keyword">new</span> SubTemlate();</span><br><span class="line">        t.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Dawn Lee</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@data</span> 2020-8-2416:07:07</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code();<span class="comment">//不确定的部分，易变的部分</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (start - end));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemlate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：<ul><li>数据库访问的封装</li><li>Junit单元测试</li><li>JavaWeb的Servlet中关于doGet/doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中JDBCTemlate、HibernateTemplate等</li></ul></li></ol><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>编写一个Employee类，声明为抽象类，包含如下三个属性：</p><p>name，id，salary。</p><p>提供必要的构造器和抽象方法：work()。</p><p>对于Manager类来说，他既是员工，还具有奖金（bonus）的属性。请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 编写一个Employee类，声明为抽象类，包含如下三个属性：</span></span><br><span class="line"><span class="comment"> * name，id，salary。</span></span><br><span class="line"><span class="comment"> * 提供必要的构造器和抽象方法：work()。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-24    9:59:51</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//工号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;<span class="comment">//薪资</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于Manager类来说，他既是员工，还具有奖金（bonus）的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;<span class="comment">//奖金</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name,<span class="keyword">int</span> id,<span class="keyword">double</span> salary,<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,id,salary);</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBonus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员工，提高公司的运行效率&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05exercise1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEmployee</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工在一线车间生产产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin._05exercise1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee manager = <span class="keyword">new</span> Manager(<span class="string">&quot;库克&quot;</span>,<span class="number">1001</span>,<span class="number">5000</span>,<span class="number">50000</span>);</span><br><span class="line">        manager.work();</span><br><span class="line">        </span><br><span class="line">        CommonEmployee commonEmployee = <span class="keyword">new</span> CommonEmployee();</span><br><span class="line">        commonEmployee.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li><li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</li><li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</li><li>接口的本质是契约，标准，规范，就像法律一样。指定好后大家都要遵守。</li><li>举例</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201212100310946.png" alt="image-20201212100310946" style="zoom: 33%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201212100331272.png" alt="image-20201212100331272" style="zoom:33%;" /><h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ol><li><p>使用interface来定义。</p></li><li><p>在Java语言中，接口和类是并列的两个结构。</p></li><li><p>如何定义接口：定义接口中的成员</p><p>① JDK7以前：只能定义全局常量和抽象方法</p><ul><li>全局常量：public static final的，但是书写时可以省略不写</li><li>抽象方法：public abstract的</li></ul><p>② JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。（暂略）</p></li><li><p>接口中不能定义构造器，意味着接口不可以实例化。</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用。</p><p>如果实现类覆盖了接口中所有抽象方法，则次实现类可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。</p></li><li><p>Java类可以实现说个接口 —&gt; 弥补了Java单继承性的局限性。</p><p>格式：class AA extends BB implements CC,DD,EE,…{} 先写继承，后写实现。</p></li><li><p>接口与接口之间可以继承，而且可以多继承。</p></li><li><p>接口的具体使用体现多态性。</p></li><li><p>接口实际上可以看做是一种规范。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Flyable.MAX_SPEED);</span><br><span class="line">        System.out.println(Flyable.MIN_SPEED);</span><br><span class="line"><span class="comment">//        Flyable.MIN_SPEED = 2;//The final field Flyable.MIN_SPEED cannot be assigned</span></span><br><span class="line">        </span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane();</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>;<span class="comment">//第一宇宙速度</span></span><br><span class="line">    <span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>;<span class="comment">//省略了public static final</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//省略了public abstract</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public Flyable() &#123;</span></span><br><span class="line"><span class="comment">//        //Interfaces cannot have constructors</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过引擎起飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶员减速停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Kite</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Flyable</span>,<span class="title">Attackable</span>,<span class="title">CC</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">AA</span>,<span class="title">BB</span></span>&#123;</span><br><span class="line">    <span class="comment">//多继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题：抽象类与接口有哪些异同？"><a href="#面试题：抽象类与接口有哪些异同？" class="headerlink" title="面试题：抽象类与接口有哪些异同？"></a>面试题：抽象类与接口有哪些异同？</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201212100902772.png" alt="image-20201212100902772" style="zoom: 50%;" /><h3 id="应用举例-2"><a href="#应用举例-2" class="headerlink" title="应用举例"></a>应用举例</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201212100601340.png" alt="image-20201212100601340" style="zoom:33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> * 1. 接口使用上也满足多态。</span></span><br><span class="line"><span class="comment"> * 2. 接口，实际上就是定义了一种多态。</span></span><br><span class="line"><span class="comment"> * 3. 开发中，体会面向接口编程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        <span class="comment">//1. 创建了接口的非匿名实现类的非匿名对象</span></span><br><span class="line">        Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">        computer.transferData(flash);</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//2. 创建了接口的非匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> Printer());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//3. 创建了接口的匿名实现类的非匿名对象</span></span><br><span class="line">        USB phone = <span class="keyword">new</span> USB() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机结束工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        computer.transferData(phone);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 创建了接口的匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> USB() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;mp3开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;mp3结束工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span> </span>&#123;<span class="comment">//USB usb = new Flash(); 接口的多态性</span></span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="comment">//常量：定义了长、宽、最大最小的传输速率等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><ol><li>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201212100701753.png" alt="image-20201212100701753" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的应用：代理模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetWork work;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.work = work;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;联网之前的一些检查工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        work.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>应用场景：</p><ul><li>安全代理：屏蔽对真实角色的直接访问。</li><li>远程代理：通过代理类处理远程方法调用（RMI）。</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</li></ul></li><li><p>分类：</p><ul><li><p>静态代理（静态定义代理类）</p></li><li><p>动态代理</p><p>（动态生成代理类）</p><ul><li>JDK自动的动态代理，需要反射等知识</li></ul></li></ul></li></ol><h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><h3 id="Java8中关于接口的改进"><a href="#Java8中关于接口的改进" class="headerlink" title="Java8中关于接口的改进"></a>Java8中关于接口的改进</h3><ol><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。</li><li>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</li><li><strong>静态方法：</strong>使用static关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。</li><li><strong>默认方法：</strong>默认方法使用default关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA：北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;<span class="comment">//public可省略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;<span class="comment">//public可省略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CompareB：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass：北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="comment">//        s.method1();</span></span><br><span class="line">        <span class="comment">//知识点1：接口中定义的静态方法只能通过接口来调用。</span></span><br><span class="line">        CompareA.method1();</span><br><span class="line">        <span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法</span></span><br><span class="line">        <span class="comment">//实现类可以重写接口中的默认方法</span></span><br><span class="line">        s.method2();</span><br><span class="line">        <span class="comment">//知识点3：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么</span></span><br><span class="line">        <span class="comment">//子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法。(类优先原则)</span></span><br><span class="line">        <span class="comment">//知识点4：如果子类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现</span></span><br><span class="line">        <span class="comment">//类没有重写此方法的情况下，报错。(接口冲突)</span></span><br><span class="line">        <span class="comment">//这就需要我们在实现类中重写此方法</span></span><br><span class="line">        s.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span>,<span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass：深圳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//知识点5：如何在子类（或实现类）的方法中调用父类、接口中被重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method3();<span class="comment">//自己定义的重写方法</span></span><br><span class="line">        <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">        <span class="comment">//调用接口中默认的方法</span></span><br><span class="line">        CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">        CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h2><ol><li><p>ava中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p></li><li><p>内部类的分类：成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）。</p></li><li><p>成员内部类：</p><p>一方面，作为外部类的成员：</p><ul><li>调用外部类的结构</li><li>可以被static修饰</li><li>可以被4种不同的权限修饰</li></ul><p>另一方面，作为一个类：</p><ul><li>类内可以定义属性、方法、构造器等</li><li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract修饰</li></ul></li><li><p>关注如下3个问题：</p><p>① 如何实例化成员内部类</p><p>② 如何在成员内部类中区分调用外部类的结构</p><p>③ 开发中局部内部类的使用 见《InnerClassTest1.java》</p></li><li><p>使用实例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的内部成员之五：内部类 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Dog实例（静态的成员内部类）：</span></span><br><span class="line">        Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line">        <span class="comment">//创建Bird实例（非静态的成员内部类）：</span></span><br><span class="line"><span class="comment">//        Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">        bird.sing();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        bird.display(<span class="string">&quot;形参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        <span class="comment">//静态成员内部类</span></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;卡拉是条狗&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">        <span class="comment">//非静态成员内部类</span></span><br><span class="line">        String name = <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line">            Person.<span class="keyword">this</span>.eat();<span class="comment">//调用外部类的非静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">            <span class="comment">//局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类(代码块内)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">            <span class="comment">//局部内部类(构造器内)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开发中很少见</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关键字：static&quot;&gt;&lt;a href=&quot;#关键字：static&quot; class=&quot;headerlink&quot; title=&quot;关键字：static&quot;&gt;&lt;/a&gt;关键字：static&lt;/h2&gt;&lt;h3 id=&quot;static关键字的使用&quot;&gt;&lt;a href=&quot;#static关键字</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十四章 网络编程</title>
    <link href="https://asteroidcs.github.io/undefined/ce7e.html"/>
    <id>https://asteroidcs.github.io/undefined/ce7e.html</id>
    <published>2020-11-30T04:25:18.289Z</published>
    <updated>2020-12-10T13:18:44.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>​    把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。</p><h4 id="网络编程的目的"><a href="#网络编程的目的" class="headerlink" title="网络编程的目的"></a>网络编程的目的</h4><p>​    直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</p><h4 id="网络编程中有两个主要的问题"><a href="#网络编程中有两个主要的问题" class="headerlink" title="网络编程中有两个主要的问题"></a>网络编程中有两个主要的问题</h4><ol><li>如何准确地定位网络上一台或多台主机;定位主机上的特定的应用</li><li>找到主机后如何可靠高效地进行数据传输</li></ol><h3 id="网络通信要素概述"><a href="#网络通信要素概述" class="headerlink" title="网络通信要素概述"></a>网络通信要素概述</h3><h4 id="如何实现网络中的主机互相通信"><a href="#如何实现网络中的主机互相通信" class="headerlink" title="如何实现网络中的主机互相通信"></a>如何实现网络中的主机互相通信</h4><ol><li>通信双方地址<ul><li>IP</li><li>端口号</li></ul></li><li>一定的规则(即:网络通信协议。有两套参考模型)<ul><li>OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广</li><li>==TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。==</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130123705011.png" alt="image-20201130123705011" style="zoom:50%;" /><ol start="3"><li>数据传输视图</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130124223380.png" alt="image-20201130124223380" style="zoom:50%;" /><h3 id="通信要素1-IP和端口号"><a href="#通信要素1-IP和端口号" class="headerlink" title="==通信要素1: IP和端口号=="></a>==通信要素1: IP和端口号==</h3><h4 id="IP-地址-InetAddress"><a href="#IP-地址-InetAddress" class="headerlink" title="IP 地址:InetAddress"></a>IP 地址:InetAddress</h4><ol><li>唯一的标识 Internet 上的计算机(通信实体)</li><li>本地回环地址(hostAddress):127.0.0.1 主机名(hostName):localhost</li><li>IP地址分类方式1:IPV4 和 IPV6<ul><li>PV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1</li><li>IPV6:128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li></ul></li><li>IP地址分类方式2:==公网地址(万维网使用)==和==私有地址(局域网使用)==。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</li><li>特点:不易记忆</li></ol><h4 id="端口号-：标识正在计算机上运行的进程-程序"><a href="#端口号-：标识正在计算机上运行的进程-程序" class="headerlink" title="==端口号==：标识正在计算机上运行的进程(程序)"></a>==端口号==：标识正在计算机上运行的进程(程序)</h4><ol><li>==不同的进程有不同的端口号==</li><li>被规定为一个 16 位的整数 0~65535</li><li>端口分类:<ul><li>公认端口:0~1023。被预先定义的服务通信占用(如:HTTP占用端口 80，FTP占用端口21，Telnet占用端口23)</li><li>注册端口:1024~49151。分配给用户进程或应用程序。(如:Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等)</li><li>动态/私有端口:49152~65535</li></ul></li></ol><h4 id="端口号与IP地址的组合得出一个网络套接字：Socket。"><a href="#端口号与IP地址的组合得出一个网络套接字：Socket。" class="headerlink" title="==端口号与IP地址的组合得出一个网络套接字：Socket。=="></a>==端口号与IP地址的组合得出一个网络套接字：Socket。==</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130125026273.png" alt="image-20201130125026273" style="zoom:50%;" /><h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><ol><li>Internet上的主机有两种方式表示地址:<ul><li>域名(hostName): <a href="http://www.atguigu.com/">www.atguigu.com</a></li><li>P 地址(hostAddress): 202.108.35.210</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternetAddressTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br><span class="line">            System.out.println(address);  <span class="comment">// www.atguigu.com/58.215.145.106</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>InetAddress类主要表示IP地址，两个子类:Inet4Address、Inet6Address</li><li>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: <a href="http://www.atguigu.com/">www.atguigu.com</a> 和 202.108.35.210</li><li>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS) 负责将域名转化成IP地址，这样才能和主机建立连接。———==域名解析==</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130125809486.png" alt="image-20201130125809486" style="zoom: 50%;" /><ol start="4"><li>InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例<ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByName(String host)</li></ul></li><li>InetAddress提供了如下几个常用的方法<ul><li>public String getHostAddress(): 返回 IP 地址字符串(以文本表现形式)</li><li>public String getHostName(): 获取此 IP 地址的主机名</li><li>public boolean isReachable(int timeout): 测试是否可以达到该地址</li></ul></li></ol><h3 id="通信要素2：网络协议"><a href="#通信要素2：网络协议" class="headerlink" title="==通信要素2：网络协议=="></a>==通信要素2：网络协议==</h3><ol><li><p>网络通信协议</p><p>​    计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代 码结构、传输控制步骤、出错控制等制定标准。</p></li><li><p>问题:网络协议太复杂</p><p>​    计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩，解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢?</p></li><li><p>通信协议分层的思想</p><p>​    在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</p></li></ol><h4 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP/IP协议簇"></a>TCP/IP协议簇</h4><ol><li><p>传输层协议中有两个非常重要的协议:</p><ul><li>传输控制协议TCP(Transmission Control Protocol)</li><li>用户数据报协议UDP(User Datagram Protocol)</li></ul></li><li><p>==TCP/IP 以其两个主要协议==：==传输控制协议(TCP)==和==网络互联协议(IP)==而得 名，实际上是一组协议，包括多个具有不同功能且互为关联的协议</p></li><li><p>==IP(Internet Protocol)协议==是网络层的主要协议，支持网间互连的数据通信</p></li><li><p>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理链路层==、==IP层==、==传输层==和==应用层==。</p></li></ol><h4 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h4><ol><li><p>TCP协议:</p><ul><li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li><li>传输前，采用==“三次握手”==方式，点对点通信，==是可靠的==</li><li>TCP协议进行通信的两个应用进程:客户端、服务端。</li><li>在连接中可==进行大数据量的传输==</li><li>传输完毕，==需释放已建立的连接，效率低==</li></ul></li><li><p>UDP协议:</p><ul><li>将数据、源、目的封装成数据包，==不需要建立连接==</li><li>每个数据报的大小限制在64K内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的  可以广播发送</li><li>发送数据结束时==无需释放资源，开销小，速度快==</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130131804507.png" alt="image-20201130131804507" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130131838776.png" alt="image-20201130131838776" style="zoom:50%;" /><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><ol><li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。</li><li>==网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字==</li><li>通信的两端都要有Socket，是两台机器间通信的端点。 </li><li>网络通信其实就是Socket间的通信。</li><li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。  一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</li><li>Socket分类:<ul><li>流套接字(stream socket):使用TCP提供可依赖的字节流服务 </li><li>数据报套接字(datagram socket):使用UDP提供“尽力而为”的数据报服务</li></ul></li></ol><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><h4 id="基于Socket的TCP编程"><a href="#基于Socket的TCP编程" class="headerlink" title="基于Socket的TCP编程"></a>基于Socket的TCP编程</h4><ol><li>Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模 型如图所示</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140123191.png" alt="image-20201130140123191" style="zoom:50%;" /><ol start="2"><li>==客户端Socket的工作过程包含以下四个基本的步骤:==<ul><li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket 的输入/出流:：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 (但不能读取自己放入线路的信息)，通过输出流将信息写入线程。</li><li>关闭 Socket:：断开客户端到服务器的连接，释放线路</li></ul></li><li>==服务器程序的工作过程包含以下四个基本的步骤:==<ul><li>调用 ServerSocket(int port) :创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept():监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。</li><li>调用 该Socket类对象的 getOutputStream() 和 getInputStream ():获取输出 流和输入流，开始网络数据的发送和接收。</li><li>关闭ServerSocket和Socket对象:客户端访问结束，关闭通信套接字</li></ul></li></ol><h4 id="客户端创建Socket对象"><a href="#客户端创建Socket对象" class="headerlink" title="客户端创建Socket对象"></a>客户端创建Socket对象</h4><ol><li>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是:<ul><li>Socket(String host,int port)throws UnknownHostException,IOException:向服务器(域名是 host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li><li>Socket(InetAddress address,int port)throws IOException:根据InetAddress对象所表示的 IP地址以及端口号port发起连接。</li></ul></li><li>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140600249.png" alt="image-20201130140600249" style="zoom:67%;" /><h4 id="服务器建立-ServerSocket-对象"><a href="#服务器建立-ServerSocket-对象" class="headerlink" title="服务器建立 ServerSocket 对象"></a>服务器建立 ServerSocket 对象</h4><ol><li>erverSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。</li><li>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130140912034.png" alt="image-20201130140912034" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130142653444.png" alt="image-20201130142653444" style="zoom:50%;" /><h4 id="例题1：客户端发送内容给服务端，服务端将内容打印到控制台上"><a href="#例题1：客户端发送内容给服务端，服务端将内容打印到控制台上" class="headerlink" title="例题1：客户端发送内容给服务端，服务端将内容打印到控制台上"></a>例题1：客户端发送内容给服务端，服务端将内容打印到控制台上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 实现TCP的网络编程：客户端发送信息给服务器，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-30 1:38 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(localHost, <span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2：客户端发送文件给服务端，服务端将文件保存在本地"><a href="#例题2：客户端发送文件给服务端，服务端将文件保存在本地" class="headerlink" title="例题2：客户端发送文件给服务端，服务端将文件保存在本地"></a>例题2：客户端发送文件给服务端，服务端将文件保存在本地</h4><p>例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给 客户端。并关闭相应的连接。</p><h4 id="练习1：服务端读取图片并发送给客户端，客户端保存图片到本地"><a href="#练习1：服务端读取图片并发送给客户端，客户端保存图片到本地" class="headerlink" title="练习1：服务端读取图片并发送给客户端，客户端保存图片到本地"></a>练习1：服务端读取图片并发送给客户端，客户端保存图片到本地</h4><h4 id="练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"><a href="#练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端" class="headerlink" title="练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"></a>练习：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端</h4><h3 id="客户端—服务端"><a href="#客户端—服务端" class="headerlink" title="客户端—服务端"></a>客户端—服务端</h3><ol><li>客户端:<ul><li>自定义 </li><li>浏览器</li></ul></li><li>服务端:<ul><li>自定义</li><li>Tomcat服务器</li></ul></li></ol><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><ol><li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</li><li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，==系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达==。</li><li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。</li><li>==UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样==。</li><li>常用方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130150126474.png" alt="image-20201130150126474" style="zoom:50%;" /><h4 id="UDP网络通信"><a href="#UDP网络通信" class="headerlink" title="UDP网络通信"></a>UDP网络通信</h4><ol><li>流程<ul><li>DatagramSocket与DatagramPacket</li><li>建立发送端，接收端</li><li>建立数据包</li><li>调用Socket的发送、接收方法 5. 关闭Socket</li></ul></li><li>发送端与接收端是两个独立的运行程序</li><li>例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-30 2:46 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">        InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, <span class="number">0</span>, data.length, localHost, <span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><ol><li><p>URL(Uniform Resource Locator):统一资源定位符，它表示 Internet 上某一 资源的地址</p></li><li><p>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate 这个资源</p></li><li><p>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。</p></li><li><p>URL的基本结构由5部分组成:</p><p>==&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表==</p><ul><li><p>例如: <a href="http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</a></p></li><li><p>#片段名:即锚点，例如看小说，直接定位到章节</p></li><li><p>参数列表格式:参数名=参数值&amp;参数名=参数值….</p></li></ul></li><li><p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象:</p></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130151447169.png" alt="image-20201130151447169" style="zoom:50%;" /><ol start="6"><li>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。</li><li>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的 方法来获取这些属性:</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201130151611370.png" alt="image-20201130151611370" style="zoom:50%;" /><h4 id="针对HTTP协议的URLConnection类"><a href="#针对HTTP协议的URLConnection类" class="headerlink" title="针对HTTP协议的URLConnection类"></a>针对HTTP协议的URLConnection类</h4><ol><li>==URL的方法 openStream():能从网络上读取数据==</li><li>若希望输出数据，例如向服务器端的 CGI (公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口)程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</li><li>URLConnection:表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException.<ul><li>URL netchinaren = new URL (“<a href="http://www.atguigu.com/index.shtml&quot;">http://www.atguigu.com/index.shtml&quot;</a>); </li><li>URLConnectonn u = netchinaren.openConnection( );</li></ul></li><li>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201130151829726.png" alt="20201130151829726" style="zoom:50%;" /><h3 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="==URI、URL和URN的区别=="></a>==URI、URL和URN的区别==</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net<span class="meta">@java</span>.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。</span><br><span class="line">在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h3><ul><li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li><li>==客户端-服务器==是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。==端口号== 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。==套接字==用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。</li><li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段:主机名(String) 和 IP 地址(int)。</li><li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端-服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。</li><li>类 URL 和 URLConnection 提供了最 高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; title=&quot;网络基础&quot;&gt;&lt;/a&gt;网络基础&lt;/h3&gt;&lt;h4 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十三章 IO流</title>
    <link href="https://asteroidcs.github.io/undefined/4554.html"/>
    <id>https://asteroidcs.github.io/undefined/4554.html</id>
    <published>2020-11-28T12:25:50.563Z</published>
    <updated>2020-12-10T13:18:49.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重点掌握-：节点流、缓冲流、转换流、对象流"><a href="#重点掌握-：节点流、缓冲流、转换流、对象流" class="headerlink" title="==重点掌握==：节点流、缓冲流、转换流、对象流"></a>==重点掌握==：节点流、缓冲流、转换流、对象流</h4><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><p>File类的一个对象，==代表一个文件或一个文件目录==（俗称：文件夹）</p></li><li><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。</p></li><li><p>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是==Java程序中的一个File对象，可能没有一个真实存在的文件或目录==</p></li><li><p>File对象可以作为参数传递给流的构造器</p></li><li><p>==File类不涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流==</p><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点“</p></li></ol><h3 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a><strong>路径分隔符</strong></h3><ul><li><p>路径中的每级目录之间用一个路径分隔符隔开。</p></li><li><p>==路径分隔符和系统有关==：</p><p>①windows和DOS系统默认使用“\”来表示</p><p>②UNIX和URL使用“/”来表示</p></li><li><p>Java程序支持跨平台运行，因此路径分隔符要慎用，为了解决这个隐患，File类提供了一个常量：</p><p>==public static final String separator。根据操作系统，动态的提供分隔符==</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118164027.png" alt="20201118164027" style="zoom:50%;" /><h3 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h3><ol><li>==public File(String pathname)==：以pathname为路径创建对象(绝对路径或相对路径)，==相对路径默认当前路径为系统属性user.dir==。<ul><li>IDEA中：<ul><li>如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下；</li><li>如果使用main()测试，相对路径即为当前的Project下。</li></ul></li><li>Eclipse中：<br>不管是单元测试方法还是main()测试，相对路径都是当前的Project下。</li></ul></li><li>==public File(String parent,String child)==：以parent为父路径，child为子路径创建File对象。</li><li>==public File(File parent,String child)==：根据一个父File对象和子文件路径创建File对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器的使用</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器1：</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior&quot;</span>);</span><br><span class="line">        System.out.println(file1);</span><br><span class="line">        System.out.println(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器2：</span></span><br><span class="line">        File file3 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\workspace_idea1&quot;</span>, <span class="string">&quot;JavaSenior&quot;</span>);</span><br><span class="line">        System.out.println(file1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器3：</span></span><br><span class="line">        File file4 = <span class="keyword">new</span> File(file3, <span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        System.out.println(file4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li><p><strong>File类的获取功能：</strong></p><ul><li>public String getAbsolutePath()：获取绝对路径</li><li>public String getPath()：获取路径</li><li>public String getName() ：获取名称</li><li>public String getParent()：获取上层文件目录路径。若无，返回null</li><li>public long length() ：获取文件长度（即：字节数）。不能获取目录的长度</li><li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;\\Users\\i-mamba\\Desktop\\IO\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file1.getAbsoluteFile()); <span class="comment">// /Users/i-mamba/程序员技能学习/Java/Java基础入门/code/IDEA-workspace/JavaSenior/day08/Hello.txt</span></span><br><span class="line">        System.out.println(file1.getPath()); <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file1.getName()); <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file1.getParent());  <span class="comment">// null</span></span><br><span class="line">        System.out.println(file1.length());  <span class="comment">// 12</span></span><br><span class="line">        System.out.println(file1.lastModified());  <span class="comment">// 1606614159235</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(file1.lastModified()));  <span class="comment">// Sun Nov 29 09:42:39 CST 2020</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>下面两方法适用于文件目录：<ul><li>public String[] list()：获取指定目录下的所有文件或者文件目录的==名称==数组</li><li>public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File路径数组</li></ul></li></ul></li><li><p><strong>File类的重命名功能</strong></p><ul><li><p>public boolean renameTo(File dest)：把文件重命名为指定的文件路径</p><p>比如file1.renameTo(file2)，要保证返回true，==需要file1在硬盘中存在且file2在硬盘中不存在==。修改可包括路径和文件内容。</p></li></ul></li><li><p><strong>File类的判断功能</strong></p><ul><li>public boolean isDirectory()：判断是否是文件目录</li><li>public boolean isFile()：判断是否是文件</li><li>public boolean exists()：判断是否存在</li><li>public boolean canRead()：判断是否可读</li><li>public boolean canWrite()：判断是否可写</li><li>public boolean isHidden()：判断是否隐藏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/i-mamba/程序员技能学习&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file.isDirectory());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isFile());  <span class="comment">// false</span></span><br><span class="line">        System.out.println(file.exists());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.canRead());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.canWrite());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isHidden());  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>File类的创建功能</strong></p><ul><li>public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false</li><li>public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li><li>public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建——&gt; 创建多层文件目录</li></ul><ul><li>==注意事项==：如果你创建文件或者文件目录没有写盘符路径，那么默认在项目路径下。</li></ul></li><li><p><strong>File类的删除功能</strong></p><ul><li>public boolean delete()：删除文件或者文件夹</li><li>删除注意事项：<ul><li>==Java中的删除不走回收站==；</li><li>==要删除一个文件目录，请注意该文件目录内不能包含文件或文件目录==</li></ul></li></ul></li></ol><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 利用File构造器，<span class="keyword">new</span> 一个文件目录file。</span><br><span class="line">   * 在其中创建多个文件和目录</span><br><span class="line">   * 编写方法，实现删除file中指定文件的操作</span><br><span class="line"><span class="number">2.</span> 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称。</span><br><span class="line"><span class="number">3.</span> 遍历指定目录所有文件名称，包括子文件目录中的文件。</span><br><span class="line">   * 拓展<span class="number">1</span>：并计算指定目录占用空间的大小</span><br><span class="line">   * 拓展<span class="number">2</span>：删除指定文件目录及其下的所有文件</span><br></pre></td></tr></table></figure><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><h3 id="Java-IO原理"><a href="#Java-IO原理" class="headerlink" title="Java IO原理"></a>Java IO原理</h3><ol><li>I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</li><li>==Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行的==</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li><li><strong>输入输出：</strong>进入内存即为输入(Input)，出内存即为输出(Output)</li></ol><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ol><li>按操作==数据单位==不同分为：==字节流(8 bit)==，==字符流(16 bit)==。</li><li>按数据流的==流向==不同分为：==输入流==，==输出流==。</li><li>按流的==角色==的不同分为：==节点流==，==处理流==。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118221934.png" alt="20201118221934" style="zoom:50%;" /><table><thead><tr><th align="center">==<strong>(抽象基类)</strong>==</th><th align="center"><strong>字节流</strong></th><th align="center"><strong>字符流</strong></th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><ul><li>Java的IO流共涉及40多个类，实际上非常规则，都是从者4个类派生的，==由这4个类派生出来的子类名称都是以其父类名作为子类名后缀==</li></ul><h4 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a><strong>IO流体系</strong></h4><table><thead><tr><th align="center">分类</th><th align="center">字节输入流</th><th align="center">字节输出流</th><th align="center">字符输入流</th><th align="center">字符输出流</th></tr></thead><tbody><tr><td align="center">==抽象基类==</td><td align="center">InputStream</td><td align="center">OutputStream</td><td align="center">Reader</td><td align="center">Writer</td></tr><tr><td align="center">==访问文件==</td><td align="center">FileInputStream</td><td align="center">FileOutputStream</td><td align="center">FileReader</td><td align="center">FileWriter</td></tr><tr><td align="center">访问数组</td><td align="center">ByteArrayInputStream</td><td align="center">ByteArrayOutputStream</td><td align="center">CharArrayReader</td><td align="center">CharArrayWriter</td></tr><tr><td align="center">访问管道</td><td align="center">PipedInputStream</td><td align="center">PipedOutputStream</td><td align="center">PipedReader</td><td align="center">PipedWriter</td></tr><tr><td align="center">访问字符串</td><td align="center"></td><td align="center"></td><td align="center">StringReader</td><td align="center">StringWriter</td></tr><tr><td align="center">==缓冲流==</td><td align="center">BufferedInputStream</td><td align="center">BufferedOutputStream</td><td align="center">BufferedReader</td><td align="center">BufferedWriter</td></tr><tr><td align="center">转换流</td><td align="center"></td><td align="center"></td><td align="center">InputStreamReader</td><td align="center">OutputStreamWriter</td></tr><tr><td align="center">对象流</td><td align="center">ObjectInputStream</td><td align="center">ObjectOutputStream</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">FilterInputStream</td><td align="center">FilterOutputStream</td><td align="center">FilterReader</td><td align="center">FilterWriter</td></tr><tr><td align="center">打印流</td><td align="center"></td><td align="center">PrintStream</td><td align="center"></td><td align="center">PrintWriter</td></tr><tr><td align="center">推回输入流</td><td align="center">PushbackInputStream</td><td align="center"></td><td align="center">PushbackReader</td><td align="center"></td></tr><tr><td align="center">特殊流</td><td align="center">DataInputStream</td><td align="center">DataOutputStream</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul><li>==节点流==：直接从数据源或目的地读写数据</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118224629.png" alt="20201118224629"></p><ul><li>==处理流==：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118224802.png" alt="20201118224802" style="zoom:67%;" /><h3 id="InputStream-amp-Reader"><a href="#InputStream-amp-Reader" class="headerlink" title="InputStream &amp; Reader"></a>InputStream &amp; Reader</h3><ol><li><p>==InputStream和Reader是所有输入流的基类==。</p></li><li><p>InputStream（典型实现：FileInputStream）</p><ul><li>int read()</li><li>int read(byte[] b)</li><li>int read(byte[] b,int off,int len)</li></ul></li><li><p>Reader（典型实现：FileReader）</p><ul><li><p>int read()</p></li><li><p>int read(byte[] b)</p></li><li><p>int read(byte[] b,int off,int len)</p></li></ul></li><li><p>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</p></li><li><p>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader</p></li></ol><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a><strong>InputStream</strong></h4><ol><li>int read()：从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</li><li>int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。</li><li>int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。</li><li>public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</li></ol><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a><strong>Reader</strong></h4><ol><li>int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1。</li><li>int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li><li>int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li><li>public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</li></ol><h3 id="OutputStream-amp-Writer"><a href="#OutputStream-amp-Writer" class="headerlink" title="OutputStream &amp; Writer"></a>OutputStream &amp; Writer</h3><ol><li><p>OutputStream 和 Writer 也非常相似：</p><ul><li><p>void write(int b/int c);</p></li><li><p>void write(byte[] b/char[] cbuf);</p></li><li><p>void write(byte[] b/char[] buff, int off, int len);</p></li><li><p>void flush();</p></li><li><p>void close(); 需要先刷新，再关闭此流</p></li></ul></li><li><p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数</p><ul><li><p>void write(String str);</p></li><li><p>void write(String str, int off, int len);</p></li></ul></li><li><p>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。</p></li></ol><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a><strong>OutputStream</strong></h4><ul><li>void write(int b)：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。</li><li>void write(byte[] b)：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。</li><li>void write(byte[] b,int off,int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</li><li>public void flush()throws IOException：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</li><li>public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源</li></ul><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a><strong>Writer</strong></h4><ul><li>void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</li><li>void write(char[] cbuf)：写入字符数组。</li><li>void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符。</li><li>void write(String str)：写入字符串。</li><li>void write(String str,int off,int len)：写入字符串的某一部分。</li><li>void flush()：刷新该流的缓冲，则立即将它们写入预期目标。</li><li>public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源</li></ul><h2 id="节点流-或文件流"><a href="#节点流-或文件流" class="headerlink" title="节点流(或文件流)"></a>节点流(或文件流)</h2><h3 id="通用步骤："><a href="#通用步骤：" class="headerlink" title="通用步骤："></a><strong>通用步骤：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 实例化File类对象，指明要操作的文件</span><br><span class="line">* 提供具体的流</span><br><span class="line">* 数据的操作</span><br><span class="line">* 关闭资源</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：异常处理</span></span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><ol><li><p>步骤：</p><ul><li>File类的实例化</li><li>FileReader流的实例化</li><li>读入的操作</li><li>资源关闭</li></ul></li><li><p>说明点：</p></li></ol><ul><li>read()的理解：返回读入的一个字符，如果到大文件末尾，返回-1。</li><li>异常处理：为了保证资源一定可以执行关闭操作。需要使用try-catch-finally处理。</li><li>读入文件一定要存在，否则就会报FileNotFoundException</li></ul><ol start="3"><li>基本操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileReaderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.提供具体的流</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.数据的读入</span></span><br><span class="line">            <span class="comment">//read()：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//            int data = fileReader.read();</span></span><br><span class="line"><span class="comment">//            while (data != -1) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char) data);</span></span><br><span class="line"><span class="comment">//                //读取下一个字符</span></span><br><span class="line"><span class="comment">//                data = fileReader.read();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二：语法上针对于方式一的修改</span></span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.流的关闭操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>对read()操作升级：使用read()的重载方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileReaderTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    System.out.print(cbuf[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><ol><li><p>步骤：</p><ul><li>创建File类的对象：指明读入和写出的文件</li><li>创建输入流和输出流的对象</li><li>数据的读入和写出操作</li><li>关闭流资源</li></ul></li><li><p>==说明点==</p></li></ol><ul><li>从内存中写出数据到硬盘的文件里<ul><li>输出操作，对应的File可以不存在。<pre><code> *  如果不存在，在输出过程中，会自动创建此文件      *  如果存在：      *      使用的流构造器是: FileWriter(file,false) / FileWriter(file)，对原有文件覆盖           *      使用的流构造器是: FileWriter(file,true)，不会对原有文件覆盖，而是在原有文件的基础上</code></pre></li></ul></li></ul><ol start="3"><li>基本操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileWriterTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建File类的对象：指明读入和写出的文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">            File file1 = <span class="keyword">new</span> File(<span class="string">&quot;Hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(file1);</span><br><span class="line">            <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;  <span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//每次写出len个字符</span></span><br><span class="line">                fileWriter.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>)</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><ol><li>==注意点：使用字节流处理文本文件，可能出现乱码==</li><li>说明：<ul><li>对于文本文件（.txt，.java，.c，.cpp），使用字符流处理</li><li>对于非文本文件，使用字节流处理</li></ul></li><li>基本操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fISStreamTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//造文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">            <span class="comment">//造流</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//读数据</span></span><br><span class="line">            <span class="keyword">int</span> len;  <span class="comment">// 记录每次读取的字节的个数</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    System.out.print(bytes[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭流资源</span></span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>复制图片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fISStreamTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建File类对象</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">            File file1 = <span class="keyword">new</span> File(<span class="string">&quot;cat2.jpeg&quot;</span>);</span><br><span class="line">            <span class="comment">//创建输入流和输出流的对象</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">            <span class="comment">//数据的读入和写出操作</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)</span><br><span class="line">                    outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>通用操作：指定路径下的文件复制操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String srcPath,String destPath)</span> </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建File类对象</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">            File file1 = <span class="keyword">new</span> File(destPath);</span><br><span class="line">            <span class="comment">//创建输入流和输出流的对象</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">            <span class="comment">//数据的读入和写出操作</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)</span><br><span class="line">                    outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)</span><br><span class="line">                    inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String srcPath = <span class="string">&quot;文件路径&quot;</span>;</span><br><span class="line">        String destPath = <span class="string">&quot;复制路径&quot;</span>;</span><br><span class="line">        copyFile(srcPath,destPath);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;整个复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//13031</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以复制文本文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><ol><li>处理流的一种，“套接”在已有的流的基础上</li><li>缓冲流涉及到的类<ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul></li><li>==作用==：提供流的读取、写入的速度<ul><li>==原因==：内部提供了一个缓冲区。默认情况下是<em>8kb</em></li></ul></li><li>说明：<ul><li>先关闭外层流，再关闭内层流</li><li>==关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略==</li></ul></li><li>非文本文件的复制</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BfStreamTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">       BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.造文件</span></span><br><span class="line">           File file = <span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>);</span><br><span class="line">           File file1 = <span class="keyword">new</span> File(<span class="string">&quot;cat3.jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.造流</span></span><br><span class="line">           <span class="comment">//2.1造节点流</span></span><br><span class="line">           FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">           FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line">           <span class="comment">//2.2造处理流</span></span><br><span class="line">           bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">           bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.复制：数据的读入和写出操作</span></span><br><span class="line">           <span class="keyword">int</span> len;</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">           <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               bufferedOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//关闭流资源</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bufferedOutputStream != <span class="keyword">null</span>)</span><br><span class="line">                   bufferedOutputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (bufferedInputStream != <span class="keyword">null</span>)</span><br><span class="line">                   bufferedInputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>文本文件的复制，略，基本雷同</li></ol><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>图片的加密</p><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201129145623613.png" alt="image-20201129145623613"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PicTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片的加密操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncrypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//文件类可省略，它会自动包装为文件类</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;cat.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cat2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">              <span class="comment">//核心</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>图片的解密</p></li></ol><ul><li>对加密的文件做同样的异或操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片的解密操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDecode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//文件类可省略，它会自动包装为文件类</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;加密后的玛雅.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;解密后的玛雅.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取文本上每个字符出现的次数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提示：遍历文本每一个字符，字符及出现次数保存在Map中，将Map中数据写入文件。</span></span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ol><li>转换流提供了在字节流和字符流之间的转换</li><li>==Java API提供了两个转换流==:<ul><li>==InputStreamReader==：将InputStream转换为Reader</li><li>==OutputStreamWriter==；将Writer转换为OutputStream</li></ul></li><li>字节流中的数据都是字符时，转成字符流操作更高效</li><li>很多时候我们使用转换流来==处理文件乱码==问题。实现==编码==和== 解码==的功能</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201129151859662.png" alt="image-20201129151859662" style="zoom:33%;" /><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><ol><li>==实现将字节的输入流按指定字符集转换为字符的输入流==</li><li>需要和InputStream“套接”</li><li>构造器<ul><li>public InputStreamReader(InputStream in)</li><li>public InputSreamReader(InputStream in,String charsetName)</li></ul></li></ol><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><ol><li>==实现将字符的输出流按指定字符集转换为字节的输出流==</li><li>需要和OutputStream“套接”</li><li>构造器<ul><li>public OutputStreamWriter(OutputStream out)</li><li>public OutputSreamWriter(OutputStream out,String charsetName)</li></ul></li></ol><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ol><li>编码:字符串字节数组</li><li>解码:字节数组字符串</li><li>转换流的编码应用<ul><li>可以将字符按指定编码格式存储</li><li>可以对文本数据按指定编码格式来解读</li><li>指定编码表的动作由构造器完成</li></ul></li></ol><h2 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h2><ol><li>==System.in==和==System.out==分别代表了系统标准的输入和输出设备<ul><li>默认输入设备是：键盘，输出设备是：显示器</li></ul></li><li>System.in的类型是==InputStream==，直接以流的形式读取了</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li><li>重定向:通过System类的setIn()，setOut()方法对默认设备进行改变</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">                String data = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (data.equalsIgnoreCase(<span class="string">&quot;e&quot;</span>) || data.equalsIgnoreCase(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序结束！&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String upperCase = data.toUpperCase();</span><br><span class="line">                System.out.println(upperCase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ol><li>==实现将基本数据类型的数据格式转化为字符串输出==，指定输入/输出的位置</li><li>打印流：==PrintStream==和==PrintWriter==<ul><li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。<ul><li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li></ul></li><li>System.out返回的是PrintStream的实例</li></ul></li><li>例子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">null</span>; <span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>)); <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true);</span></span><br><span class="line"><span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">System.setOut(ps); &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符 System.out.print((char) i);</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">System.out.println(); <span class="comment">// 换行 &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace(); &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123; ps.close();</span><br><span class="line">&#125; &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ol><li><p>作用：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流</p></li><li><p>数据流有两个类:(==用于读取和写出基本数据类型、String类的数据==)</p><ul><li>==DataInputStream== 和 ==DataOutputStream==</li><li>分别“套接”在 InputStream 和 OutputStream 子类的流上</li></ul></li><li><p>DataInputStream中的方法</p><ul><li>boolean readBoolean() </li><li>char readChar() </li><li>double </li><li>readDouble() </li><li>long readLong()</li><li>String readUTF()</li><li>byte readByte() </li><li>float readFloat() </li><li>short readShort() </li><li>int readInt()</li><li>void readFully(byte[] b)</li></ul></li><li><p>DataOutputStream中的方法</p><ul><li>==将上述的方法的read改为相应的write即可==</li></ul></li><li><p>练习</p><ul><li>将内存中的字符串、基本数据类型变量写出到文件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 创建连接到指定文件的数据输出流对象</span></span><br><span class="line">dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;destData.dat&quot;</span>)); dos.writeUTF(<span class="string">&quot;我爱北京天安门&quot;</span>); <span class="comment">// 写UTF字符串 dos.writeBoolean(false); // 写入布尔值</span></span><br><span class="line">dos.writeLong(<span class="number">1234567890L</span>); <span class="comment">// 写入长整数 System.out.println(&quot;写文件成功!&quot;);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">null</span>; <span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;destData.dat&quot;</span>)); String info = dis.readUTF();</span><br><span class="line"><span class="keyword">boolean</span> flag = dis.readBoolean();</span><br><span class="line"><span class="keyword">long</span> time = dis.readLong();</span><br><span class="line">System.out.println(info); System.out.println(flag); System.out.println(time);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dis != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123; dis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace();</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>==注意==：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</li></ol><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ol><li><p>用于==存储==和==读取==基本数据类型数据或对象的处理流。它的强大之处就是==可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来==</p></li><li><p>==ObjectInputStream==和==OjbectOutputSteam==</p><ul><li>==序列化==：用ObjectOutputStream类==保存==基本类型数据或对象的机制</li><li>==反序列化==：用ObjectInputStream类==读取==基本类型数据或对象的机制</li></ul></li><li><p>ObjectOutputStream和ObjectInputStream==不能序列化static和transient==修饰的成员变量</p><ul><li>以下面的Person类为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">44353533453L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将变量用static 和 transient修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">略</span><br><span class="line">  </span><br><span class="line"><span class="comment">//此时的反序列化结果</span></span><br><span class="line">我爱北京天安门</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;  <span class="comment">//显然无法序列化这两个变量</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><ol><li><p>==对象序列化机制==允许把内存中的Java对象转换成平台无关的==二进制流==，从 而允许把这种二进制流持久地==保存在磁盘上==，或通过网络将这种二进制流==传输到另一个网络节点==。//==当其它程序获取了这种二进制流，就可以恢复成原来的Java对象==</p></li><li><p>==序列化的好处==：在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原</p></li><li><p>序列化是 RMI(Remote Method Invoke – 远程方法调用)过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此==序列化机制是 JavaEE 平台的基础==</p></li><li><p>==如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的==，==为了让某个类是可序列化的，该类必须实现如下两个接口之一==。 否则，会抛出NotSerializableException异常</p><ul><li>$\color{red}{Serializable}$</li><li>Externalizable</li></ul></li><li><p>==凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量==:</p><ul><li>$\color{red}{private static final long serialVersionUID}$;</li><li>==serialVersionUID==用来表明类的不同版本间的兼容性。简言之，其目的是==以序列化对象 进行版本控制，有关各版本反序列化时是否兼容==。</li><li>==如果类没有显示定义这个静态常量==，它的值是==Java运行时环境根据类的内部细节自动生成==的。<ul><li>若类的实例变量做了修改，serialVersionUID 可能发生变化。故==建议， 显式声明==</li></ul></li></ul></li><li><p>==Java的序列化机制==是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，==JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较==，如果相同就认为是==一致==的，==可以进行反序列化==，==否则就会出现序列化版本不一致的异 常。(InvalidCastException)==</p></li></ol><h3 id="使用对象流序列化对象"><a href="#使用对象流序列化对象" class="headerlink" title="使用对象流序列化对象"></a>使用对象流序列化对象</h3><h4 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h4><ol><li>==若某个类实现了 Serializable 接口，该类的对象就是可序列化的:==<ul><li>创建一个 ObjectOutputStream</li><li>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</li><li>==注意写出一次，操作flush()一次==</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化实现"><a href="#反序列化实现" class="headerlink" title="反序列化实现"></a>反序列化实现</h4><ol><li>步骤<ul><li>创建一个 ObjectInputStream</li><li>调用 readObject() 方法读取流中的对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObctIStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类实现序列化"><a href="#自定义类实现序列化" class="headerlink" title="自定义类实现序列化"></a>自定义类实现序列化</h4><ol><li><p>==强调==：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是==可序列化的==，否则拥有该类型的 Field 的类也不能序列化</p></li><li><p>==以Person类为例==</p><ul><li>需要==实现接口==：Serializable</li><li>当前类==提供一个全局常量==：serialVersionUID</li><li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化de 。(默认情况下，基本数据类型可序列化)</li></ul></li><li><pre><code class="java">package lesson;import org.junit.jupiter.api.Test;import java.io.*;/** * @author Justry * @Description 对象流的使用 * @date 2020-11-30 9:35 上午 */public class ObiectIOStreamTest &#123;    //序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去，使用ObjectOutputStream实现    @Test    public void ObjectOStreamTest() &#123;        ObjectOutputStream oos = null;        try &#123;            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));            oos.writeObject(&quot;我爱北京天安门&quot;);            oos.flush();            oos.writeObject(new Person(&quot;如花&quot;, 60));            oos.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (oos != null)                try &#123;                    oos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;        &#125;    &#125;    //反序列化过程：将磁盘文件中的对象还原为内存中的java对象，使用ObjectInputStream实现    @Test    public void ObctIStreamTest() &#123;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));            Object obj = ois.readObject();            String str = (String) obj;            Person p = (Person) ois.readObject();            System.out.println(str);  // 我爱北京天安门            System.out.println(p);  // Person&#123;name=&#39;如花&#39;, age=60&#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (ois != null)                try &#123;                    ois.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;        &#125;    &#125;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Q</span><br><span class="line"></span><br><span class="line">1. 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗?</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。&#x2F;&#x2F;这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。</span><br><span class="line">换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。</span><br><span class="line">由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="随机存取文件流"><a href="#随机存取文件流" class="headerlink" title="随机存取文件流"></a>随机存取文件流</h2><h3 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h3><ol><li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写，即可以作为输入/出流<ul><li>实现图片的复制</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile r1 = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile r2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;cat.jpeg&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            r2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;cat2.jpeg&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = r1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                r2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r2 != <span class="keyword">null</span>)</span><br><span class="line">                r2.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r1 != <span class="keyword">null</span>)</span><br><span class="line">                r1.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件</p><ul><li>支持只访问文件的部分内容 </li><li>可以向已存在的文件后追加内容</li></ul></li><li><p>==RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置==</p><ul><li>long getFilePointer():获取文件记录指针的当前位置 </li><li>void seek(long pos):将文件记录指针定位到 pos 位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile rw = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;Hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rw.seek(<span class="string">&quot;Hello.txt&quot;</span>.length());  <span class="comment">// 将指针指到末尾，追加内容</span></span><br><span class="line">    rw.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    rw.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器</p><ul><li>public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode)</li></ul></li><li><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式</p><ul><li>r；以只读方式打开</li><li>rw；打开以便读取和写入 </li><li>rwd；打开以便读取和写入；同步文件内容的更新 </li><li>rws；打开以便读取和写入；同步文件内容和元数据的更新</li></ul></li><li><p>==如果模式为只读r==。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 ==如果模式为rw读写==，如果文件不 存在则会去创建文件；如果存在则不会创建，写到文件时会对原有内容进行部分覆盖</p></li><li><p>应用：多线程断点下载</p></li></ol><h2 id="流的基本应用小节"><a href="#流的基本应用小节" class="headerlink" title="流的基本应用小节"></a>流的基本应用小节</h2><ol><li>流是用来处理数据的。</li><li>处理数据时，一定要先明确数据源，与数据目的地，数据源可以是文件，可以是键盘。</li><li>数据目的地可以是文件、显示器或者其他设备。</li><li>而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等</li></ol><h2 id="NIO-2中Path、-Paths、Files类的使用"><a href="#NIO-2中Path、-Paths、Files类的使用" class="headerlink" title="NIO.2中Path、 Paths、Files类的使用"></a>NIO.2中Path、 Paths、Files类的使用</h2><ol><li>NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。==NIO将以更加高效的方式进行文件的读写操作==。</li><li>Java API中提供了两套NIO：==一套是针对标准输入输出NIO==，==另一套就是网 络编程NIO==</li></ol><h2 id="实战总结："><a href="#实战总结：" class="headerlink" title="实战总结："></a>实战总结：</h2><ul><li>一个流只能使用一次，不能重复使用，若想使用，必须重新创建流</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;重点掌握-：节点流、缓冲流、转换流、对象流&quot;&gt;&lt;a href=&quot;#重点掌握-：节点流、缓冲流、转换流、对象流&quot; class=&quot;headerlink&quot; title=&quot;==重点掌握==：节点流、缓冲流、转换流、对象流&quot;&gt;&lt;/a&gt;==重点掌握==：节点流、缓冲流、转换流</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十一章 集合</title>
    <link href="https://asteroidcs.github.io/undefined/f650.html"/>
    <id>https://asteroidcs.github.io/undefined/f650.html</id>
    <published>2020-11-27T01:12:32.106Z</published>
    <updated>2020-12-10T13:18:33.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><h3 id="集合与数组存储数据概述"><a href="#集合与数组存储数据概述" class="headerlink" title="集合与数组存储数据概述"></a>集合与数组存储数据概述</h3><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</p><h3 id="数组存储的弊端"><a href="#数组存储的弊端" class="headerlink" title="数组存储的弊端"></a>数组存储的弊端</h3><ul><li>一旦初始化以后，其长度就不可以修改了，这就使得不便于扩展</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作不便，且效率不高</li><li>获取数组中实际元素的个数的需求，数组中没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。故无法满足对于无序、不可重复的需求</li></ul><h3 id="集合存储的优点"><a href="#集合存储的优点" class="headerlink" title="集合存储的优点"></a>集合存储的优点</h3><p>集合的出现就是为了==解决数组存储数据方面的弊端==</p><h3 id="集合框架结构：Java集合可分为-Collection-和-Map-两种体系"><a href="#集合框架结构：Java集合可分为-Collection-和-Map-两种体系" class="headerlink" title="集合框架结构：Java集合可分为==Collection==和==Map==两种体系"></a>集合框架结构：Java集合可分为==Collection==和==Map==两种体系</h3><ul><li><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>List接口：==存储有序的、可重复的数据  ——&gt;  “动态”数组==</li><li>Set接口：==存储无序的、不可重复的数据==</li><li>Collection接口继承树</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/wpsClwKIf.png" alt="wpsClwKIf" style="zoom: 33%;" /></li><li><p>Map接口：双列数据，==保存具有映射关系的“key-value”对的集合==</p><ul><li>Map接口继承树</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201116214800.png" alt="20201116214800" style="zoom: 50%;" /></li></ul><h2 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul><li>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合——&gt;  ==继承性的特点：可以调用父类的方法==</li><li>==JDK不提供Collection接口的任何直接实现，而是提供更具体的子接口(Set、List)实现== ——&gt; 意味着只能构造其子接口的对象，即ArrayList、LinkedList、Vector/LinkedHashSet、TreeSet等</li><li>在==Java5==之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；==从JDK 5.0增加了泛型以后==，Java集合可以记住容器中对象的数据类型。</li><li>$\color{red}{注意：向Collection接口的实现类对象中添加数据obj时，要求obj所在类重写equals()方法}$</li></ul><h3 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h3><ol><li>增加数据</li></ol><ul><li>add(Object e): 将元素e添加到集合coll中</li><li>addAll(Collection coll): 将coll集合中的元素添加到当前的集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于JDK不提供Collection接口的任何直接实现，所以这种写法是错误的 ---&gt; 只能用其子接口</span></span><br><span class="line"><span class="comment">//        Collection collection = new Collection();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用子接口实现</span></span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);  <span class="comment">// 其中false为Boolean型，包装类</span></span><br><span class="line">        collection1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(collection1);  <span class="comment">// [123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addAll</span></span><br><span class="line">        collection2.add(<span class="number">4324</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection2.add(<span class="keyword">new</span> String(<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">        collection2.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection2);  <span class="comment">// [4324, 555, 123, Jack, true]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合1加入集合2中</span></span><br><span class="line">        collection2.addAll(collection1);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection2);  <span class="comment">// [4324, 555, 123, Jack, true, 123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==从代码输出的结果可以看出：这里正好体现了List接口存放有序、可重复数据的特点==</li></ul><ol start="2"><li>删除数据</li></ol><ul><li>clear()：==清空==集合元素</li><li>remove(Object obj)：从当前集合中移除指定的obj元素</li><li>removeAll(Collection coll)：移除当前集合与另外的coll集合的==交集==中的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">      collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      collection1.add(<span class="number">123</span>);</span><br><span class="line">      collection1.add(<span class="keyword">false</span>);</span><br><span class="line">      collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [123, 123, false, Tom]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//remove</span></span><br><span class="line">      collection1.remove(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [123, 123, false]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// clear</span></span><br><span class="line">      collection1.clear();</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//removeAll</span></span><br><span class="line">      Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      collection2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">      collection1.removeAll(collection2);</span><br><span class="line">      System.out.println(collection1);  <span class="comment">// [false, Tom]</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>查找数据</li></ol><ul><li>contains(Object obj)；判断当前集合中是否包含obj</li><li>containsAll(Collection coll)：判断形参coll中所有元素是否都存在于当前集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ContainsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);  <span class="comment">// 其中false为Boolean型，包装类</span></span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Contains</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = collection1.contains(<span class="number">123</span>);</span><br><span class="line">        System.out.println(contains);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> contains1 = collection1.contains(<span class="number">3543</span>);</span><br><span class="line">        System.out.println(contains1);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此处调用的是String类中的equals，由于String重写了equals方法，</span></span><br><span class="line"><span class="comment">         * 故比较的是内容，而非地址，所以返回true，</span></span><br><span class="line"><span class="comment">         * 若自定义的类没有重写object的equals方法，则返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(collection1.contains(<span class="string">&quot;Tom&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ContainsAll</span></span><br><span class="line">        Collection collection2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        collection2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection2.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合collection2中的所有元素是否都存在于collection1中</span></span><br><span class="line">        <span class="keyword">boolean</span> b = collection1.containsAll(collection2);</span><br><span class="line">        System.out.println(b);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>集合的长度</li></ol><ul><li>size(): 获取添加的元素个数</li></ul><ol start="5"><li><p>其他</p><ul><li><p>isEmpty()：判断当前集合是否为空</p></li><li><p>retainAll(Collection coll): 交集，将当前集合修改为当前集合与coll的交集</p></li><li><p>equals(Object obj): 判断当前集合与形参集合的元素是否都相同</p></li><li><p>hashCode()：返回当前对象的哈希值</p></li><li><p>toArray()：集合转换成数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object[] array = collection1.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;  <span class="comment">// 123 123 false Tom</span></span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展：数组 ---&gt; 集合</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);  <span class="comment">// [AA, BB, CC]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        List arr = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">        System.out.println(arr);  <span class="comment">// [[I@3ecd23d9] ---&gt; 识别为了一个元素</span></span><br><span class="line"></span><br><span class="line">        List arr1 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(arr1);  <span class="comment">//[123, 456]</span></span><br><span class="line"></span><br><span class="line">        List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">        System.out.println(arr2);  <span class="comment">// [123, 456]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展：数组 ---&gt; 集合 : 调用Arrays类的静态方法asList()</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);  <span class="comment">// [AA, BB, CC]</span></span><br></pre></td></tr></table></figure><ul><li>iterator(): 返回Iterator接口的实例，用于遍历集合元素</li></ul><p>$\color{red}{在判断时会调用obj对象所在类的equals()方法}$</p><ol start="6"><li><p>集合的默认遍历方法（jdk8新特性）—&gt; ==forEach==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="number">343</span>);</span><br><span class="line">    coll.add(<span class="number">343</span>);</span><br><span class="line"></span><br><span class="line">    coll.forEach(System.out::println);<span class="comment">//方法引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="terator迭代器接口"><a href="#terator迭代器接口" class="headerlink" title="terator迭代器接口"></a>terator迭代器接口</h3><ul><li><p>==Iterator仅用于遍历集合==，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = collection1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);  <span class="comment">// 123 123 false Tom </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">while</span> (collection1.iterator().hasNext())&#123;   <span class="comment">// 每次产生一个全新的迭代器对象</span></span><br><span class="line">      System.out.println(collection1.iterator().next());  <span class="comment">// 死循环 ---&gt; 不断输出第一个元素</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>==使用迭代器遍历集合一般使用的方式以及迭代器执行原理：==</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201116222158-20201127205655581.png" alt="20201116222158-20201127205655581" style="zoom: 67%;" /></li><li><p>remove()方法</p><ul><li><p>内部定义了remove方法，==Iterator可以删除集合的元素==，==区别集合的remove()方法和迭代器的remove()方法==</p></li><li><p>注意指针的位置，若调用remove()方法时指针位置为空，则报异常IllegalStateException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = collection1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object o = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Tom&quot;</span>.equals(o))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(collection1);  <span class="comment">// [123, 123, false]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="foreach循环-增强for循环"><a href="#foreach循环-增强for循环" class="headerlink" title="foreach循环(增强for循环)"></a>foreach循环(增强for循环)</h3><ul><li><p>Java 5.0 提供了foreach循环迭代访问Collection和数组</p></li><li><p>无需长度、索引</p></li><li><p>内部仍然调用了迭代器 ——&gt; ==底层：Iterator==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 局部变量 : 数组/Collection对象)&#123;</span><br><span class="line">    <span class="comment">//对局部变量操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection collection1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        collection1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="keyword">false</span>);</span><br><span class="line">        collection1.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : collection1)&#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);  <span class="comment">// 123 123 false Tom </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>$\color{red}{注意：增强for循环是将值赋给局部变量，改变的是局部变量，不影响对象中的元素}$</p></li><li><p><strong>练习：</strong>判断输出结果为何？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(String myStr : str)&#123;</span><br><span class="line">            myStr = <span class="string">&quot;atguigu&quot;</span>;</span><br><span class="line">            System.out.println(myStr);</span><br><span class="line">        &#125;<span class="comment">//5行&quot;atguigu&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length;i++)&#123;</span><br><span class="line">            System.out.println(str[i]);</span><br><span class="line">        &#125;<span class="comment">//5行null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collection子接口一：List"><a href="#Collection子接口一：List" class="headerlink" title="Collection子接口一：List"></a>Collection子接口一：List</h2><ol><li><p>存储有序的、可重复的数据。==&gt; “动态”数组，替换原有的数组 —&gt; 避免了角标越界</p><ul><li>理解：添加数据时，当原数组的存储空间不够时，会重新生成一个容量较大的新数组，将原数组中的元素放进新数组中，并添加新的数据 ———&gt; 占内存 </li></ul></li><li><p>List接口方法：除了从Collection集合继承的方法外，==List 集合里添加了一些根据索引来操作集合元素的方法==</p></li><li><p>增加数据</p><ul><li>void add(int index,Object ele)：在index位置插入ele元素；</li><li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">false</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="comment">//数组的第二个位置插入数据</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">657</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, 657, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addAll</span></span><br><span class="line">        <span class="comment">//将list1插入list的索引2位置</span></span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list1.add(<span class="number">7868</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list1.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        list.addAll(<span class="number">2</span>, list1);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><ul><li>Object remove(int index)：移除指定index位置的元素，==并返回此元素==</li><li>Object remove(Object obj)：移除指定的元素(若有多个，则只移除首位的元素)，==并返回true/false==</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">false</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, false, 342]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove(int index)</span></span><br><span class="line">        Object o = list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);  <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove(Object obj)</span></span><br><span class="line">        <span class="keyword">boolean</span> b = list.remove(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(b);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = list.remove(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(b1);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>查找</p><ul><li>Object get(int index)：获取指定index位置的元素；</li><li>int indexOf(Object obj)：返回obj在集合中首次出现的位置；</li><li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置；</li><li>List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">342</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, Tom, Jack, 342, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(int index)</span></span><br><span class="line">        Object o = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(o);  <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int indexOf(Object obj)</span></span><br><span class="line">        <span class="keyword">int</span> i = list.indexOf(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(i);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int lastIndexOf(Object obj)</span></span><br><span class="line">        <span class="keyword">int</span> i1 = list.lastIndexOf(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(i1);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List subList(int fromIndex, int toIndex)</span></span><br><span class="line">        List list1 = list.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list1);  <span class="comment">// [Tom, Jack, 342]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><ul><li>Object set(int index, Object ele)：设置指定index位置的元素为ele；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="number">5464</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, 5464, Jack]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​    ==作为List接口的主要实现类；由于是线程不安全的，故效率高；底层使用Object[] elementData存储。==</p><ul><li><p><strong>==源码分析==：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7的情况下：</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建而来长度为10的Object[]数组elementData；</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">list.add(<span class="number">12</span>);<span class="comment">//如果此次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk8中ArrayList的变化：</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组。</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中。</span></span><br><span class="line"><span class="comment">//后续的添加扩容操作与jdk7无异</span></span><br></pre></td></tr></table></figure></li><li><p><strong>==小结==：</strong>jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8则类似于懒汉式，延迟了数组的创建，节省内存。</p></li><li><p><strong>【面试题】</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);  <span class="comment">// [1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考点：确定调用哪个remove， 两个remove()方法中index优先权大于Object，删除索引为2的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list.remove(<span class="number">2</span>);<span class="comment">//两个remove()方法中index优先权大于Object，删除索引为2的元素</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//删除值为2的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol><li>对于==频繁的插入和删除==操作，使用此类效率比ArrayList高；底层使用双向链表存储。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();<span class="comment">//内部声明了Node类型的first和last属性，，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line">其中，Node定义为：体现了LinkedList的双向链表</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Node除了保存数据，还定义了两个变量：</p><ul><li>prev：记录前一个元素的位置</li><li>next：记录下一个元素的位置</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117101744.png" alt="20201117101744" style="zoom:75%;" /></li><li><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeLast</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol><li><p>作为List接口的古老实现类(1.0)；线程安全的，效率低；底层使用Object[] elementData存储。</p></li><li><p><strong>源码分析：</strong></p><ul><li>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍。</li></ul></li><li><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>==面试题==：</strong>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解。ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p><ul><li><p>ArrayList和LinkedList的异同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二者都线程不安全，相对线程安全的Vector，执行效率高。</span><br><span class="line">此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br></pre></td></tr></table></figure></li><li><p>ArrayList和Vector的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(<span class="keyword">synchronized</span>)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的<span class="number">2</span>倍空间，而ArrayList是<span class="number">1.5</span>倍。Vector还有一个子类Stack。</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Collection子接口二：Set"><a href="#Collection子接口二：Set" class="headerlink" title="Collection子接口二：Set"></a>Collection子接口二：Set</h2><ul><li>Set接口是Collection的子接口，==<em>set接口没有提供额外的方法</em>==。都是Collection中声明过的方法。</li><li>==存储无序的、不可重复的数据== ==&gt; 高中数学中的“集合”</li><li>Set判断两个对象是否相同不是使用 == 运算符，而是根据equals()方法</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol><li><p>作为Set接口的主要实现类；==是线程不安全的，可以存储null值==。</p></li><li><p><strong>以HashSet为例说明：Set存储无序的、不可重复的数据:</strong></p><ul><li><p>==无序性==：==不等于随机性==。存储的数据在底层数组中并非按照数组索引的顺序添加，而是==根据数据的哈希值决定的==</p></li><li><p>==不可重复性==：保证添加的元素==按照equals()判断==时，不能返回true。即：相同的元素只能添加一个。—&gt; ==因此自定义类需要重写equals( )方法和hashCode( )方法，先比较hash值，再用equals( )比较==</p></li><li><p>==要求==：</p><ul><li>向Set中添加元素所在类，其所在类一定要==重写hashCode()和equals()==；</li><li>==重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码== —&gt; 哈希值</li><li>==重写两个方法的小技巧==：对象中用作equals()方法比较的Field，都应该用来计算hashCode值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        set.add(<span class="number">657</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set); <span class="comment">// [657, Tom, 123] ---&gt; 不可重复性</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        System.out.println(set);  <span class="comment">// [AA, 657, Tom, 123, Jack] ---&gt; 无序性</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>==<strong>添加元素的过程：以HashSet为例</strong>==</p><ul><li>向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值</li><li>==此哈希值接着通过某种算法，计算出在HashSet底层数组中的存放位置（即为：索引位置）==</li><li>判断数组此位置上是否已有元素：<ul><li>没有其他元素==&gt;添加成功。==&gt;情况1</li><li>有其他元素b(或以链表形式存在的多个元素)，则比较元素a与b的哈希值:<ul><li>哈希值不同==&gt;添加成功。==&gt;情况2</li><li>哈希值相同，进而调用元素a所在类的equals()方法：<ul><li>返回false==&gt;添加成功。==&gt;情况3</li><li>返回true，则添加失败。</li></ul></li></ul></li></ul></li></ul></li><li><p>对于添加成功的情况2和3而言：元素a与已经存在指定索性位置上的数据以链表的方式存储。</p><ul><li>jdk7：元素a放到数组中，指向原来的元素。（头插）</li><li>jdk8：原来的元素在数组中指向a元素。（尾插）</li><li>总结：七上八下</li></ul></li><li><p>==HashSet底层：数组+链表的结构==</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117110143.png" alt="20201117110143" style="zoom: 50%;" /></li><li><p>==问题==：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</span><br><span class="line"><span class="number">31</span>只占用5bits,相乘造成数据溢出的概率较小。</span><br><span class="line"><span class="number">31</span>可以 由i*<span class="number">31</span>== (i&lt;&lt;<span class="number">5</span>)-<span class="number">1</span>来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</span><br><span class="line"><span class="number">31</span>是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有<span class="number">1</span>来整除！(减少冲突)</span><br></pre></td></tr></table></figure></li></ol><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ol><li><p>作为HashSet的子类；遍历其内部数据时，==可以按照添加顺序遍历==。==对于频繁的遍历操作，LinkedHashSet效率高于HashSet==</p></li><li><p>LinkedHashSet ==根据元素的 hashCode 值来决定元素的存储位置==，但它同时==使用双向链表维护元素的次序==，这使得元素看起来是以插入顺序保存的</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117110952.png" alt="20201117110952" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LinkedHashSet</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        set.add(<span class="number">657</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [123, Tom, 657] ---&gt; 不可重复性</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [123, Tom, 657, Jack, AA] ---&gt; 按照添加顺序遍历</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol><li><p>==以按照添加对象的指定属性进行排序==</p><ul><li>向TreeSet中添加的数据。要求是相同类的对象</li><li>两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）。默认情况下，TreeSet采用自然排序</li><li>==自然排序中==，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()</li><li>==定制排序中==，比较两个对象是否相同的标准为：compare()返回0，不再是equals()</li></ul></li><li><p><strong>新增方法</strong></p><ul><li>Comparator comparator()</li><li>Object first()</li><li>Object last()</li><li>Object lower(Object e)</li><li>Object higher(Object e)</li><li>SortedSet subSet(fromElement, toElement)</li><li>SortedSet headSet(toElement)</li><li>SortedSet tailSet(fromElement)</li></ul></li><li><p>==TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快==</p><img src="https://gitee.com/Dawn_Lee/blogimg/raw/master/20201117111739.png" alt="img" style="zoom: 50%;" /></li><li><p>User类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> age == user.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自然排序：默认从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            User user = (User) o;</span><br><span class="line"><span class="comment">//            return this.name.compareTo(user.name);</span></span><br><span class="line">            <span class="comment">// 二级排序</span></span><br><span class="line">            <span class="keyword">int</span> compare = -<span class="keyword">this</span>.name.compareTo(user.name);  <span class="comment">// 加了负号，所以按照姓名从大到小排序</span></span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, user.age);  <span class="comment">// 年龄从小到大排列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不匹配！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>自然排序实现</strong>==（实现Comparable接口）——&gt; 重写compareTo( )方法==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">56</span>));  <span class="comment">// 若排序方式中未定义年龄的排序方式，则无法添加成功</span></span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">65</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">32</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">33</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">56</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>定制排序实现</p><ul><li>构建comparator对象，并重写compare（）方法</li><li>将其作为形参传入User类的构造器中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Comparator comparator = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    User u1 = (User)o1;</span><br><span class="line">                    User u2 = (User)o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">56</span>));  <span class="comment">// 若排序方式中未定义年龄的排序方式，则无法添加成功</span></span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">32</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">33</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">56</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">65</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>==<strong>非常非常经典的面试题：</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);  <span class="comment">// 根据算法算出hash值h1，确定在set中的存储位置</span></span><br><span class="line">        set.add(p2);  <span class="comment">// 根据算法算出hash值，确定在set中的存储位置</span></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;  <span class="comment">// 只改变p1的属性值，但p1已存入set，在set中位置不变</span></span><br><span class="line">        set.remove(p1);  <span class="comment">// 根据此时的p1(属性改变后)计算出的hash值h2≠h1，所以没能删除set中的p1</span></span><br><span class="line">        System.out.println(set);  <span class="comment">//[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));  <span class="comment">// 根据算法算出hash值h2，此位置无元素，添加成功</span></span><br><span class="line">        System.out.println(set);  <span class="comment">//[Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));  <span class="comment">// 计算出hash值h1与p1所在位置哈希值相同，调用</span></span><br><span class="line">        <span class="comment">// Person中的equals()方法，返回结果为false，此对象以链表的形式存入数组中，添加成功。</span></span><br><span class="line">        System.out.println(set);  <span class="comment">// [Person&#123;id=1002, name=&#x27;BB&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;CC&#x27;&#125;, Person&#123;id=1001, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201117112759.png" alt="20201117112759" style="zoom:75%;" /><ol><li><p><strong>概述：</strong></p><ul><li><p>==双列数据，存储key-value对的数据== ==&gt; 类似于高中的函数，类比其他语言中的==字典==</p></li><li><p>==Map中的key：无序的，不可重复的==，使用Set存储所有的key。 ==&gt; key所在的类必须要重写equals()和hashCode()==（以HashMap为例）</p></li><li><p>==Map中的value：无序的，可重复的==，==使用Collection存储所有的value==。 –&gt; ==value所在类要重写equals()==</p></li><li><p>一个键值对：==key-value构成一个Entry对象==。</p></li><li><p>==Map中的Entry：无序的，不可重复的，使用Set存储所有entry==。</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118101436.png" alt="20201118101436" style="zoom: 50%;" /></li><li><p>==添加、删除、修改等操作==</p><ul><li>Object put(Object key,Object value):将制定key-value添加到（或修改）当前map对象中。</li><li>void putAll(Map m):将m中所有key-value对存放到当前map中。</li><li>Object remove(Object key):移除指定key的key-value对，并返回value。没有相应的key则返回null</li><li>void clear():清空当前map中的所有数据。与map=null操作不同</li></ul></li><li><p>==元素查询的操作==</p><ul><li>Object get(Object key):获取指定key对应的value。没有相应的key则返回null</li><li>boolean containsKey(Object key):是否包含指定的key。</li><li>boolean containsValue(Object value):是否包含指定的value。</li><li>int size():返回map中key-value对的个数。</li><li>boolean isEmpty(): 判断当前map是否为空。</li><li>boolean equals(Object obj):判断当前map和参数对象是否相等</li></ul></li><li><p>==元视图操作的方法==</p><ul><li>Set keySet():返回所有key构成的Set集合。</li><li>Collections values():返回所有value构成的Collection集合。</li><li>Set entrySet():返回所有key-value构成的Set集合</li></ul></li><li><p>==总结：常用方法==</p><ul><li><p>添加：put(Object key,Object value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除：remove(Object key)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove</span></span><br><span class="line">        Object remove = hashMap.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(remove);  <span class="comment">// Tom</span></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改：put(Object key,Object value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put2Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        hashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Jim&quot;</span>);</span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Jim, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询：get(Object key)</p></li><li><p>长度：size()</p></li><li><p>遍历：keySet() / values() / entrySet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        hashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap);  <span class="comment">// &#123;tt=546, 2=Tom, 564=Tom, 6=324&#125;</span></span><br><span class="line"></span><br><span class="line">        Set set = hashMap.keySet();</span><br><span class="line">        Collection values = hashMap.values();</span><br><span class="line">        Set set1 = hashMap.entrySet();</span><br><span class="line"></span><br><span class="line">        System.out.println(set);  <span class="comment">// [tt, 2, 564, 6]</span></span><br><span class="line">        System.out.println(values);  <span class="comment">// [546, Tom, Tom, 324]</span></span><br><span class="line">        System.out.println(set1);  <span class="comment">// [tt=546, 2=Tom, 564=Tom, 6=324]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol><li><p>==作为Map的主要实现类==；线程不安全，效率高；==存储null的key和value==</p></li><li><p>==<strong>底层实现原理：</strong>(jdk7)==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();<span class="comment">//在实例化以后，底层创建了一个长度为16的一维数组Entry[] table。</span></span><br><span class="line"><span class="comment">//...可能已经执行过多次put...</span></span><br><span class="line">map.put(key1,value1);<span class="comment">//首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值通过某种算法计算后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。---情况1</span></span><br><span class="line"><span class="comment">/*如果，此位置上的数据不为空，(意味着此位置上一个或多个数据(以链表形式存在))，比较key1与已经存在的一个或多个数据的哈希值：</span></span><br><span class="line"><span class="comment">    如果key1与已经存在的数据的哈希值都不相同，key1-value1添加成功。---情况2</span></span><br><span class="line"><span class="comment">    如果key1与已经存在的某个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较：</span></span><br><span class="line"><span class="comment">        equals()返回false，添加成功。---情况3</span></span><br><span class="line"><span class="comment">        equals()返回true，使用value1替换value2值。*/</span></span><br></pre></td></tr></table></figure></li><li><p>==补充==：</p><ul><li><p>情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p></li><li><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。</p></li><li><p>默认扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。</p></li></ul></li><li><p>==jdk8相较于jdk7在底层实现方面的不同==</p><ul><li>new HashMap()：底层没有创建一个长度为16的数组；</li><li>jdk8底层的数组是Node[]，而非Entry[]；</li><li>首次调用put()时，底层创建长度为16的数组；</li><li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</li><li>当某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组长度 &gt; 64 时，此索引位置上的的所有数据改为用红黑树存储。</li></ul></li><li><p>HashMap的存储结构</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118103319.png" alt="20201118103319" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118103404.png" alt="20201118103404" style="zoom: 50%;" /></li><li><p><strong>==几个常量值==</strong> —&gt; ==底层源码==</p><ul><li>DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75</li><li>threshold：扩容的临界值等于容量x填充因子：16*0.75 = 12</li><li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8</li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量：64</li><li>table：存储元素的数组，总是2的n次幂</li><li>entrySet：存储具体元素的集</li><li>size：HashMap中存储的键值对的数量</li><li>modCount：HashMap扩容和结构改变的次数</li><li>threshold：扩容的临界值 = 容量*填充因子</li><li>loadFactor：填充因子</li></ul></li><li><p><strong>==面试题==：</strong>谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？</p></li><li><p><strong>==面试题==：</strong>负载因子的值太小，对HashMap有什么影响？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">负载因子的大小决定了HashMap的数据密度。</span><br><span class="line">负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</span><br><span class="line">负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</span><br><span class="line">按照其他语言的参考及研究经验，会考虑将负载因子设置为<span class="number">0.7</span>~<span class="number">0.75</span>，此时平均检索长度接近于常数。</span><br></pre></td></tr></table></figure></li></ol><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ol><li><p>概述</p><ul><li>作为HashMap的子类</li><li>保证在遍历map元素时，可以按照添加的顺序实现遍历。<ul><li>原理：在原有的HashMap地层结构基础上，添加了一对指针，指向前一个和后一个元素。</li><li>对于频繁的遍历操作，此类执行效率高于HashMap。</li></ul></li></ul></li><li><p><strong>底层实现原理：</strong>(了解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">//能记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LinkedHashMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        linkedHashMap.put(<span class="number">2</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;tt&quot;</span>, <span class="number">546</span>);</span><br><span class="line">        linkedHashMap.put(<span class="number">6</span>, <span class="number">324</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;564&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(linkedHashMap);  <span class="comment">// &#123;2=Tom, tt=546, 6=324, 564=Tom&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        linkedHashMap.put(<span class="number">2</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashMap);  <span class="comment">// &#123;2=Jack, tt=546, 6=324, 564=Tom&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li><p>==保证按照添加的key-value对进行排序，实现遍历。此时考虑key的自然和定制排序==。==底层使用红黑树存储==。</p></li><li><p>向TreeMap中添加key-value，==要求key必须是由同一个类创建的对象==，因为要按照key进行自然排序、定制排序。</p><p>排序类似于之前的TreeSet。 ———&gt; ==同一个treeMap中的key的类型必须一致，意味着只能有仅只有一个类型的数据==</p></li><li><p>==TreeMap判断两个key相等的标准==：两个key通过compareTo()方法或者compare()方法返回0。———&gt; 因此涉及到了方法的重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line"></span><br><span class="line">        treeMap.put(<span class="string">&quot;fsad&quot;</span>, <span class="number">453</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;sad&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;J&quot;</span>, <span class="number">435</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(treeMap);  <span class="comment">// &#123;2=sad, J=435, fsad=453&#125;</span></span><br><span class="line"></span><br><span class="line">        treeMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;happy&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);  <span class="comment">// &#123;2=happy, J=435, fsad=453&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key的类型不一致，故而抛出异常</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * java.lang.ClassCastException: class java.lang.</span></span><br><span class="line"><span class="comment">         * String cannot be cast to class java.lang.Integer (java.lang.String </span></span><br><span class="line"><span class="comment">         * and java.lang.Integer are in module java.base of loader &#x27;bootstrap&#x27;)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object put = treeMap.put(<span class="number">3</span>, <span class="number">342</span>);</span><br><span class="line">        System.out.println(put);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li>作为Map古老的实现类(jdk1.0)；线程安全的，效率低；不能存储null的key和value。</li><li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。</li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序。</li><li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><p>Properties 类是 Hashtable 的子类，常用来处理配置文件。key和value都是Sting类型。</p></li><li><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</p></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="==Collections工具类=="></a>==Collections工具类==</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Collections 是一个操作 Set、List 和 Map 等集合的工具类。</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="==常用方法=="></a><strong>==常用方法==</strong></h3><ol><li><p>==排序操作：(均为非static方法)==</p><ul><li>reverse(List)：反转 List 中元素的顺序</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ul></li><li><p>==查找、替换==</p><ul><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)</li><li>Object min(Collection，Comparator)</li><li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li><li>void copy(List dest,List src)：将src中的内容复制到dest中</li><li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值</li></ul></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-28 11:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        arrayList.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">546</span>);</span><br><span class="line">        arrayList.add(<span class="number">324</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [Tom, 546, 324, Jack]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse</span></span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [Jack, 324, 546, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        Collections.swap(arrayList, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList);  <span class="comment">// [546, 324, Jack, Tom]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy</span></span><br><span class="line">        List&lt;Object&gt; arrayList1 = Arrays.asList(<span class="keyword">new</span> Object[arrayList.size()]);</span><br><span class="line"></span><br><span class="line">        System.out.println(arrayList1);  <span class="comment">// [null, null, null, null]</span></span><br><span class="line">        Collections.copy(arrayList1, arrayList);</span><br><span class="line">        System.out.println(arrayList1);  <span class="comment">// [546, 324, Jack, Tom]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>==同步控制==：</strong></p><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronizedXxx() </span></span><br><span class="line">List list = Collections.synchronizedList(arrayList); <span class="comment">// 返回的list为线程安全的</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><strong>补充：</strong>Enumeration</p><ul><li><p>Enumeration 接口是 Iterator 迭代器的 “古老版本”。</p><ul><li><p>hasMoreElements()</p></li><li><p>nextElement()</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration stringEnum = <span class="keyword">new</span> StringTokenizer(<span class="string">&quot;a-b*c-d-e-g&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stringEnum.hasMoreElements())&#123;</span><br><span class="line">    Object obj = stringEnum.nextElement();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==面试题==：Collection 和 Collections的区别？</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h2&gt;&lt;h3 id=&quot;集合与数组存储数据概述&quot;&gt;&lt;a href=&quot;#集合与数组存储数据概述&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十二章 泛型</title>
    <link href="https://asteroidcs.github.io/undefined/95b4.html"/>
    <id>https://asteroidcs.github.io/undefined/95b4.html</id>
    <published>2020-11-26T14:23:19.245Z</published>
    <updated>2020-12-10T13:19:07.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范型的理解"><a href="#范型的理解" class="headerlink" title="范型的理解"></a>范型的理解</h2><h3 id="为什么要有泛型"><a href="#为什么要有泛型" class="headerlink" title="为什么要有泛型?"></a>为什么要有泛型?</h3><ul><li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li><li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li></ul><h3 id="什么是范型？"><a href="#什么是范型？" class="headerlink" title="什么是范型？"></a>什么是范型？</h3><ul><li><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118121221.jpg" alt="20201118121221" style="zoom: 50%;" /></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/20201118121235.png" alt="20201118121235" style="zoom:50%;" /><ul><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</li></ul><h3 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h3><ul><li>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>，List<E>，ArrayList<E>  这个<E>就是类型参数，即泛型。</li></ul><h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><p>​    ==使用范型的时候，这个范型指的是基本数据类型，即&lt;&gt;中不能放int、double、float等，应该放它们的包装类==</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>使用范型之前的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//存放学生成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">90</span>);</span><br><span class="line">        list.add(<span class="number">86</span>);</span><br><span class="line">        <span class="comment">//问题一：；类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object score : list) &#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能会出现类型异常ClassCastException</span></span><br><span class="line">            <span class="keyword">int</span> stuScore = (Integer) score;</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用范型的情况：以ArrayList为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//存放学生成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">90</span>);</span><br><span class="line">        list.add(<span class="number">86</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：Iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用泛型的情况：以HashMap为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span></span><br><span class="line">        <span class="comment">//jdk新特性：类型推断</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        map.put(123,&quot;ABC&quot;);</span></span><br><span class="line">        <span class="comment">//泛型嵌套</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">            String key = e.getKey();</span><br><span class="line">            Integer value = e.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">：</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h4><ul><li>集合接口或集合类在<em>jdk5.0</em>时都修改为带泛型的结构</li><li>在实例化集合类时，可以指明具体的泛型类型</li><li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型<ul><li>比如：<em>add(E e) —&gt;<em>实例化以后：</em>add(Integer e)</em></li></ul></li><li>==注意点==：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li><li>如果实例化时，没指明泛型的类型。默认类型为<em>java.lang.Object</em>类型</li></ul><h2 id="自定义泛型类、泛型接口、泛型方法"><a href="#自定义泛型类、泛型接口、泛型方法" class="headerlink" title="自定义泛型类、泛型接口、泛型方法"></a><strong>自定义泛型类、泛型接口、泛型方法</strong></h2><ol><li><p>范型的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; 和 <span class="title">class</span> <span class="title">GenTest</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">其中，<span class="title">T</span>，<span class="title">K</span>，<span class="title">V</span>不代表值，而是表示类型。这里使用任意字母都可以。常用<span class="title">T</span>表示，是<span class="title">Type</span>的缩写</span></span><br></pre></td></tr></table></figure></li><li><p>范型的实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一定要在类名后面指定类型参数的值（类型）。如</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;Customer&gt; iterator = customers.iterator();</span><br><span class="line"><span class="comment">//T只能是累，不能用基本数据类型填充。但可以使用包装类填充</span></span><br><span class="line"><span class="comment">//把一个集合中的内容限制为一个制定的数据类型，这就是generics背后的核心思想</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ol><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String OrderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的内部结构就可以使用类的范型</span></span><br><span class="line">    T orderT;  <span class="comment">//这里的T目前不确定什么类型，实例化的时候才会确定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T orderT)</span> </span>&#123;</span><br><span class="line">        OrderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">        <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">        Order&lt;String&gt; stringOrder = <span class="keyword">new</span> Order&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">        stringOrder.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>==细节==<ul><li>范型类可能有多个参数，此时应该将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li><li>范型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass<E>(){}</li><li>实例话后，操作原来范型位置的结构必须与指定的范型类型一致</li><li>范型不同的引用不能相互赋值</li><li>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中</li><li>范型如果不指定，将被擦除，范型对应的类型均按照Object处理，但不等价于Object。经验：范型要使用一路都用。要不用，一路都不要用</li><li>如果范型结构是一个接口或抽象类，则不创建范型类的对象</li><li>Jdk1.7，范型的简化操作：ArrayList<Fruit> flist = new ArrayList&lt;&gt;()</li><li>范型的指定中不能使用基本数据类型，可以使用包装类替换</li><li>在类/接口上声明的范型，在本类或本接口中即代表某种类型，可以作为静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的范型</li><li>异常类不能是范型的</li><li>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capcity]；<ul><li>参考：ArrayList源码中声明：Object[] elementData，而非范型参数类型数组</li></ul></li><li>父类有范型，子类可以选择保留泛型也可以选择指定泛型类型<ul><li>子类不保留父类的泛型：按需实现</li><li>自类保留父类的泛型：泛型子类</li></ul></li></ul></li></ol><ul><li>==总结==：<ul><li>类的内部结构就可以使用类的范型</li><li>如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</li><li>要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型</li><li>由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型</li></ul></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ol><li><p>方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型，与类的泛型类没有任何关系</p></li><li><p>泛型方法的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常</span><br></pre></td></tr></table></figure></li><li><p>泛型方法声明泛型时也可以指定上限</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128184559793.png" alt="image-20201128184559793" style="zoom:50%;" /></li><li><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128184811944.png" alt="image-20201128184811944" style="zoom:50%;" /></li></ol><h2 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a><strong>泛型在继承上的体现</strong></h2><ul><li><p>泛型在继承方面的体现*</p><p>*    虽然类<em>A</em>是类<em>B</em>的父类，但是<em>G<A></em> 和*G<B><em>二者不具备子父类关系，二者是并列关系。</em></p><p>*    补充：类<em>A</em>是类<em>B</em>的父类，<em>A<G></em> 是 <em>B<G></em> 的父类</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Java/image-20201128194134097.png" alt="image-20201128194134097"  /></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h2><ol><li><p>使用类型==通配符:?==</p><ul><li>比如:List<?> ，Map<?,?></li><li>List&lt;?&gt;是List<String>、List<Object>等各种泛型List的父类</li></ul></li><li><p>读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object</p></li><li><p>对于List&lt;?&gt;不能向其内部添加数据——&gt;因为我们不知道c的元素类型，我们不能向其中添加对象</p><ul><li>唯一的例外是null，它是所有类型的成员</li></ul></li><li><p>将任意元素加入到其中不是类型安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">c.add(<span class="keyword">new</span> Object()); <span class="comment">// 编译时错误</span></span><br></pre></td></tr></table></figure></li><li><p>可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。</p></li><li><p>注意点</p><ul><li>不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用</li><li>不能用在泛型类的声明上</li><li>不能用在创建对象上，右边属于创建集合对象</li></ul></li><li><p>有限制条件的通配符</p><ul><li>通配符指定上限：上限extends:使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A:</span><br><span class="line">     G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span><br></pre></td></tr></table></figure><ul><li>通配符指定下限：下限super:使用时指定的类型不能小于操作的类，即&gt;=</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> A:</span><br><span class="line">     G&lt;? <span class="keyword">super</span> A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span><br></pre></td></tr></table></figure></li><li><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;? extends Number&gt;</span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line">  </span><br><span class="line">&lt;? <span class="keyword">super</span> Number&gt;</span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br><span class="line">  </span><br><span class="line">&lt;? extends Comparable&gt;</span><br><span class="line"><span class="comment">//只允许泛型为实现Comparable接口的实现类的引用调用</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;范型的理解&quot;&gt;&lt;a href=&quot;#范型的理解&quot; class=&quot;headerlink&quot; title=&quot;范型的理解&quot;&gt;&lt;/a&gt;范型的理解&lt;/h2&gt;&lt;h3 id=&quot;为什么要有泛型&quot;&gt;&lt;a href=&quot;#为什么要有泛型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇</title>
    <link href="https://asteroidcs.github.io/undefined/43fa.html"/>
    <id>https://asteroidcs.github.io/undefined/43fa.html</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:24:03.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java：贪吃蛇游戏笔记"><a href="#Java：贪吃蛇游戏笔记" class="headerlink" title="Java：贪吃蛇游戏笔记"></a>Java：贪吃蛇游戏笔记</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>创建一个窗体，用于游戏界面显示 ——&gt; 继承Java中的JFrame窗体类，设置自定义的参数</li><li>创建游戏棋盘，用于Snake移动 ——&gt; JPanel类的实例化，并且重写其中的 paint() 方法</li><li>采用链表的方式创建蛇身，移动以增删节点表示，头插法增加节点，方向采用头节点的横纵坐标加1添加节点</li><li>方向的改变用KeyListener来实现，每移动一次都需要重新绘制棋盘</li><li>蛇的运动采用timer调用timer task来反复执行蛇的移动</li><li>蛇撞墙：蛇头的横纵坐标超过了窗体的边界</li><li>蛇追尾：蛇头的坐标与其身体的任意节点坐标相等</li></ol><h2 id="创建窗体"><a href="#创建窗体" class="headerlink" title="创建窗体"></a>创建窗体</h2><ul><li><input disabled="" type="checkbox"> 创建一个MainFrame类继承JFrame，表示主窗口<ul><li>定义窗体的空参构造器，初始化窗体参数</li><li>初始化窗体参数的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义窗体的空参构造器，初始化窗体参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化窗体参数的方法</span></span><br><span class="line">        initFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> MainFrame类中写一个initFrame方法，初始化窗体参数：<ul><li>窗体标题：setTitle()</li><li>窗体尺寸：setSize()</li><li>窗体固定显示位置：setLocation()</li><li>窗体大小能否改变：setResizable()</li><li>窗体关闭按钮的作用：setDefaultCloseOperation()</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗体标题</span></span><br><span class="line">        setTitle(<span class="string">&quot;贪吃蛇&quot;</span>);</span><br><span class="line">        <span class="comment">//窗体尺寸</span></span><br><span class="line">        setSize(<span class="number">610</span>, <span class="number">640</span>);</span><br><span class="line">        <span class="comment">//固定窗体显示位置</span></span><br><span class="line">        setLocation(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置窗体大小不能改变</span></span><br><span class="line">        setResizable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//设置窗体关闭按钮的作用（退出程序）</span></span><br><span class="line">        setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在MainFrame中添加一个main方法，创建窗体并运行，就可以看到窗口了<ul><li>窗体类实例化</li><li>显示窗体</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗体类实例化</span></span><br><span class="line">        MainFrame mainFrame = <span class="keyword">new</span> MainFrame();</span><br><span class="line">        <span class="comment">//显示窗体</span></span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="创建游戏棋盘"><a href="#创建游戏棋盘" class="headerlink" title="创建游戏棋盘"></a>创建游戏棋盘</h2><ul><li><input disabled="" type="checkbox"> 在JFrame类中写一个initGamePanel方法，初始化游戏棋盘<ul><li>JPanel类实例化，并重写其中的paint方法 ——&gt; paint是用来绘制面板中的内容—棋盘格<ul><li>设置画笔的颜色：setColor（）</li><li>绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（）</li><li>绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）：drawLine（）</li></ul></li><li>将棋盘添加到窗体中：add( )</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//JPanel实例化，并重写其中的paint方法</span></span><br><span class="line">        JPanel jPanel = <span class="keyword">new</span> JPanel() &#123;</span><br><span class="line">            <span class="comment">//paint是用来绘制面板中的内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//g 相当于一个画笔，用于绘制</span></span><br><span class="line">                <span class="comment">//设置画笔的颜色</span></span><br><span class="line">                g.setColor(Color.BLACK);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//绘制棋盘</span></span><br><span class="line">                <span class="comment">//绘制40条横线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    g.drawLine(<span class="number">0</span>, i * <span class="number">15</span>, <span class="number">600</span>, i * <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制40条竖线（起点横坐标，起点纵坐标，终点横坐标，终点纵坐标）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">40</span>; j++) &#123;</span><br><span class="line">                    g.drawLine(j * <span class="number">15</span>, <span class="number">0</span>, j * <span class="number">15</span>, <span class="number">600</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将棋盘添加到窗体中</span></span><br><span class="line">        add(jPanel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="创建蛇的节点：用于构建蛇与食物"><a href="#创建蛇的节点：用于构建蛇与食物" class="headerlink" title="创建蛇的节点：用于构建蛇与食物"></a>创建蛇的节点：用于构建蛇与食物</h2><ul><li><input disabled="" type="checkbox"> 创建节点类：<ul><li>在棋盘上以横纵坐标创建一个节点</li><li>随机生成节点位置：用于随机生成食物  random()方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;  <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;  <span class="comment">// 纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成位置：用于随机生成食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成横坐标</span></span><br><span class="line">        <span class="keyword">this</span>.x = random.nextInt(<span class="number">40</span>);</span><br><span class="line">        <span class="comment">//随机生成纵坐标</span></span><br><span class="line">        <span class="keyword">this</span>.y = random.nextInt(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建蛇身：采用链表的方式构建蛇"><a href="#创建蛇身：采用链表的方式构建蛇" class="headerlink" title="创建蛇身：采用链表的方式构建蛇"></a>创建蛇身：采用链表的方式构建蛇</h2><ul><li><input disabled="" type="checkbox"> 多个节点构成蛇身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//蛇的身体</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; snakeBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化蛇身</span></span><br><span class="line">        initSnake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇身</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        snakeBody = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建节点，添加到集合中</span></span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">16</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">17</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">18</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">19</span>, <span class="number">20</span>));</span><br><span class="line">        snakeBody.add(<span class="keyword">new</span> Node(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title">getSnakeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snakeBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把🐍绘制到棋盘上"><a href="#把🐍绘制到棋盘上" class="headerlink" title="把🐍绘制到棋盘上"></a>把🐍绘制到棋盘上</h2><ul><li><input disabled="" type="checkbox"> 在MainFrame类中实现Snake类对象化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Snake snake; <span class="comment">//蛇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化蛇</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        snake = <span class="keyword">new</span> Snake();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在MainFrame类中的initGamePanel方法中写入绘制蛇身的代码<ul><li>绘制蛇身：fillRect（）——&gt;  绘制节点的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制蛇</span></span><br><span class="line">LinkedList&lt;Node&gt; body = snake.getSnakeBody();</span><br><span class="line"><span class="keyword">for</span> (Node node : body) &#123;</span><br><span class="line">    g.fillRect(node.getX() * <span class="number">15</span>, node.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="让蛇移动"><a href="#让蛇移动" class="headerlink" title="让蛇移动"></a>让蛇移动</h2><ul><li><input disabled="" type="checkbox"> 定义枚举类Direction，存放蛇移动的方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    UP, DOWN, LEFT, RIGHT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在Snake类中定义direction属性，用于控制蛇的运动方向，默认向左</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蛇的运动方向：默认向左</span></span><br><span class="line">    <span class="keyword">private</span> Direction direction = Direction.LEFT;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在Snake类中写一个move（）方法，控制蛇移动<ul><li>蛇会沿着蛇头的方向移动</li><li>控制蛇移动：蛇头添加节点，蛇尾删除节点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蛇会沿着蛇头的方向移动</span></span><br><span class="line">    <span class="comment">//控制蛇移动：蛇头添加节点，蛇尾删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">////获取蛇头</span></span><br><span class="line">        Node head = snakeBody.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最后的节点</span></span><br><span class="line">        snakeBody.removeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 采用定时器，在指定时间内调用蛇移动<ul><li>每次移动后都需要重新绘制棋盘</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> Timer timer; <span class="comment">//定时器，在指定时间内调用蛇移动的方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化定时器</span></span><br><span class="line">    initTimer();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//蛇移动</span></span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加键盘监听"><a href="#添加键盘监听" class="headerlink" title="添加键盘监听"></a>添加键盘监听</h2><ul><li><input disabled="" type="checkbox"> 设置键盘监听，让蛇随着上下左右移动，addKeyListener（）<ul><li>蛇的运动方向不能与当前方向相反 </li><li>每次按下方向键都会改变蛇的运动方向</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置键盘监听，让蛇随着上下左右移动</span></span><br><span class="line">    setKeyListener();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKeyListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addKeyListener(<span class="keyword">new</span> KeyAdapter() &#123;</span><br><span class="line">            <span class="comment">//当键盘按下时会自动调用此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//键盘中每一个键都有一个编号</span></span><br><span class="line">                <span class="keyword">switch</span> (e.getKeyCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_UP:  <span class="comment">// 上键</span></span><br><span class="line">                        <span class="comment">//修改蛇的运动方向不能与当前方向相反</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.DOWN) &#123;</span><br><span class="line">                            <span class="comment">//修改蛇的运动方向</span></span><br><span class="line">                            snake.setDirection(Direction.UP);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_DOWN:  <span class="comment">// 下键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.UP) &#123;</span><br><span class="line">                            snake.setDirection(Direction.DOWN);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_LEFT:  <span class="comment">//左键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.RIGHT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.LEFT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_RIGHT:  <span class="comment">// 右键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.LEFT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.RIGHT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;a</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加边界处理"><a href="#添加边界处理" class="headerlink" title="添加边界处理"></a>添加边界处理</h2><ul><li><input disabled="" type="checkbox"> 当蛇移动到边界处就游戏结束，把标记改为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//定义一个标记true表示蛇还活着，可以运动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLiving = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 判断蛇是否撞墙：头节点的坐标是否越界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">head = body.getFirst();</span><br><span class="line"><span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">  isLiving = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 判断蛇是否碰到自己的身体：头节点坐标与任意身体节点的坐标一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">  Node node = body.get(i);</span><br><span class="line">  <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">    isLiving = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 优化move( )代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLiving) &#123;</span><br><span class="line">            <span class="comment">//获取蛇头</span></span><br><span class="line">            Node head = body.getFirst();</span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEFT:</span><br><span class="line">                    <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RIGHT:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除最后的节点</span></span><br><span class="line">            body.removeLast();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">            head = body.getFirst();</span><br><span class="line">            <span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">                isLiving = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否碰到自己的身体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">                Node node = body.get(i);</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">                    isLiving = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="把食物绘制到棋盘上"><a href="#把食物绘制到棋盘上" class="headerlink" title="把食物绘制到棋盘上"></a>把食物绘制到棋盘上</h2><ul><li><input disabled="" type="checkbox"> 此处的食物就是节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> Node food; <span class="comment">//食物</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化食物</span></span><br><span class="line">    initFood();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     food = <span class="keyword">new</span> Node();</span><br><span class="line">     food.random();  <span class="comment">// food随机出现</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//绘制食物</span></span><br><span class="line">    g.fillRect(food.getX() * <span class="number">15</span>, food.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="吃食物"><a href="#吃食物" class="headerlink" title="吃食物"></a>吃食物</h2><ul><li><input disabled="" type="checkbox"> 吃食物：沿着蛇头的移动方向添加节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//吃食物：沿着蛇头的移动方向添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Node food)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取蛇头</span></span><br><span class="line">        Node head = snakeBody.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                snakeBody.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 吃食物：判断蛇头是否和食物重合，即头节点坐标与食物坐标一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//吃食物：判断蛇头是否和食物重合</span></span><br><span class="line">                Node head = snake.getSnakeBody().getFirst();</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123;</span><br><span class="line">                    snake.eat(food);</span><br><span class="line">                    food.random();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="MainFrame类"><a href="#MainFrame类" class="headerlink" title="MainFrame类"></a>MainFrame类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 窗体设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 7:31 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//java中有准备好的窗体类，继承即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Snake snake; <span class="comment">//蛇</span></span><br><span class="line">    <span class="keyword">private</span> JPanel jPanel; <span class="comment">//游戏棋盘</span></span><br><span class="line">    <span class="keyword">private</span> Timer timer; <span class="comment">//定时器，在指定时间内调用蛇移动的方法</span></span><br><span class="line">    <span class="keyword">private</span> Node food; <span class="comment">//食物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化窗体参数</span></span><br><span class="line">        <span class="keyword">this</span>.initFrame();</span><br><span class="line">        <span class="comment">//初始化游戏棋盘</span></span><br><span class="line">        <span class="keyword">this</span>.initGamePanel();</span><br><span class="line">        <span class="comment">//初始化蛇</span></span><br><span class="line">        <span class="keyword">this</span>.initSnake();</span><br><span class="line">        <span class="comment">//初始化食物</span></span><br><span class="line">        initFood();</span><br><span class="line">        <span class="comment">//初始化定时器</span></span><br><span class="line">        initTimer();</span><br><span class="line">        <span class="comment">//设置键盘监听，让蛇随着上下左右移动</span></span><br><span class="line">        setKeyListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建窗体对象，并显示</span></span><br><span class="line">        MainFrame mainFrame = <span class="keyword">new</span> MainFrame();</span><br><span class="line">        mainFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        food = <span class="keyword">new</span> Node();</span><br><span class="line">        food.random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKeyListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addKeyListener(<span class="keyword">new</span> KeyAdapter() &#123;</span><br><span class="line">            <span class="comment">//当键盘按下时会自动调用此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//键盘中每一个键都有一个编号</span></span><br><span class="line">                <span class="keyword">switch</span> (e.getKeyCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_UP:  <span class="comment">// 上键</span></span><br><span class="line">                        <span class="comment">//修改蛇的运动方向不能与当前方向相反</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.DOWN) &#123;</span><br><span class="line">                            <span class="comment">//修改蛇的运动方向</span></span><br><span class="line">                            snake.setDirection(Direction.UP);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_DOWN:  <span class="comment">// 下键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.UP) &#123;</span><br><span class="line">                            snake.setDirection(Direction.DOWN);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_LEFT:  <span class="comment">//左键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.RIGHT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.LEFT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> KeyEvent.VK_RIGHT:  <span class="comment">// 右键</span></span><br><span class="line">                        <span class="keyword">if</span> (snake.getDirection() != Direction.LEFT) &#123;</span><br><span class="line">                            snake.setDirection(Direction.RIGHT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//初始化定时任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                snake.move();</span><br><span class="line">                <span class="comment">//吃食物：判断蛇头是否和食物重合</span></span><br><span class="line">                Node head = snake.getBody().getFirst();</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == food.getX() &amp;&amp; head.getY() == food.getY())&#123;</span><br><span class="line">                    snake.eat(food);</span><br><span class="line">                    food.random();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重新绘制棋盘</span></span><br><span class="line">                jPanel.repaint();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每100毫秒，执行一次定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        snake = <span class="keyword">new</span> Snake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化游戏棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGamePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        jPanel = <span class="keyword">new</span> JPanel() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//清空棋盘</span></span><br><span class="line">                g.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Graphics g 相当于一个画笔，用于绘制</span></span><br><span class="line">                <span class="comment">//绘制横线</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    g.drawLine(<span class="number">0</span>, i * <span class="number">15</span>, <span class="number">600</span>, i * <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制竖线</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">40</span>; j++) &#123;</span><br><span class="line">                    g.drawLine(j * <span class="number">15</span>, <span class="number">0</span>, j * <span class="number">15</span>, <span class="number">600</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制蛇</span></span><br><span class="line">                LinkedList&lt;Node&gt; body = snake.getBody();</span><br><span class="line">                <span class="keyword">for</span> (Node node : body) &#123;</span><br><span class="line">                    g.fillRect(node.getX() * <span class="number">15</span>, node.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//绘制食物</span></span><br><span class="line">                g.fillRect(food.getX() * <span class="number">15</span>, food.getY() * <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把棋盘添加到窗体中</span></span><br><span class="line">        <span class="keyword">this</span>.add(jPanel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化窗体参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置窗体标题</span></span><br><span class="line">        <span class="keyword">this</span>.setTitle(<span class="string">&quot;贪吃蛇&quot;</span>);</span><br><span class="line">        <span class="comment">//设置窗体宽高</span></span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>, <span class="number">615</span>);</span><br><span class="line">        <span class="comment">//设置窗体位置</span></span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置关闭按钮的作用（退出程序）</span></span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//设置窗体大小不可变</span></span><br><span class="line">        <span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 节点类：每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:14 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成横坐标</span></span><br><span class="line">        <span class="keyword">this</span>.x = random.nextInt(<span class="number">40</span>);</span><br><span class="line">        <span class="comment">//随机生成纵坐标</span></span><br><span class="line">        <span class="keyword">this</span>.y = random.nextInt(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Snake类"><a href="#Snake类" class="headerlink" title="Snake类"></a>Snake类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  每一条蛇是由若干个节点组成，每一个节点有横纵坐标来确定位置，采用链表的方式构建蛇</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">    <span class="comment">//蛇的身体</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; body;</span><br><span class="line">    <span class="comment">//蛇的运动方向：默认向左</span></span><br><span class="line">    <span class="keyword">private</span> Direction direction = Direction.LEFT;</span><br><span class="line">    <span class="comment">//蛇是否活着</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLiving = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，在创建Snake对象时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化蛇身</span></span><br><span class="line">        initSnake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蛇身</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSnake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        body = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建节点，添加到集合中</span></span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">16</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">17</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">18</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">19</span>, <span class="number">20</span>));</span><br><span class="line">        body.add(<span class="keyword">new</span> Node(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//蛇会沿着蛇头的方向移动</span></span><br><span class="line">    <span class="comment">//控制蛇移动：蛇头添加节点，蛇尾删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLiving) &#123;</span><br><span class="line">            <span class="comment">//获取蛇头</span></span><br><span class="line">            Node head = body.getFirst();</span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEFT:</span><br><span class="line">                    <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RIGHT:</span><br><span class="line">                    <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                    body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除最后的节点</span></span><br><span class="line">            body.removeLast();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否撞墙</span></span><br><span class="line">            head = body.getFirst();</span><br><span class="line">            <span class="keyword">if</span> (head.getX() &lt; <span class="number">0</span> || head.getY() &lt; <span class="number">0</span> || head.getX() &gt;= <span class="number">40</span> || head.getY() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">                isLiving = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断蛇是否碰到自己的身体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; body.size(); i++) &#123;</span><br><span class="line">                Node node = body.get(i);</span><br><span class="line">                <span class="keyword">if</span> (head.getX() == node.getX() &amp;&amp; head.getY() == node.getY()) &#123;</span><br><span class="line">                    isLiving = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">getDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDirection</span><span class="params">(Direction direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//吃食物：沿着蛇头的移动方向添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Node food)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取蛇头</span></span><br><span class="line">        Node head = body.getFirst();</span><br><span class="line">        <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="comment">//在蛇头下边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX(), head.getY() + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                <span class="comment">//在蛇头左边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX() - <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                <span class="comment">//在蛇头上边添加一个节点</span></span><br><span class="line">                body.addFirst(<span class="keyword">new</span> Node(head.getX() + <span class="number">1</span>, head.getY()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Direction类"><a href="#Direction类" class="headerlink" title="Direction类"></a>Direction类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Snake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 8:53 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    UP, DOWN, LEFT, RIGHT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201208145319260.png" alt="image-20201208145319260" style="zoom: 67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java：贪吃蛇游戏笔记&quot;&gt;&lt;a href=&quot;#Java：贪吃蛇游戏笔记&quot; class=&quot;headerlink&quot; title=&quot;Java：贪吃蛇游戏笔记&quot;&gt;&lt;/a&gt;Java：贪吃蛇游戏笔记&lt;/h2&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="game" scheme="https://asteroidcs.github.io/categories/Java/game/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
    <category term="游戏" scheme="https://asteroidcs.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Java语言概述</title>
    <link href="https://asteroidcs.github.io/undefined/e28.html"/>
    <id>https://asteroidcs.github.io/undefined/e28.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:17:28.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识图解"><a href="#基础知识图解" class="headerlink" title="基础知识图解"></a>基础知识图解</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/766D3894-DEF8-4EDD-8F15-A13171BFFF33.png" alt="766D3894-DEF8-4EDD-8F15-A13171BFFF33"  /><h2 id="软件开发介绍"><a href="#软件开发介绍" class="headerlink" title="软件开发介绍"></a>软件开发介绍</h2><h3 id="基础常识"><a href="#基础常识" class="headerlink" title="基础常识"></a>基础常识</h3><ol><li>软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件<ul><li>系统软件：Windows，Mac os，linux，unix，android，iOS…</li><li>应用软件：word，ppt，画图板…</li></ul></li><li>人机交互方式：图形化界面 vs 命令行方式</li><li>应用程序 = 算法 ➕ 数据结构</li></ol><h3 id="常用的DOS指令"><a href="#常用的DOS指令" class="headerlink" title="常用的DOS指令"></a>常用的DOS指令</h3><ul><li>dir：列出当前目录下的文件以及文件夹</li><li>md：创建目录</li><li>rd；删除目录</li><li>cd：进入目录</li><li>cd..：返回到上一级目录</li><li>cd\：退回到根目录</li><li>del：删除文件</li><li>exit：推出dos命令行</li><li>ech javase&gt;：创建文件，如：ech javase&gt;1.doc，ech javase &gt; 1.jpg</li></ul><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li>⬅️ ➡️：移动光标</li><li>⬆️ ⬇️：调阅历史操作命令</li><li>Delete 和 Backspace：删除字符</li></ul><h3 id="计算机语言的发展迭代史"><a href="#计算机语言的发展迭代史" class="headerlink" title="计算机语言的发展迭代史"></a>计算机语言的发展迭代史</h3><ul><li><p>第一代：机器语言：指令以二进制代码形式存在</p><p>第二代：汇编语言：使用助记符表示一条机器指令</p><p>第三代：高级语言：</p><ul><li>面向过程：C、Pascal、Fortran</li><li>面向对象：Java、JS、Python、Scala…</li></ul></li></ul><h4 id="Java语言应用的领域"><a href="#Java语言应用的领域" class="headerlink" title="Java语言应用的领域"></a>Java语言应用的领域</h4><ul><li>Java Web开发：后台开发</li><li>大数据开发：</li><li>Android应用程序开发：客户端开发</li></ul><h3 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h3><ol><li>面向对象性： </li><li><ul><li>两个要素：类、对象</li><li>三个特征：封装、继承、多态</li></ul></li><li>健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏</li><li>跨平台型：write once，run anywhere：一次编译，到处运行</li><li>原理：只需要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM JAVA Virtual Machine）即可。由JVM来负责Java程序在该系统中的运行。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/2C3E0C74-6AE1-4F69-80A7-1587ABFECFC0.png" alt="2C3E0C74-6AE1-4F69-80A7-1587ABFECFC0"></p><h2 id="Java核心机制"><a href="#Java核心机制" class="headerlink" title="Java核心机制"></a>Java核心机制</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ul><li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器</li><li>对于不同的平台，由不同的虚拟机</li><li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li><li>java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/57F1EE3D-6203-4996-B532-87DC650C407D.png" alt="57F1EE3D-6203-4996-B532-87DC650C407D" style="zoom: 33%;" /><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>不再使用的内存空间应回收——垃圾回收</li><li>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预</li><li>Java程序==还会出现内存泄漏和内存溢出问题==</li></ul><h2 id="Java语言的环境搭建"><a href="#Java语言的环境搭建" class="headerlink" title="Java语言的环境搭建"></a>Java语言的环境搭建</h2><h3 id="什么是JDK，JRE"><a href="#什么是JDK，JRE" class="headerlink" title="什么是JDK，JRE"></a>什么是<strong>JDK</strong>，<strong>JRE</strong></h3><ol><li><p>JDK(Java Development Kit Java开发工具包)</p><ul><li><p>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了 JRE。所以安装了JDK，就不用在单独安装JRE了。</p><p>其中的开发工具:编译工具(javac.exe) 打包工具(jar.exe)等</p></li></ul></li><li><p>RE(Java Runtime Environment Java运行环境)</p><ul><li>包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等， 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li></ul></li></ol><h3 id="Java语言的环境搭建-JDK、JRE、JVM关系"><a href="#Java语言的环境搭建-JDK、JRE、JVM关系" class="headerlink" title="Java语言的环境搭建:JDK、JRE、JVM关系"></a><strong>Java</strong>语言的环境搭建:<strong>JDK</strong>、<strong>JRE</strong>、<strong>JVM</strong>关系</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207143107565.png" alt="image-20201207143107565" style="zoom: 33%;" /><h2 id="开发体验—-HelloWorld"><a href="#开发体验—-HelloWorld" class="headerlink" title="开发体验— HelloWorld"></a>开发体验— HelloWorld</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207143254624.png" alt="image-20201207143254624" style="zoom: 33%;" /><h2 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释(Comment)"></a>注释(Comment)</h2><h3 id="Java中的注释类型"><a href="#Java中的注释类型" class="headerlink" title="Java中的注释类型"></a>Java中的注释类型</h3><ul><li>//单行注释</li><li>/* <em>多行注释</em> */</li><li>/** <em>文档注释（Java特有）</em> **/</li></ul><h3 id="单行和多行注释的作用"><a href="#单行和多行注释的作用" class="headerlink" title="单行和多行注释的作用"></a>单行和多行注释的作用</h3><ol><li>对所写程序进行解释说明，增强可读性，方便自己和别人。</li><li>调试所写代码（注释掉不需要运行部分）。</li><li>特点：单行和多行注释掉的内容不参与编译，编译以后生成的.class文件中不包含注释掉的信息。</li></ol><h3 id="文档注释的使用"><a href="#文档注释的使用" class="headerlink" title="文档注释的使用"></a>文档注释的使用</h3><ol><li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</li><li>操作方式<ul><li>&gt;javadoc -d [生成文件名] -author -version [解析文件名.java]（-author和-version分别为注释当中@author和@version后面的内容）</li></ul></li></ol><ul><li><strong>注意：多行注释不能嵌套使用</strong></li></ul><h2 id="第1个Java代码"><a href="#第1个Java代码" class="headerlink" title="第1个Java代码"></a>第1个Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//arguments参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对第一个Java程序总结"><a href="#对第一个Java程序总结" class="headerlink" title="对第一个Java程序总结"></a>对第一个Java程序总结</h3><ol><li>java程序的编写-编译-运行的过程<ul><li>编写：我们将编写的java代码保存在以“.java”结尾的源文件中</li><li>编译：使用javac.exe来编译我们的java源文件。格式：javac 源文件名.java</li><li>运行：使用java.exe解释运行我们的字节码文件（.class)。格式：java 类名</li></ul></li><li>在一个java源文件中可以声明多个类（class），但是只能有一个类声明为public的，而且要求声明为public的类的类名必须与源文件名必须相同。</li><li>程序的入口是main()方法，格式是固定的。可以写成：public static void main(String[] args)或public static void main(String[] a)或public static void main(String a[])</li><li>输出语句<ul><li>System.out.println()：输出后换行，无内容则只换行</li><li>System.out.print()：输出后不换行</li></ul></li><li>每一个执行语句都以分号结尾，每个执行语句只要以分号隔开即使不换行也不影响执行</li><li>编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。</li></ol><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ol><li>java语言的特点是什么？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面向对象性：两个基本概念：类、对象；三大特性：封装、继承、多态</span><br><span class="line">健壮性：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</span><br><span class="line">跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”</span><br></pre></td></tr></table></figure><ol start="2"><li>System.out.println()和System.out.print()有什么区别？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前者输出内容后换行，后者输出后不换行。</span><br></pre></td></tr></table></figure><ol start="3"><li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：可以。但最多只有一个类名声明为<span class="keyword">public</span>，与文件名相同。</span><br></pre></td></tr></table></figure><ol start="4"><li>JDK,JRE和JVM的关系是什么？以及JDK、JRE包含的主要结构有哪些？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系：JDK包含JRE，JRE包含JVM</span><br><span class="line">JDK = JRE + Java开发工具（javac.exe、java.exe、javadoc.exe）</span><br><span class="line">JRD = JVM + Java核心类库</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础知识图解&quot;&gt;&lt;a href=&quot;#基础知识图解&quot; class=&quot;headerlink&quot; title=&quot;基础知识图解&quot;&gt;&lt;/a&gt;基础知识图解&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/asteroidcs/pic-go-cloud/raw/m</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第三章 数组</title>
    <link href="https://asteroidcs.github.io/undefined/4fb4.html"/>
    <id>https://asteroidcs.github.io/undefined/4fb4.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:19:12.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h2><ul><li>数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。</li></ul><h3 id="数组的常见概念"><a href="#数组的常见概念" class="headerlink" title="数组的常见概念"></a>数组的常见概念</h3><ol><li>数组名</li><li>标（或索引）</li><li>元素</li><li>数组的长度：元素的个数</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>数组是有序排列的；</li><li>数组属于引用数据类型，但是数组的元素既可以是基本数据类型，也可以是引用数据类型；</li><li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址；</li><li>数组的长度一旦确定，就不能修改；</li><li>可以通过下标（或索引）的方式调用指定位置的元素，速度很快。</li></ol><h3 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3><ol><li>按照维数：一维数组、二维数组……</li><li>按照数组元素类型分类：基本数据类型元素的素组、引用数据类型元素的数组。</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p></li><li><p>数据的存储结构：</p><ul><li><p>线性表：顺序表（比如：数组）、链表、栈、队列</p></li><li><p>树形结构：二叉树</p></li><li><p>图形结构：</p></li></ul></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>排序算法</li><li>搜（检索）索算法</li></ol><h2 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h2><h3 id="一维数组的声明和初始化"><a href="#一维数组的声明和初始化" class="headerlink" title="一维数组的声明和初始化"></a>一维数组的声明和初始化</h3><ol><li>声明：<code>int[] ins;</code></li><li>静态初始化：数组的初始化和数组的赋值操作同时进行。<ul><li><code>int ids = new int[]&#123;1001,1002,1003,1004&#125;;</code></li></ul></li><li>动态初始化：数组的初始化和数组的赋值操作分开进行<ul><li><code>String[] names = new String[5];</code></li></ul></li><li>错误写法<ul><li><code>int[] arr1 = new int[];</code></li><li><code>int[5] arr2 = new int[5];</code></li><li><code>int [] arr3 = new int[3]&#123;1,2,3&#125;;</code></li></ul></li><li>总结：数组一旦初始化完成，其长度就确定了。</li></ol><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定函数指定位置的函数<ul><li>通过索引（角标）的方式调用，索引（角标）从0开始，直到数组的长度-1结束</li></ul></li><li>如何获取数组的长度<ul><li>属性：length</li><li>使用：<code>names.length</code></li></ul></li><li>遍历数组<ul><li><code>for(int i = 0; i &lt; names.length; i++)&#123;&#125;</code></li></ul></li></ol><h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207154420142.png" alt="image-20201207154420142" style="zoom:33%;" /><h3 id="数组的内存解析"><a href="#数组的内存解析" class="headerlink" title="数组的内存解析"></a>数组的内存解析</h3><ol><li>栈（stack）：存放局部变量</li><li>堆（heap)：存放new出来的结构（对象数组）</li><li>方法区：常量池、静态域</li></ol><h4 id="内存的简化结构"><a href="#内存的简化结构" class="headerlink" title="内存的简化结构"></a>内存的简化结构</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207154613393.png" alt="image-20201207154613393" style="zoom: 33%;" /><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200802215212.png" alt="img" style="zoom: 67%;" /><ul><li>栈中的所有地址为Java虚拟机计算出来的哈希地址，并非真正的内存地址</li></ul><h2 id="多维数组的使用"><a href="#多维数组的使用" class="headerlink" title="多维数组的使用"></a>多维数组的使用</h2><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ol><li>理解：对于二维数组的理解，可以看成是一维数组array1的元素而存在。从数组底层的运行机制来看，其实没有多维数组。</li><li>二维数组的使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];<span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误情况</span></span><br><span class="line"></span><br><span class="line">String[][] arr4 = <span class="keyword">new</span> String[][<span class="number">4</span>];</span><br><span class="line">String[<span class="number">4</span>][<span class="number">3</span>] arr5 = <span class="keyword">new</span> String[][];</span><br><span class="line"><span class="keyword">int</span>[][] arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li>Tips：中括号（[]）的位置可以放在类名或者变量名后面；或者类名后面放一个，变量名后面放一个（二维数组）。</li><li>类型推断：<code>int[][] arr7 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;; //省略new int[][]</code></li></ul><h3 id="数组的基本操作-1"><a href="#数组的基本操作-1" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定位置的函数<ul><li><code>arry[i][j]; //第i行第j列的元素</code></li></ul></li><li>如何获取数组长度<ul><li><code>arr4.length;</code></li><li><code>arr4[0].length;</code></li></ul></li><li>如何遍历数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; a &lt;= arr4.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= arr4[i].length)&#123;</span><br><span class="line">        <span class="comment">//执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组元素的默认初始化值-1"><a href="#数组元素的默认初始化值-1" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><ol><li><p>规定：二维数组分为外层数组的元素和内层数组的元素</p><p><code>int[][] arr = new int[4][3];</code></p></li><li><p>外层元素：arr[0]，arr[1]等；</p></li><li><p>内层元素：arr[0][0]，arr[1][2]等；</p></li><li><p>初始化方式一：<code>int[][] arr = new int[4][3];</code></p><ul><li>外层元素的初始化值为：地址值</li><li>内层元素的初始化值：与一维数组初始化情况相同</li></ul></li><li><p>初始化方式二：<code>int[][] arr = new int[4][];</code></p><ul><li>外层元素的初始化值为：null</li><li>内层元素的初始化值为：不能调用，否则报错</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155151188.png" alt="image-20201207155151188" style="zoom: 67%;" /><h2 id="数组中涉及到的常见算法"><a href="#数组中涉及到的常见算法" class="headerlink" title="数组中涉及到的常见算法"></a>数组中涉及到的常见算法</h2><ol><li>数组元素的赋值（杨辉三角、回形书等）（面试常考）</li><li>求数值型数组中元素的最大值、最小值、平均数、总数等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求数值型数组中元素的最大值、最小值、平均数、总和等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-27        22:14:07</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            array[i] = (<span class="keyword">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        minValue = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / array.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n最大值为：&quot;</span> + maxValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值为：&quot;</span> + minValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数为：&quot;</span> + avg);</span><br><span class="line">        System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>数组的复制、反转、查找（线性查找、二分法查找）（面试会考）</p><ul><li><p>复制：通过遍历元素的方式进行复制操作，赋值只能使得新数组值相同一块内存区域，修改其中一个，原数组就得一起改变，相当于Linux中的硬链接</p></li><li><p>反转：通过中间变量实现反转</p></li><li><p>查找</p><ul><li>线性查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String dest = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定元素，位置为：&quot;</span> + i);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没找到！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二分法查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有要查找的数组必须有序</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dest1 = -<span class="number">34</span>;</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;<span class="comment">//初始首索引</span></span><br><span class="line"><span class="keyword">int</span> end = arr2.length - <span class="number">1</span>;<span class="comment">//初始末索引</span></span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (head + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(dest1 == arr2[mid])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + mid);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr2[mid] &gt; dest1)&#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;很遗憾，没有找到！&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组元素的排序算法（面试最常考）</p><ul><li>排序：假设含有n个记录的序列为(R1, R2,…, Rn)，其相应的关键字序列为(K1, K2,…, Kn)。将这些记录重新排序为(Ri1, Ri2,…, Rin)，使得相应的关键字满足条件Ki1 &lt;= Ki2 &lt;=…&lt;= Kin，这样的一种操作成为排序。<ul><li>通常来说，排序的目的是快速查找。</li></ul></li><li>衡量排序算法的优劣<ul><li>时间复杂度：分析关键字的比较次数和记录的移动次数。</li><li>空间复杂度：分析排序算法中徐需要多少辅助内存。</li><li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B先后次序保持不变，则称这种排序算法是稳定的。</li></ul></li></ul></li></ol><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><ol><li>内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。</li><li>十大内部排序算法（和具体语言无关），前八种较常用 (数据结构与算法中学)</li></ol><h3 id="各种排序算法的比较"><a href="#各种排序算法的比较" class="headerlink" title="各种排序算法的比较"></a>各种排序算法的比较</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155818904.png" alt="image-20201207155818904"  /><ol><li>从平均时间而言：快速排序最佳，但在最坏的情况下，时间性能不如堆排序和归并排序。</li><li>从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li><li>从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序。</li><li>从待排序的记录数n的大小看：n较小时，宜采用简单排序；而n较大时，宜采用改进排序。</li></ol><h3 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h3><ol><li>若n较小（如n≤50），可采用直接插入或直接选择排序。</li><li>当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。</li><li>若文件初始状态基本有序（正序），则应选用直接插入、冒泡或随机的快速排序为宜。</li><li>若n较大，则应采用时间复杂度为O（nlgn）的排序方法：快速排序、堆排序或归并排序</li></ol><h3 id="算法五大特征"><a href="#算法五大特征" class="headerlink" title="算法五大特征"></a>算法五大特征</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207155937296.png" alt="image-20201207155937296" style="zoom: 33%;" /><h2 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h2><ol><li>java.util.Arrays类即为操作数组的工具类，它包含了用来操作数组（比如排序和搜索）的各种方法。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160246169.png" alt="image-20201207160246169"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> java.util.Arrays：操作数组的共工具类，里面定义了很多操作数组的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-28        16:56:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isEquals = Arrays.equals(arr1,arr2);</span><br><span class="line">        System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.String toString(int[] a):输出数组信息</span></span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.void fill(int[] a,int val):将指定的值填充到数组中</span></span><br><span class="line">        Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.void sort(int[] a):对数组进行排序</span></span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.int binarySearch(int[] a,int key):对排序后的数组进行二分法检索指定的值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">333</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中常见的一异常"><a href="#数组中常见的一异常" class="headerlink" title="数组中常见的一异常"></a>数组中常见的一异常</h2><ul><li>注意：编译时不会报错</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160446090.png" alt="image-20201207160446090" style="zoom: 33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组的概述&quot;&gt;&lt;a href=&quot;#数组的概述&quot; class=&quot;headerlink&quot; title=&quot;数组的概述&quot;&gt;&lt;/a&gt;数组的概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组（Array），是多个==相同数据类型==按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Java基本语法</title>
    <link href="https://asteroidcs.github.io/undefined/2136.html"/>
    <id>https://asteroidcs.github.io/undefined/2136.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:19:19.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><h3 id="关键字（keyword）"><a href="#关键字（keyword）" class="headerlink" title="关键字（keyword）"></a>关键字（keyword）</h3><ol><li>定义：被Java语言赋予特殊含义，用作专门用途的字符（单词）。</li><li>特点：关键字中所有字母都为小写。</li><li>官方地址：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html</a></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207144700839.png" alt="image-20201207144700839" style="zoom: 33%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207144740355.png" alt="image-20201207144740355" style="zoom:33%;" /><h3 id="保留字（reserved-word）"><a href="#保留字（reserved-word）" class="headerlink" title="保留字（reserved word）"></a>保留字（reserved word）</h3><ul><li><p>ava保留字:现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字</p><p>goto 、const</p></li></ul><h2 id="标识符（Identifier）"><a href="#标识符（Identifier）" class="headerlink" title="标识符（Identifier）"></a>标识符（Identifier）</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ol><li>ava对各种变量、方法和类等要素命名时使用的字符序列称为标识符。</li><li>比如：类名、变量名、方法名、接口名、包名……</li><li>技巧：凡是自己可以取名字的地方都叫标识符。</li></ol><h3 id="定义合法标识符规则（必须遵守）"><a href="#定义合法标识符规则（必须遵守）" class="headerlink" title="定义合法标识符规则（必须遵守）"></a>定义合法标识符规则（必须遵守）</h3><ol><li>由26个英文字母大小写，0-9，_或$组成；</li><li>数字不可开头；</li><li>不可以使用关键字和保留字，但可以包含关键字和保留字；</li><li>Java中严格区分大小写，长度无限制；</li><li>标识符不能包含空格。</li></ol><h3 id="Java中名称命名规范（建议遵守）"><a href="#Java中名称命名规范（建议遵守）" class="headerlink" title="Java中名称命名规范（建议遵守）"></a>Java中名称命名规范（建议遵守）</h3><ol><li>包名：多单词组成时所有字母都小写：xxxyyyzzz；</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ；</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz；</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ；</li><li>注意<ul><li>注意1：在取名字时，为提高阅读性，要尽量有意义（见名知意）</li><li>注意2：Java采用unicode字符集，因此标识符也可以使用汉字声明，但不建议使用</li></ul></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h3><ol><li>内存中的一个存储区域；</li><li>该区域的数据可在同一类型范围内不断变化；</li><li>变量是程序中最基本的存储单元。包含变量类型（强类型：必须先声明）、变量名和存储的值。<ul><li>定义变量的格式：数据类型 变量名 = 变量值<ul><li>例：<code>int myAge = 18;</code></li></ul></li></ul></li></ol><h3 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h3><ol><li>ava中每个变量必须先声明，后使用；</li><li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了。“一对{}”即为一个作用域；</li><li>同一个作用域内，不能声明两个同名的变量。</li><li>Java定义的数据类型（按数据类型分）：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间</li></ol><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><ol><li>按数据类型：对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207145345147.png" alt="image-20201207145345147" style="zoom: 33%;" /><ul><li><p>(1) 数值型</p><ul><li><p>整数类型</p><ul><li><p>byte</p><ul><li>占用存储空间：1字节 = 8bit位</li><li>表数范围：-128~127（27），最高位为符号位（0正1负），故为7次方</li></ul></li><li><p>short</p><ul><li>占用存储空间：2字节</li><li>表数范围：-215~215-1</li></ul></li><li><p>int</p><ul><li>占用存储空间：4字节</li><li>表数范围：-231~231-1（约21亿）</li></ul></li><li><p>long</p><ul><li>占用存储空间：8字节</li><li>表数范围：-263~263-1</li></ul></li><li><p>==注意==</p><ul><li>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性</li><li>Java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’</li><li>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long </li></ul></li></ul></li><li><p>浮点类型</p><ul><li>单精度float<ul><li>占用存储空间：4字节</li><li>表数范围：-3.403E38~3.403E38</li></ul></li><li>双精度double<ul><li>占用存储空间：8字节</li><li>表数范围：-1.798E308~1.798E308</li></ul></li><li>注意：与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响</li><li>浮点型常量有两种表示形式<ul><li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li><li>科学计数法形式:如：5.12e2、512E2、100E-2</li></ul></li><li>float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求</li><li>double：双精度，精度是float的两倍。通常采用此类型</li><li>Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’</li><li>float表示的数值范围比long还大，是因为它使用科学计数法来计数，但是精度不够</li></ul></li></ul><p>(2) 字符型</p><ul><li>char<ul><li>1字符 = 2字节</li><li>声明或定义char型变量，通常使用一对单引号（’’），内部只能写一个字符</li><li>转义字符（例如：换行符\n、制表符\t、unicode编号等）</li></ul></li><li>布尔型<ul><li>boolean<ul><li>只能取两个值之一：true、false</li><li>常用于判断、循环结构</li><li>boolean类型数据只允许取值true和false，无null</li><li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同</li><li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替：true用1表示，false用0表示</li></ul></li></ul></li></ul></li><li><p>引用数据类型（reference type）</p><ul><li>类（class）</li><li>接口（interface）</li><li>数组（[]）</li></ul></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150009761.png" alt="image-20201207150009761"  /><h2 id="基本数据类型之间的运算规则"><a href="#基本数据类型之间的运算规则" class="headerlink" title="基本数据类型之间的运算规则"></a>基本数据类型之间的运算规则</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>这里只讨论7种基本数据类型变量间的运算，不包含boolean类型的。</li></ul><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3><ul><li>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150210307.png" alt="image-20201207150210307" style="zoom: 33%;" /><ul><li>多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。</li><li>byte、char、short三种类型变量做运算时，结果为int类型，即这三个变量之间的运算结果至少要拿一个int型去接收。原因：可能是防止溢出，并且整形常量默认类型为int型，运算时如果直接加减数字的话编译不通过。</li><li>boolean类型不能与其它数据类型运算。</li><li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。</li></ul><h3 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型:String"></a>字符串类型:<strong>String</strong></h3><ul><li>String不是基本数据类型，属于引用数据类型</li><li>使用方式与基本数据类型一致。例如:String str = “abcd”;</li><li>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。</li><li>使用时要加上强制转换符:()，但可能造成精度降低或溢出,格外要注意</li><li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207150718306.png" alt="image-20201207150718306" style="zoom: 33%;" /><ul><li>boolean类型不可以转换为其它的数据类型。</li></ul><h2 id="进制（了解内容）"><a href="#进制（了解内容）" class="headerlink" title="进制（了解内容）"></a>进制（了解内容）</h2><ul><li>所有数字在计算机底层都以二进制形式存在</li></ul><h3 id="整数的四种表示方式"><a href="#整数的四种表示方式" class="headerlink" title="整数的四种表示方式"></a>整数的四种表示方式</h3><ol><li>二进制(binary)：0,1 ，满2进1，以0b或0B开头；</li><li>十进制(decimal)：0-9 ，满10进1；</li><li>八进制(octal)：0-7 ，满8进1，以数字0开头表示；</li><li>十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0。</li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><ol><li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</li><li>二进制的整数有如下三种形式：<ul><li>原码：直接将一个数值换成二进制数。最高位是符号位。</li><li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li><li>负数的补码：其反码加1。</li><li>计算机以二进制补码的形式存所有的整数。<ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul></li></ul></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>概念：运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151105715.png" alt="image-20201207151105715" style="zoom: 33%;" /><ol><li>整形数相除后默认结果为整形<ul><li>需要精确结果进行运算前需要先进行类型转换（自动转换或者强制类型转换）</li></ul></li><li>取模（余）运算（%）<ul><li>结果符号与被模（除）数相同</li></ul></li><li>自增（减）<ul><li>（前）++：先自增1，后运算</li><li>（后）++：先运算，后自增1</li><li>自减（略）</li><li>注意：自增（减）不会改变变量本身数据类型</li></ul></li></ol><h3 id="赋值运算符（-）"><a href="#赋值运算符（-）" class="headerlink" title="赋值运算符（=）"></a>赋值运算符（=）</h3><ol><li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li><li>支持连续赋值<ul><li><code>int i1, j1;</code></li><li><code>i1 = j1 = 10;</code></li></ul></li></ol><h3 id="比较（关系）运算符"><a href="#比较（关系）运算符" class="headerlink" title="比较（关系）运算符"></a>比较（关系）运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151222679.png" alt="image-20201207151222679" style="zoom: 33%;" /><ol><li>比较运算符的运算结果都是boolean型，也就是要么是true，要么false</li><li>区分“=”和“==”</li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151301938.png" alt="image-20201207151301938" style="zoom:33%;" /><ol><li>区分逻辑与（&amp;）和短路与（&amp;&amp;）<ul><li>相同点：运算结果相同；党符号左边为true时，都会执行符号右边的内容</li><li>不同点：当左边为false时，&amp;&amp;不会执行符号右边的运算（短路）</li><li>开发中优先使用短路与（&amp;&amp;）</li></ul></li><li>区分逻辑或（|）和短路或（||）<ul><li>相同点：运算结果相同；当符号右边为false时，二者都会执行符号右边的内容</li><li>不同点：当符号左边为true时，|| 不会执行符号右边的运算（短路）</li><li>开发中优先使用短路或（||）</li></ul></li><li>逻辑非（!）</li><li>逻辑异或（^）<ul><li>相同为true，不同为false</li></ul></li></ol><h3 id="位运算符（用得较少）"><a href="#位运算符（用得较少）" class="headerlink" title="位运算符（用得较少）"></a>位运算符（用得较少）</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151342011.png" alt="image-20201207151342011" style="zoom:33%;" /><h4 id="位运算符细节："><a href="#位运算符细节：" class="headerlink" title="位运算符细节："></a><strong>位运算符细节：</strong></h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151420395.png" alt="image-20201207151420395" style="zoom:33%;" /><ol><li>位运算符是直接对整数的二进制进行的运算</li><li>位运算符操作的都是整形的数据</li><li>&lt;&lt;：在一定范围内，每向左移n位，相当于*2n</li><li>&gt;&gt;：在一定范围内，每向右移n位，相当于/2n<ul><li>面试题：如何最高效的计算2*8？<ul><li>2 &lt;&lt; 3 或 8 &lt;&lt; 1</li></ul></li><li>注意：无&lt;&lt;&lt;</li></ul></li><li>&amp;、|、^运算</li></ol><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ol><li>格式：</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151612571.png" alt="image-20201207151612571"></p><ul><li>条件表达式的结果为boolean类型</li><li>表达式1和表达式2为<strong>同种类型</strong></li><li>三元运算符可嵌套使用</li></ul><ol start="2"><li>三元运算符与if-else的联系与区别<ul><li>三元运算符可简化if-else语句，因此能用三元运算符的地方尽量用三元运算符</li><li>三元运算符要求必须返回一个结果</li><li>if后的代码块可有多个语句</li><li>凡是可以使用三元运算符的地方都可以改写成if-else，反之则不一定行</li></ul></li><li>练习：获取3个数中的最大值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max1 = (a &gt; b)? a : b;</span><br><span class="line"><span class="keyword">int</span> max2 = (max1 &gt; c)? max1 : c;</span><br></pre></td></tr></table></figure><h3 id="运算符的优先等级"><a href="#运算符的优先等级" class="headerlink" title="运算符的优先等级"></a>运算符的优先等级</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207151825396.png" alt="image-20201207151825396" style="zoom: 50%;" /><ol><li>运算符有不同优先级，所谓优先级就是表达式 运算中的运算顺序</li><li>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</li></ol><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块</li></ul><h3 id="如何从键盘-控制台获取不同类型的变量：需要使用Scanner类"><a href="#如何从键盘-控制台获取不同类型的变量：需要使用Scanner类" class="headerlink" title="如何从键盘/控制台获取不同类型的变量：需要使用Scanner类"></a>如何从键盘/控制台获取不同类型的变量：需要使用Scanner类</h3><ol><li>导包：<code>import java.util.Scanner;</code></li><li>Scanner的实例化：<code>Scanner scan = new Scanner(System.in);</code></li><li>调用Scanner的相关方法，来获取指定类型的变量。</li><li>对于char类型的获取，Scanner没有提供相关的方法，只能获取一个字符串。</li><li>如果一定要获取char类型，可用charAt(0)获取字符串索引为0位置上的字符。</li></ol><ul><li>注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配，则出现异常：InputMisMatchException，导致程序中断。容量小的可自动提升；</li></ul><h3 id="如何获取随机数"><a href="#如何获取随机数" class="headerlink" title="如何获取随机数"></a>如何获取随机数</h3><ul><li><code>double value = Math.random()</code>：返回一个[0.0, 1.0)之间的double型的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取[a,b]之间的<span class="keyword">int</span>型随机数：(<span class="keyword">int</span>)(Math.random() * (b - a + <span class="number">1</span>) + a)</span><br></pre></td></tr></table></figure><h3 id="流程控制方式结构化程序设计中规定的三种基本流程结构"><a href="#流程控制方式结构化程序设计中规定的三种基本流程结构" class="headerlink" title="流程控制方式结构化程序设计中规定的三种基本流程结构"></a>流程控制方式结构化程序设计中规定的三种基本流程结构</h3><ol><li>顺序结构<ul><li>程序从上到下逐行执行，中间没有任何判断和跳转</li></ul></li><li>分支结构<ul><li>根据条件，选择性地执行某段代码</li><li>有if-else和switch-case两种分支语句</li></ul></li><li>循环结构<ul><li>根据循环条件，重复性地执行某段代码</li><li>有while、do…while、for三种循环语句</li><li>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素</li></ul></li></ol><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h4 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h4><ol><li>第一种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二选一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>多选一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">执行表达式n</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用说明</p><ul><li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。</li><li>语句块只有一条执行语句时，一对{}可以省略，<strong>但建议保留</strong></li><li>if-else语句结构，根据需要可以嵌套使用（一般不超过3层，超过3层未解决则停下来想其他办法）。</li><li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。</li><li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。</li><li>当多个条件是“包含”关系时，“小上大下 /子上父下”。</li><li>if (80 &lt; core &lt;= 99)报错原因：前面的(80 &lt; core)的结果为一个boolean类型，boolean类型不能与int类型做大小关系对比。</li></ul></li><li><p>针对于条件表达式：</p><ul><li>如果多个表达式之间是”互斥“关系（或没有交集的关系），判断和执行语句的上下顺序不影响。</li><li>如果多个表达式之间有交集的关系，则需要根据实际情况来决定哪个声明在上面。</li><li>如果多个表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则范围小的就没机会执行了。</li><li>就近原则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//上述语句相当于：</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//以上误判源于省略了单行执行语句的&#123;&#125;，所以尽量不要省略&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h4><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207152637213.png" alt="image-20201207152637213" style="zoom: 33%;" /><ol><li><p>说明：</p><ul><li>根据switch表达式中的值，依次匹配各个case中的常量。一旦配成功，则进入相应的case结构中，调用其执行语句，当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</li><li>break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。</li><li>switch结构中的表达式，只能是如下六种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。</li><li>case之后只能声明常量，尤其不能是一个范围。</li><li>break关键字是可选的。</li><li>default：相当于if-else中的else，也是可选的，且default位置是可选的，一般还是写在末尾。</li><li>如果switch-case结构中多个case的执行语句相同，则可以考虑进行合并，即写完多行执行语句相同的case以后只写1行执行语句。</li><li>凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。</li><li>写分支结构时，如果既可以使用if-else，又可以使用switch-case（switch中表达式的取值情况不太多），优先选择使用switch-case。原因：switch-case执行效率稍高。</li></ul></li><li><p>示例：输入日期，返回日期是那一年的第几天。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDays</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入月份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> month = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入日期：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> day = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (month)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                days += <span class="number">29</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                days += <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            days += day;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span> + year +<span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;号是&quot;</span> + year + <span class="string">&quot;年的第&quot;</span> + days + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;\n输入有误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol><li><p>在某些条件满足得情况下，反复执行特定代码的功能</p></li><li><p>循环语句的四个组成部分</p><ul><li><p>初始化部分（init_statement）</p></li><li><p>循环条件部分（test_exp）–&gt; boolean类型</p></li><li><p>循环体部分（body_statement）</p></li><li><p>迭代部分（alter_statement）</p></li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207152959974.png" alt="image-20201207152959974" style="zoom: 67%;" /><ol start="3"><li><p>通常情况下，循环结束都是因为②中循环条件返回了false</p><ul><li><p>循环语句分类</p><ul><li>for循环</li><li>结构</li></ul></li><li><p>for(① ; ② ; ④){</p><p> ③</p><p>}</p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt; 直到②不再返回true，跳出循环</p></li><li><p>例题：遍历100以内的偶数，输出所有偶数的和，输出所有偶数的个数。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErgodicEvenNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                count += <span class="number">1</span>;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;0-100内偶数有&quot;</span> + count + <span class="string">&quot;个，它们的和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i在for循环内有效，出了for循环就失效了</span></span><br></pre></td></tr></table></figure><ul><li>例题：输入两个正整数m和n，求其最大公约数和最小公倍数。比如，12和20的最大公约数是4，最小公倍数是60。<ul><li>说明break的作用：跳出循环体</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetGcdLcm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入第二个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> min = (m &lt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\n&quot;</span> + m + <span class="string">&quot;和&quot;</span> + n + <span class="string">&quot;的最大公约数为&quot;</span> + i + <span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = (m &gt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &lt;= m * n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % m == <span class="number">0</span> &amp;&amp; i % n == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最小公倍数为&quot;</span> + i + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>while循环</p><ul><li>结构</li></ul><p><code>①初始化部分</code></p><p><code>while(②循环条件部分)&#123;</code></p><p> <code>③循环体部分;</code></p><p> <code>④迭代部分;</code></p><p><code>&#125;</code></p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt;②</p><ul><li>说明<ul><li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li><li>for循环和while循环可以相互转换</li><li>for循环和while循环初始化条件的作用范围不同。</li><li>i 出了while循环后可以继续使用，原因：①初始化部分在循环外。</li></ul></li></ul></li><li><p>do-while</p><ul><li><p>结构</p><p><code>①</code></p><p><code>do&#123;</code></p><p><code>③；</code></p><p><code>④；</code></p><p><code>&#125;while(②)；</code></p><p>执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② …… -&gt;②</p></li><li><p>特点</p><ul><li>先执行再判断，至少执行一次循环体。</li><li>开发中较少使用do-while，for和while使用较多。</li></ul></li></ul></li></ol><p>循环语句综合题：从键盘输入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时，结束程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CirCom</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> negNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> alter = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (alter &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                posNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (alter &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的正数个数为：&quot;</span> + posNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的负数个数为：&quot;</span> + negNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>while(true)就相当于for(;;)</li><li>结束循环的几种方式<ul><li>循环条件部分返回false；</li><li>在循环体中执行break。</li></ul></li></ul></li></ul><ol start="7"><li>嵌套循环<ul><li>嵌套循环的使用<ul><li>嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环。</li><li>外层循环：循环结构B。</li><li>内层循环：循环结构A。</li></ul></li><li>说明<ul><li>内层循环结构遍历一遍，只相当于外层循环结构循环一次。</li><li>假设外层循环需要执行m次，内层循环需要执行n次，此时内存层循环的循环体需要执行m*n次。</li></ul></li><li>技巧：外层循环控制行数，内层循环控制列数。</li></ul></li></ol><p>例题1：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiTable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印几行？（1-9）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> line = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot;x&quot;</span> + j + <span class="string">&quot;=&quot;</span> + i * j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题2：100以内所有质数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)        &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//获取当前时间距1970-01-01 00:00:00的毫秒数（long型）</span></span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="comment">//for (int j = 2; j &lt; i; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++)&#123;<span class="comment">//优化二：一个数如果在2到它本身开方的范围内没有商，则为质数</span></span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//优化一：只对本身非质数的自然数是有效的。加break前后对比：20181ms/2174ms = 9.28</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;质数的个数：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;所花费的时间：&quot;</span> + (start - end));</span><br><span class="line">        <span class="comment">//优化前：17916ms 优化一：1629ms 优化二：16ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊关键字的使用"><a href="#特殊关键字的使用" class="headerlink" title="特殊关键字的使用"></a>特殊关键字的使用</h3><ol><li>break<ul><li>使用范围：switch-case、循环结构中</li><li>循环中使用的作用：结束当前循环</li><li>默认跳出包裹此关键字最近的一层循环</li><li>结束指定标识的一层循环结构</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>continue</p><ul><li><p>使用范围：循环结构中</p></li><li><p>循环中使用的作用：结束当次循环</p></li><li><p>结束指定标识的一层循环结构的当次循环</p><p><code>countinue label;</code></p></li></ul></li></ol><ul><li>注意：以上两个关键字后面不能声明执行语句</li></ul><ol start="3"><li><p>return</p><ul><li>并非专门用于结束循环的，它的的功能是结束一个方法。当一个方法执行到一个return时，这个方法将被结束。</li><li>与break、continue不同的是吗，return直接结束整个方法，不管这个return处于多少层循环之内。</li></ul></li><li><p>补充：衡量一个功能代码的优劣</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关键字与保留字&quot;&gt;&lt;a href=&quot;#关键字与保留字&quot; class=&quot;headerlink&quot; title=&quot;关键字与保留字&quot;&gt;&lt;/a&gt;关键字与保留字&lt;/h2&gt;&lt;h3 id=&quot;关键字（keyword）&quot;&gt;&lt;a href=&quot;#关键字（keyword）&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第四章 面向对象（中）</title>
    <link href="https://asteroidcs.github.io/undefined/df1b.html"/>
    <id>https://asteroidcs.github.io/undefined/df1b.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-11T02:55:42.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OOP特征二：继承性"><a href="#OOP特征二：继承性" class="headerlink" title="OOP特征二：继承性"></a>OOP特征二：继承性</h2><h3 id="继承性的好处"><a href="#继承性的好处" class="headerlink" title="继承性的好处"></a>继承性的好处</h3><ol><li>减少代码冗余，提高了代码的复用性；</li><li>便于功能的扩展；</li><li>为之后多态性的使用，提供了前提。</li></ol><h3 id="继承性的格式：class-A-extends-B"><a href="#继承性的格式：class-A-extends-B" class="headerlink" title="继承性的格式：class A extends B{}"></a>继承性的格式：class A extends B{}</h3><ol><li>A：子类、派生类、subclass</li><li>B：父类、超类、基类、superclass</li><li>体现：一旦子类A继承父类B后，子类A就获取了父类B中所有的属性和方法。</li><li>特别地：父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</li><li>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展，扩展。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211095736330.png" alt="image-20201211095736330" style="zoom: 50%;" /><h3 id="Java中关于继承性的规定"><a href="#Java中关于继承性的规定" class="headerlink" title="Java中关于继承性的规定"></a>Java中关于继承性的规定</h3><ol><li>一个类可以被多个子类继承；</li><li>Java中类的单继承性：一个类只能有一个父类；</li><li>子类是相对概念；</li><li>子类直接继承的父类称为直接父类，间接继承的父类称为间接父类；</li><li>子类继承父类以后就获取了直接父类以及所有间接父类声明的属性和方法。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211095831287.png" alt="image-20201211095831287" style="zoom: 33%;" /><h3 id="java-lang-Object类的理解"><a href="#java-lang-Object类的理解" class="headerlink" title="java.lang.Object类的理解"></a>java.lang.Object类的理解</h3><ol><li>如果没有显式地声明一个类的父类的话，则此类继承于java.lang.Object类；</li><li>所有的Java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类；</li><li>意味着，所有的Java类具java.lang.Object类声明的功能。</li></ol><h2 id="Debug（调试）"><a href="#Debug（调试）" class="headerlink" title="Debug（调试）"></a>Debug（调试）</h2><h3 id="如何调试程序"><a href="#如何调试程序" class="headerlink" title="如何调试程序"></a>如何调试程序</h3><ol><li><p>System.out.println()；</p></li><li><p>Eclipse - Debug</p><ul><li>设置断点（可设置多个断点）</li><li>debug as java application</li><li>常用操作</li></ul><table><thead><tr><th align="center">操作</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">step into 跳入（F5）</td><td align="center">进入当前所调用的方法中</td></tr><tr><td align="center">step over 跳过（F6）</td><td align="center">执行完当前语句进入下一行</td></tr><tr><td align="center">step return 跳回（F7）</td><td align="center">执行完当前所在方法，进入下一行</td></tr><tr><td align="center">drop to frame</td><td align="center">回到当前行所在方法的第一行</td></tr><tr><td align="center">resume 恢复</td><td align="center">执行完当前所在断点的所有代码，进入下一个断点，如果没有就结束</td></tr><tr><td align="center">Terminate 终止</td><td align="center">停止JVM，后面的程序不会再执行</td></tr></tbody></table></li></ol><h2 id="方法的重写（override-overwrite）"><a href="#方法的重写（override-overwrite）" class="headerlink" title="方法的重写（override/overwrite）"></a>方法的重写（override/overwrite）</h2><h3 id="概念及使用"><a href="#概念及使用" class="headerlink" title="概念及使用"></a>概念及使用</h3><ol><li><p>重写：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在执行程序时，子类的方法将覆盖父类的方法。</p></li><li><p>重写以后，当创建子类对象以后，通过子类对象调用父类中的同名参数的方法时，实际执行的是子类重写父类的方法。</p></li><li><p>方法的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写规定：</p><p>约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法</p><ul><li> 重写与被重写方法名以及形参列表相同</li><li>重写重写方法的权限修饰符必须不小于被重写方法的权限修饰符<ul><li>特殊情况：子类不能重写父类中权限为private的方法</li></ul></li><li>返回值类型：<ul><li>父类被重写方法的返回值类型是void，则子类重写方法的返回值类型只能是void；</li><li>父类被重写方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类；</li><li>父类被重写方法的返回值类型是基本数据类型（比如double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）；</li></ul></li><li>子类重新写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。（具体放到异常处理再讲）</li></ul></li><li><p>==子类和父类中同名同参数的要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写）==</p></li></ol><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.override;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 方法重写练习--父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-14    15:19:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;走路，走的距离是&quot;</span> + distance + <span class="string">&quot;公里。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.override;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 方法重写练习--子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-14    15:24:49</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String major;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习。专业是：&quot;</span> + major);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对父类中的eat()方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生应该多吃有营养的事食物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.override;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 方法重写练习--测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-14    15:28:22</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;计算机科学与技术&quot;</span>);</span><br><span class="line">        s.eat();</span><br><span class="line">        s.walk(<span class="number">10</span>);</span><br><span class="line">        s.study();</span><br><span class="line">        </span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>​    区分方法的重载与重写 (高频题) ?</p><ol><li> 二者概念：</li><li>重载和重写的具体规则：</li><li> 重载不表现为多态性，重写表现为多态性。</li></ol><h2 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h2><ol><li>Java权限修饰符public、protected、 (缺省)、 private置于==类的成员==定义前，用来限定对象对该类成员的访问权限</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211100925653.png" alt="image-20201211100925653" style="zoom: 33%;" /><ol start="2"><li><p>对于class的权限修饰只可以用public和default(缺省)</p><ul><li>public类可以在任意地方被访问</li><li>default类只可以被同一个包内部的类访问</li></ul></li><li><p>访问控制举例</p><ul><li>创建一个Order类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.fourpermissionmodifiers;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 体会4种不同的权限修饰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-14    18:23:20</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderPrivate;</span><br><span class="line">    <span class="keyword">int</span> orderDefault;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> orderProtected;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> orderPublic;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderPrivate = <span class="number">1</span>;</span><br><span class="line">        orderDefault = <span class="number">1</span>;</span><br><span class="line">        orderProtected = <span class="number">1</span>;</span><br><span class="line">        orderPublic = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderPrivate = <span class="number">2</span>;</span><br><span class="line">        orderDefault = <span class="number">2</span>;</span><br><span class="line">        orderProtected = <span class="number">2</span>;</span><br><span class="line">        orderPublic = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderPrivate = <span class="number">3</span>;</span><br><span class="line">        orderDefault = <span class="number">3</span>;</span><br><span class="line">        orderProtected = <span class="number">3</span>;</span><br><span class="line">        orderPublic = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderPrivate = <span class="number">4</span>;</span><br><span class="line">        orderDefault = <span class="number">4</span>;</span><br><span class="line">        orderProtected = <span class="number">4</span>;</span><br><span class="line">        orderPublic = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个包中的其他类，不可以调用Order类中私有的属性、方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.fourpermissionmodifiers;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 4种不同的权限修饰测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-14    18:30:38</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        </span><br><span class="line">        order.orderDefault = <span class="number">2</span>;</span><br><span class="line">        order.orderProtected = <span class="number">3</span>;</span><br><span class="line">        order.orderPublic = <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">        order.methodDefault();</span><br><span class="line">        order.methodProtected();</span><br><span class="line">        order.methodPublic();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        同一个包中的其他类，不可以调用Order类中私有的属性、方法</span></span><br><span class="line"><span class="comment">//        order.orderPrivate = 1;</span></span><br><span class="line"><span class="comment">//        order.methodPrivate();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.fourpermissionmodifiers.suborder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.triabin.fourpermissionmodifiers.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderProtected = <span class="number">1</span>;</span><br><span class="line">        orderPublic = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        methodProtected();</span><br><span class="line">        methodPublic();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法。</span></span><br><span class="line"><span class="comment">//        orderDefault = 3;</span></span><br><span class="line"><span class="comment">//        orderPrivate = 4;</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        methodDefault();</span></span><br><span class="line"><span class="comment">//        methodPrivate();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.fourpermissionmodifiers.suborder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.triabin.fourpermissionmodifiers.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.orderPublic = <span class="number">1</span>;</span><br><span class="line">        order.methodPublic();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法。</span></span><br><span class="line"><span class="comment">//        order.orderPrivate = 2;</span></span><br><span class="line"><span class="comment">//        order.orderDefault = 3;</span></span><br><span class="line"><span class="comment">//        order.orderProtected = 4;</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        order.methodPrivate();</span></span><br><span class="line"><span class="comment">//        order.methodDefault();</span></span><br><span class="line"><span class="comment">//        order.methodProtected();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="关键字：super"><a href="#关键字：super" class="headerlink" title="关键字：super"></a>关键字：super</h2><h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><ol><li>super理解为：父类</li><li>super可以用来调用：属性、方法、构造器；</li><li>super的使用：调用属性和方法<ul><li>我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”；</li><li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须是显示的使用“super.属性”的方式，表明调用的是父类中声明的属性；</li><li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须是显示的使用“super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul></li><li>uper的使用：调用构造器<ul><li>我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的构造器；</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行；</li><li>我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现</li><li>在子类构造器的首行，没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用父类中空参的构造器：super()；</li><li>在类的多个构造器中，至少有一个类的构造器中是用来了“super(形参列表)”，调用父类中的构造器。</li></ul></li></ol><h3 id="super关键字举例"><a href="#super关键字举例" class="headerlink" title="super关键字举例"></a>super关键字举例</h3><ol><li>父类Person</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//身份证号</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用父类中空参的构造器：super()。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>子类Student</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String major;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1002</span>;<span class="comment">//学号</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,String major)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this.name = name;</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line">        <span class="keyword">super</span>(name,age);<span class="comment">//调用父类中形参列表相同的构造器</span></span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生：多吃有营养的食物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生：学习知识&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.eat();</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;,age = &quot;</span> + <span class="keyword">super</span>.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + <span class="keyword">this</span>.id);</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + <span class="keyword">super</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试类SuperTest</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        s.study();</span><br><span class="line">        </span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;Triabin&quot;</span>,<span class="number">18</span>,<span class="string">&quot;IT&quot;</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;****************************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>结果</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200815231303.png" alt="img" style="zoom: 50%;" /><h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a><strong>this</strong>和super的区别</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211101746937.png" alt="image-20201211101746937" style="zoom:33%;" /> <h2 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h2><ol><li>从结果上来看：（继承性）<ul><li>子类继承父类以后，就获取了父类中声明的属性和方法；</li><li>创建的子类的对象，在堆空间中，就会加载所有父类中声明的属性。</li></ul></li><li>从过程上来看：<ul><li>但我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象才可以调用。</li></ul></li><li>明确：虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象。</li></ol><h2 id="OOP特征三：多态性"><a href="#OOP特征三：多态性" class="headerlink" title="OOP特征三：多态性"></a>OOP特征三：多态性</h2><h3 id="基本概念和规则"><a href="#基本概念和规则" class="headerlink" title="基本概念和规则"></a>基本概念和规则</h3><ol><li><p>理解多态性：可以理解为事物的多种形态。</p></li><li><p>何为多态：</p><ul><li>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用）</li></ul></li><li><p>多态的使用：虚拟方法调用</p><ul><li><p>有了对象的多态性以后，我们在编译器期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p></li><li><p>总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。</p></li></ul></li><li><p>多态性使用前提：</p><ul><li>要有类的继承关系；</li><li>要有方法的重写。</li></ul></li><li><p>对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边）</p></li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="举例一：基本概念的使用"><a href="#举例一：基本概念的使用" class="headerlink" title="举例一：基本概念的使用"></a>举例一：基本概念的使用</h4><ol><li>Person类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Man类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSmoking;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1002</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;男人负责赚钱养家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;多吃肉，长肌肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;霸气地走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Woman类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isBeauty;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减肥&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优雅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>PersonTest类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.polymorphism;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     面向对象特征之三：多态性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    1.理解多态性：可以理解为事物的多种形态</span></span><br><span class="line"><span class="comment"> *    2.何为多态：</span></span><br><span class="line"><span class="comment"> *        对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用）</span></span><br><span class="line"><span class="comment"> *    3.多态的使用：虚拟方法调用</span></span><br><span class="line"><span class="comment"> *        有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</span></span><br><span class="line"><span class="comment"> *        总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。</span></span><br><span class="line"><span class="comment"> *    4.多态性使用前提：①要有类的继承关系；②要有方法的重写。</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    5.对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边）</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line">        </span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        man.eat();</span><br><span class="line">        man.age = <span class="number">18</span>;</span><br><span class="line">        man.earnMoney();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n*****************************&quot;</span>);</span><br><span class="line">        <span class="comment">//对象的多态性：父类的引用指向子类的对象</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//        Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//        多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用</span></span><br><span class="line">        p2.eat();</span><br><span class="line">        p2.walk();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        p2.earnMoney();</span></span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(p2.id);<span class="comment">//1001  对象的多态性，只适用于方法，不适用于属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行结果</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200816175953.png" alt="img"  /><h4 id="应用举例二：虚拟方法调用"><a href="#应用举例二：虚拟方法调用" class="headerlink" title="应用举例二：虚拟方法调用"></a>应用举例二：虚拟方法调用</h4><ol><li>AnimalTest类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.polymorphism;</span><br><span class="line"><span class="comment">//多态性的使用举例一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnimalTest test = <span class="keyword">new</span> AnimalTest();</span><br><span class="line">        </span><br><span class="line">        test.func(<span class="keyword">new</span> Dog());</span><br><span class="line">        </span><br><span class="line">        test.func(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span> </span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物：进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物：叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪！汪！汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵！喵！喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从编译和运行的角度看重载与重写"><a href="#从编译和运行的角度看重载与重写" class="headerlink" title="从编译和运行的角度看重载与重写"></a>从编译和运行的角度看重载与重写</h3><ul><li><p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。==它们的调用地址在编译期就绑定了==。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p><p>所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”。</p></li><li><p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p></li></ul><h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>​        有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特有的属性和方法？</p><ol><li>向下转型：使用强制类型转换符 例 <code>Man m1 = (Man)p2;</code></li><li>使用强转时，可能出现ClassCastException异常。引入instanceof关键字：</li><li>instanceof关键字的使用：<ul><li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true，如果不是返回false。</li><li>使用场景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型前，先进行instanceof判断，一旦返回true，就进行向下转型；如果返回false，不进行向下转型。</li><li>如果a instanceof A返回true，则a instanceof B也返回true，那么B是A的父类。</li></ul></li><li>应用举例：将上面应用举例一中的PersonTest类修改如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.polymorphism;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     面向对象特征之三：多态性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    1.理解多态性：可以理解为事物的多种形态</span></span><br><span class="line"><span class="comment"> *    2.何为多态：</span></span><br><span class="line"><span class="comment"> *        对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类引用）</span></span><br><span class="line"><span class="comment"> *    3.多态的使用：虚拟方法调用</span></span><br><span class="line"><span class="comment"> *        有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</span></span><br><span class="line"><span class="comment"> *        总结(Person p2 = new Man();)：编译，看左边(Person)；运行，看右边(Man())。</span></span><br><span class="line"><span class="comment"> *    4.多态性使用前提：①要有类的继承关系；②要有方法的重写。</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    5.对象的多态性，只适用于方法，不适用于属性。（编译和运行都看左边）</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line">        </span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        man.eat();</span><br><span class="line">        man.age = <span class="number">18</span>;</span><br><span class="line">        man.earnMoney();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n*****************************&quot;</span>);</span><br><span class="line">        <span class="comment">//对象的多态性：父类的引用指向子类的对象</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//        Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//        多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用</span></span><br><span class="line">        p2.eat();</span><br><span class="line">        p2.walk();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        p2.earnMoney();//无法调用子类所特有的方法，编译时认为p2是一个Person类，Person中无earnMoney方法。</span></span><br><span class="line"><span class="comment">//        p2.isSmoking = true;</span></span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(p2.id);<span class="comment">//1001--对象的多态性，只适用于方法，不适用于属性。</span></span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;***************instanceof关键字的使用*****************&quot;</span>);</span><br><span class="line"><span class="comment">//        有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类</span></span><br><span class="line"><span class="comment">//        类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        如何才能调用子类特有的属性和方法？</span></span><br><span class="line">        Man m1 = (Man)p2;<span class="comment">//向下转型：使用强制类型转换符。</span></span><br><span class="line">        m1.earnMoney();</span><br><span class="line">        m1.isSmoking = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        使用强转时，可能出现ClassCastException异常。</span></span><br><span class="line"><span class="comment">//        Woman w1 = (Woman)p1;</span></span><br><span class="line"><span class="comment">//        w1.goShopping();</span></span><br><span class="line">        <span class="comment">/*    instanceof关键字的使用：</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *    a instanceof A:判断对象a是否是类A的实例。如果是，返回true，如果不是返回false。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     使用情景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型前，先进</span></span><br><span class="line"><span class="comment">         *     行instanceof判断，一旦返回true，就进行向下转型；如果返回false，不进行向下转型。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *     如果a instanceof A返回true，则a instanceof B也返回true，那么B是A的父类。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">            Woman w1 = (Woman)p2;</span><br><span class="line">            w1.goShopping();</span><br><span class="line">            System.out.println(<span class="string">&quot;强转成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2不是类Woman的实例，强转失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2是类Man的实例，可以强转！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2不是类Man的实例，强转失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2是类Person的实例！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2也是类Object的实例！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        练习：</span></span><br><span class="line">        <span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line"><span class="comment">//        Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//        Man m3 = (Man)p3;</span></span><br><span class="line">        <span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//        Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//        Man m3 = (Man)p3;</span></span><br><span class="line">        <span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//        Person p4 = new Person();</span></span><br><span class="line"><span class="comment">//        Man m4 = (Man)p4;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//问题二：编译通过，运行也通过</span></span><br><span class="line"><span class="comment">//        Object obj = new Woman();</span></span><br><span class="line"><span class="comment">//        Person p = (Person)obj;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//问题三：编译不通过</span></span><br><span class="line"><span class="comment">//        Man m5 = new Woman();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200817094716.png" alt="img" style="zoom:75%;" /><h2 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h2><h3 id="java-lang-Object类"><a href="#java-lang-Object类" class="headerlink" title="java.lang.Object类"></a>java.lang.Object类</h3><ol><li><p>Object类是所有Java类的根父类。</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类。</p></li><li><p>Object类中的功能（属性、方法）具有通用性。</p><p>属性：无</p><p>方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait()、notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参的构造器。</p></li></ol><h3 id="Object类中的主要结构"><a href="#Object类中的主要结构" class="headerlink" title="Object类中的主要结构"></a>Object类中的主要结构</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211103016247.png" alt="image-20201211103016247" style="zoom: 33%;" /><h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><p>​    <strong>面试题：</strong>==和equals()的区别？</p><ol><li><p>回顾==的使用：</p><p>==：运算符</p><ul><li><p>可以使用在基本数据类型变量和引用数据类型变量中；</p></li><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一 个对象实体。</p></li></ul></li><li><p>equals()方法的使用：</p><ul><li><p>是一个方法，而非运算符；</p></li><li><p>只能适用于引用数据类型；</p></li><li><p>Object类中equals()的定义：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        说明：Object类中equals()和==的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。</p><ul><li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法，重写之后，比较的不再是两个对象的“实体内容”是否相同；</p></li><li><p>通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的“实体内容”是否相同。那么我们就需要对Object类中的equals()方法进行重写。</p></li><li><p>重写原则：比较两个对象的实体内容（即：name和age）是否相同。</p></li></ul></li><li><p>代码实例</p><ul><li>Customer类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    重写原则：比较两个对象的实体内容（即：name和age）是否相同</span></span><br><span class="line"><span class="comment">//    手动实现equals()的重写：</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">//        if(this == obj) &#123;</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(obj instanceof Customer) &#123;</span></span><br><span class="line"><span class="comment">//            Customer cust = (Customer)obj;</span></span><br><span class="line"><span class="comment">//            //比较两个对象的每个属性是否都相同</span></span><br><span class="line"><span class="comment">//            return this.age == cust.age &amp;&amp; this.name.equals(cust.name);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    自动生成equals()的重写：=&gt; Alt+Shift+S / Source =&gt; Generate hashCode() and equals()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Customer other = (Customer) obj;</span><br><span class="line">        <span class="keyword">if</span> (age != other.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EqualsTest类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 面试题：==和equals()的区别？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、回顾 == 的使用：</span></span><br><span class="line"><span class="comment"> *         ==：运算符</span></span><br><span class="line"><span class="comment"> *         1. 可以使用在基本数据类型变量和引用数据类型变量中；</span></span><br><span class="line"><span class="comment"> *         2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</span></span><br><span class="line"><span class="comment"> *             如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一</span></span><br><span class="line"><span class="comment"> *             个对象实体。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、equals()方法的使用：</span></span><br><span class="line"><span class="comment"> *         1. 是一个方法，而非运算符；</span></span><br><span class="line"><span class="comment"> *         2. 只能适用于引用数据类型；</span></span><br><span class="line"><span class="comment"> *         3. Object类中equals()的定义：</span></span><br><span class="line"><span class="comment"> *             public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">                return (this == obj);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"> *         说明：Object类中equals()和==的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> *         4. 像String、Date、File、包装类等都重写了Object类中的equals()方法，重写之后，比较的不再是两个对象的“实体内容”</span></span><br><span class="line"><span class="comment"> *             是否相同。</span></span><br><span class="line"><span class="comment"> *         5. 通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的“实体内容”是否相同。那么我们就</span></span><br><span class="line"><span class="comment"> *             需要对Object类中的equals()方法进行重写。</span></span><br><span class="line"><span class="comment"> *             重写原则：比较两个对象的实体内容（即：name和age）是否相同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">        System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i == d);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        boolean b = true;</span></span><br><span class="line"><span class="comment">//        System.out.println(i == b);//报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i == c);<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="number">65</span>;</span><br><span class="line">        System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        引用数据类型</span></span><br><span class="line">        Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Customer cust2 = <span class="keyword">new</span> Customer(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(cust1 == cust2);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;Triabin&quot;</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;Triabin&quot;</span>);</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;**********equals()方法的使用**********&quot;</span>);</span><br><span class="line">        System.out.println(cust1.equals(cust2));<span class="comment">//false =&gt; Object类中的equals()方法，比较的是地址，修改相应的equals()方法后变为true，详情见Customer类</span></span><br><span class="line">        System.out.println(str1.equals(str2));<span class="comment">//true =&gt; String类中的equals()方法，比较的是“实体内容”，而非地址</span></span><br><span class="line">        </span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">        System.out.println(date1.equals(date2));<span class="comment">//true =&gt; Date类中的equals()方法，比较的是“实体内容”，而非地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul></li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200817220202.png" alt="img"></p><ol start="4"><li><p>重写equals()方法的原则：</p><ul><li><p>对称性：如果x.equals(y)返回的是“true”，那么y.equals(x)也应该返回是“true”。</p></li><li><p>自反性：x.equals(x)必须返回是“true”。</p></li><li><p>传递性：如果x.equals(y)返回是“true”，而且x.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</p></li><li><p>一致性：如果x.equals(y)返回是”true“，只要x和y内容一直不变，不管重复x.equals(y)多少次，返回都是“true”。</p></li><li><p>任何情况下，x.equals(null)，永远返回是“false”；</p><p>x.equals(和x不同类型的对象)永远返回是“false”。</p></li></ul></li></ol><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><ol><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()；</p></li><li><p>Object类中toString()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()方法时，返回“实体内容”信息；</p></li><li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。</p></li><li><p>代码实例：</p><ul><li>在equals()代码实例的包下创建类ToStringTest类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.triabin.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object类中toString()的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. Object类中toString()的定义：</span></span><br><span class="line"><span class="comment"> *          public String toString() &#123;</span></span><br><span class="line"><span class="comment">            return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()方法</span></span><br><span class="line"><span class="comment"> *         时，返回“实体内容”信息；</span></span><br><span class="line"><span class="comment"> * 4. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">&quot;Triabin&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(cust1.toString());<span class="comment">//top.triabin.classobject.Customer@15db9742  重写toString()方法后：Customer[name = Triabin,age = 22]</span></span><br><span class="line">        System.out.println(cust1);<span class="comment">//top.triabin.classobject.Customer@15db9742  重写toString()方法后：Customer[name = Triabin,age = 22]</span></span><br><span class="line">        </span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;MM&quot;</span>);</span><br><span class="line">        System.out.println(str);<span class="comment">//MM</span></span><br><span class="line">        </span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">4534534534543L</span>);</span><br><span class="line">        System.out.println(date.toString());<span class="comment">//2113-09-11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Customer类中重写toString()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    手动实现toString()方法的重写：</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Customer[name = &quot; + name + &quot;,age = &quot; + age + &quot;]&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    自动实现：</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200818151621.png" alt="img"></p></li></ol><h2 id="包装类-Wrapper-的使用"><a href="#包装类-Wrapper-的使用" class="headerlink" title="包装类(Wrapper)的使用"></a>包装<strong>类</strong>(Wrapper)的使用</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</li><li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211104020976.png" alt="image-20201211104020976" style="zoom: 50%;" /><ol start="3"><li><p><strong>基本数据类型包装成包装类的实例</strong> —— ==装箱==</p><ul><li>通过包装类的构造器实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>; Integer t = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure><ul><li>通过字符串参数构造包装类对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float f = <span class="keyword">new</span> Float(“<span class="number">4.56</span>”);</span><br><span class="line"></span><br><span class="line">Long l = <span class="keyword">new</span> Long(“asdf”); <span class="comment">//NumberFormatException</span></span><br></pre></td></tr></table></figure></li><li><p>获得包装类对象中包装的基本类型变量 —— ==拆箱==</p><ul><li>调用包装类的.xxxValue()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = bObj.booleanValue();</span><br></pre></td></tr></table></figure></li><li><p>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。</p></li><li><p><strong>字符串转换成基本数据类型</strong></p><ul><li>通过包装类的构造器实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(“<span class="number">12</span>”);</span><br></pre></td></tr></table></figure><ul><li>通过包装类的parseXxx(String s)静态方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Float f = Float.parseFloat(“<span class="number">12.1</span>”);</span><br></pre></td></tr></table></figure></li><li><p><strong>基本数据类型转换成字符串</strong></p><ul><li>调用字符串重载的valueOf()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fstr = String.valueOf(<span class="number">2.34f</span>);</span><br></pre></td></tr></table></figure><ul><li>更直接的方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String intStr = <span class="number">5</span> + “”</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本类型、包装类与String类间的转换"><a href="#基本类型、包装类与String类间的转换" class="headerlink" title="基本类型、包装类与String类间的转换"></a><strong>基本类型、包装类与</strong>String<em>类间的转换</em></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201211104735951.png" alt="image-20201211104735951" style="zoom: 50%;" /><h3 id="包装类用法举例"><a href="#包装类用法举例" class="headerlink" title="包装类用法举例"></a><strong>包装类用法举例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">Integer t = <span class="keyword">new</span> Integer(i);</span><br><span class="line">装箱：包装类使得一个基本数据类型的数据变成了类。</span><br><span class="line">有了类的特点，可以调用类中的方法。</span><br><span class="line">String s = t.toString(); <span class="comment">// s = “500“,t是类，有toString方法</span></span><br><span class="line">String s1 = Integer.toString(<span class="number">314</span>); <span class="comment">// s1= “314“ 将数字转换成字符串。</span></span><br><span class="line">String s2=“<span class="number">4.56</span>”;</span><br><span class="line"><span class="keyword">double</span> ds=Double.parseDouble(s2); <span class="comment">//将字符串转换成数字</span></span><br></pre></td></tr></table></figure><ul><li><strong>拆箱：将数字包装类中内容变为基本数据类型。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = t.intValue(); <span class="comment">// j = 500，intValue取出包装类中的数据</span></span><br></pre></td></tr></table></figure><ul><li>包装类在实际开发中用的最多的在于字符串变为基本数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;30&quot;</span> ;</span><br><span class="line">String str2 = <span class="string">&quot;30.3&quot;</span> ;</span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(str1) ; <span class="comment">// 将字符串变为int型</span></span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(str2) ; <span class="comment">// 将字符串变为int型</span></span><br></pre></td></tr></table></figure><h2 id="单元测试（JUnit）"><a href="#单元测试（JUnit）" class="headerlink" title="单元测试（JUnit）"></a>单元测试（JUnit）</h2><ol><li>选中当前工程 -&gt; 右键 -&gt; build path -&gt; add libraries -&gt; JUnit 4 -&gt; 下一步</li><li>创建一个Java类进行单元测试<ul><li>此时的Java类要求：① 此类是public的； ② 此类提供公共的无参的构造器</li></ul></li><li>此类中声明单元测试方法<ul><li>此时的单元测试方法：方法的权限是public，没有返回值，没有形参</li></ul></li><li>此单元测试方法上需要声明注释：@Test，并在单元测试类中导入：import org.junit.Test；</li><li>声明好单元测试方法以后，就可以在方法体内测试相关代码；</li><li>写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test</li><li>说明：<ul><li>如果执行结果没有异常：绿条</li><li>如果执行结果出现异常：红条</li></ul></li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;MM&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;MM&quot;</span>;</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ClassCastException的异常</span></span><br><span class="line"><span class="comment">//        Object obj = new String(&quot;GG&quot;);</span></span><br><span class="line"><span class="comment">//        Date date = (Date)obj;</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(num);</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s2 = <span class="string">&quot;MM&quot;</span>;</span><br><span class="line">        System.out.println(s2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OOP特征二：继承性&quot;&gt;&lt;a href=&quot;#OOP特征二：继承性&quot; class=&quot;headerlink&quot; title=&quot;OOP特征二：继承性&quot;&gt;&lt;/a&gt;OOP特征二：继承性&lt;/h2&gt;&lt;h3 id=&quot;继承性的好处&quot;&gt;&lt;a href=&quot;#继承性的好处&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第四章 面向对象（上）</title>
    <link href="https://asteroidcs.github.io/undefined/df1b.html"/>
    <id>https://asteroidcs.github.io/undefined/df1b.html</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:18:28.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java面对对象学习的三条主线"><a href="#Java面对对象学习的三条主线" class="headerlink" title="Java面对对象学习的三条主线"></a>Java面对对象学习的三条主线</h2><ol><li>Java类及类的成员：属性、方法、构造器；代码块、内部类；</li><li>面向对象的三大特征：封装性、继承性、多态性（、抽样性）；</li><li>其他关键字：this、super、final、abstract、interface、package、import等。</li></ol><h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><h3 id="面向过程与面向对象区别"><a href="#面向过程与面向对象区别" class="headerlink" title="面向过程与面向对象区别"></a>面向过程与面向对象区别</h3><ol><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ol><h3 id="面对对象的三大特征"><a href="#面对对象的三大特征" class="headerlink" title="面对对象的三大特征"></a>面对对象的三大特征</h3><ol><li>封装（Encapsulation）</li><li>继承（Inheritance）</li><li>多态（Polymorphism）</li></ol><h3 id="面对对象的思想概述"><a href="#面对对象的思想概述" class="headerlink" title="面对对象的思想概述"></a>面对对象的思想概述</h3><ol><li>程序员从面向过程的执行者转化成了面向对象的指挥者。</li><li>面对对象分析问题的思路和步骤：<ul><li>根据问题需要，选择问题所针对的现实世界中的实体。</li><li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li><li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li><li>将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。</li></ul></li></ol><h2 id="Java基本元素：类和对象"><a href="#Java基本元素：类和对象" class="headerlink" title="Java基本元素：类和对象"></a>Java基本元素：类和对象</h2><h3 id="面对对象的思想概述-1"><a href="#面对对象的思想概述-1" class="headerlink" title="面对对象的思想概述"></a>面对对象的思想概述</h3><ol><li>类（Class）和对象（Object）是面向对象的核心概念。<ul><li>类是对一类事物的描述，是抽象的、概念上的定义</li><li>对象是实际存在的该类事物的每个个体，因而也称为实例（instance）</li></ul></li><li>万物皆对象<ul><li>面对对象程序设计的重点是类的设计</li><li>类的设计，其实就是类的成员的设计</li></ul></li></ol><h3 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a>Java类及类的成员</h3><ol><li>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多不同功能的类构成的。</li><li>现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质……那么，Java中用类来描述事物也是如此。常见类的成员有：<ul><li>属性：对应类中的成员变量</li><li>行为：对应类中的成员方法</li></ul></li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207160922776.png" alt="image-20201207160922776"></p><h2 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h2><h3 id="面对对象思想的实现"><a href="#面对对象思想的实现" class="headerlink" title="面对对象思想的实现"></a>面对对象思想的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dawn333.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>    一、类和对象的使用（面对对象思想落地的实现）：</span></span><br><span class="line"><span class="comment"> * 1、创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> * 2、创建类的对象</span></span><br><span class="line"><span class="comment"> * 3、通过“对象.属性”或“对象.方法”调用对象的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     二、如果创建了多个对象，则每个对象都独立的拥有一套属性。（非static）</span></span><br><span class="line"><span class="comment"> *     意味着，如果改一个对象的属性a，不影响另一个对象属性a的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-30    16:32:18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象、</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：对象.属性</span></span><br><span class="line">        p1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：对象.方法</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//************************</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p2.name);<span class="comment">//null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//************************</span></span><br><span class="line">        Person p3 = p1;</span><br><span class="line">        <span class="comment">//将p1变量保存的地址赋给p3，导致p1和p3指向了堆空间中的同一个对象实体。</span></span><br><span class="line">        System.out.println(p3.name);<span class="comment">//Tom</span></span><br><span class="line">        p3.age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(p1.age);<span class="comment">//10        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以说话，使用的语言是：&quot;</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207161029802.png" alt="image-20201207161029802" style="zoom:67%;" /><ol><li>堆（heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</li><li>通常所说的栈（stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（bolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</li><li>方法区（method area），用于存储已被虚拟机加载类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>对象内存解析</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200803230516.png" alt="03对象的内存解析" style="zoom: 50%;" /><h4 id="内存解析的说明"><a href="#内存解析的说明" class="headerlink" title="内存解析的说明"></a>内存解析的说明</h4><ol><li>引用类型的变量，只可能存储两类值：null或地址值（含变量的类型）</li><li>对象数组的内存解析</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806155821.png" alt="img" style="zoom:50%;" /><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><ol><li>关注书籍：《JVM规范》</li><li>虚拟机栈即为平时提到的栈结构，我们将局部变量存储在栈结构中。</li><li>堆，我们将new出来的结构（比如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中。</li></ol><h3 id="理解“万事万物皆对象”"><a href="#理解“万事万物皆对象”" class="headerlink" title="理解“万事万物皆对象”"></a>理解“万事万物皆对象”</h3><ol><li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。<ul><li>Scanner，String等</li><li>文件：File</li><li>网络资源：URL</li></ul></li><li>涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li></ol><h3 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h3><ol><li>理解：我们创建的对象没有显示的赋给一个变量名， 即为匿名对象。</li><li>特征：匿名对象只能代用一次。</li><li>使用：如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.triabin.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 匿名对象的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-6    16:04:02</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;正常调用：&quot;</span>);</span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象只能代用一次：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n匿名对象的使用：&quot;</span>);</span><br><span class="line">        PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"><span class="comment">//        mall.show(p);</span></span><br><span class="line">        mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的价格为：&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h2><h3 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h3><ol><li>语法格式:</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207161549477.png" alt="image-20201207161549477" style="zoom: 33%;" /><ol start="2"><li>说明：<ul><li>说明<strong>1:</strong> 修饰符<ul><li>常用的权限修饰符有:private、缺省、protected、public</li><li>其他修饰符:static、final (暂不考虑) </li></ul></li><li>说明<strong>2</strong>:数据类型<ul><li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li></ul></li><li>说明<strong>3</strong>:属性名<ul><li>属于标识符，符合命名规则和规范即可。</li></ul></li></ul></li><li>举例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">//声明private变量 age</span></span><br><span class="line"><span class="keyword">public</span> String name = “Lila”; <span class="comment">//声明public变量 name &#125;</span></span><br></pre></td></tr></table></figure><h3 id="变量的分类-成员变量与局部变量"><a href="#变量的分类-成员变量与局部变量" class="headerlink" title="变量的分类:成员变量与局部变量"></a>变量的分类:成员变量与局部变量</h3><ol><li>成员变量：在方法体外，类体内声明的变量。</li><li>局部变量：在方法体内部声明的变量称。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806153535.png" alt="img"></p><ol start="3"><li><p>注意:二者在初始化值方面的异同**:**</p><ul><li><p>同:都有生命周期</p><p>异:局部变量除形参外，均需显式初始化。</p></li></ul></li><li><p>区别：</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201207162027745.png" alt="image-20201207162027745" style="zoom: 50%;" /></li><li><p>代码示例：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.triabin.oop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类中属性的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-8-5    14:49:47</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(u1.name);</span><br><span class="line">        System.out.println(u1.age);</span><br><span class="line">        System.out.println(u1.isMale);</span><br><span class="line">        u1.talk(<span class="string">&quot;日语&quot;</span>);<span class="comment">//特别的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性（或成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;<span class="comment">//形参，也是局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我们使用&quot;</span> + language +<span class="string">&quot;进行交流。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String food = <span class="string">&quot;烙饼&quot;</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;北方人喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之二-方法-method"><a href="#类的成员之二-方法-method" class="headerlink" title="类的成员之二: 方法(method)"></a>类的成员之二: 方法(method)</h2><ul><li>方法：描述类具有的功能。比如：Math类：sqrt()\random()\……<ul><li>Scanner类：nextXxx()……</li><li>Arrarys类：sort()\binarySearch()\toString()\equals()\……</li></ul></li></ul><h3 id="类中方法的声明和使用"><a href="#类中方法的声明和使用" class="headerlink" title="类中方法的声明和使用"></a>类中方法的声明和使用</h3><ol><li>举例<ul><li>public void eat(){}（void：没有返回值）</li><li>public void sleep(int hour){}</li><li>public String getNmae() {}（String：返回一个String类型的数据）</li><li>public String getNation(String nation){}</li></ul></li><li>方法的声明：</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210195459199.png" alt="image-20201210195459199" style="zoom: 25%;" /><ul><li>注意：static、final、abstract来修饰的方法</li></ul><ol start="3"><li><p>说明：</p><ul><li>关于权限修饰符：目前默认方法的权限修饰符先都使用public</li><li>Java规定的4种权限修饰符：private、public、缺省、protected —&gt; 封装性再细说</li><li>返回值类型：有返回值 or 无返回值<ul><li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中必须使用return关键字来返回指定类型的变量或常量。例如下列代码实例方法中的getName()方法。</li><li>如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不使用return。但是，如果使用的话，只能“return;”，表示结束此方法。</li></ul></li><li>方法名：属于标识符，遵循表示符的规则和命名规范，“见名知意”。</li><li>形参列表：方法可以声明0个，1个或多个形参。<ul><li>格式：数据类型1 形参1,数据类型2 形参2,…</li></ul></li><li>方法体：方法功能的体现。</li></ul></li><li><p>return关键字的使用：</p><ul><li>使用范围：使用在方法体中。</li><li>作用：①结束方法；②针对于有返回值的方法，使用“return 数据;”方法返回所要的数据。</li><li>==注意：return关键字后面不可以声明执行语句==</li></ul></li><li><p>方法的使用中可以调用当前类的属性或方法</p><ul><li>特别地：方法A中调用方法A：递归方法。</li><li>方法中不能再定义方法。</li></ul></li></ol><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.triabin.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customar</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性:</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;休息了&quot;</span> + hour + <span class="string">&quot;小时&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNmae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//没有else则报错，必须要有一个返回值。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNation</span><span class="params">(String nation)</span> </span>&#123;</span><br><span class="line">        String info = <span class="string">&quot;我的国籍是：&quot;</span> + nation;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的分类（按照是否有形参及返回值）"><a href="#方法的分类（按照是否有形参及返回值）" class="headerlink" title="方法的分类（按照是否有形参及返回值）"></a>方法的分类（按照是否有形参及返回值）</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210200533639.png" alt="image-20201210200533639" style="zoom: 25%;" /><h2 id="再谈方法"><a href="#再谈方法" class="headerlink" title="再谈方法"></a>再谈方法</h2><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ol><li><p>定义：</p><ul><li>在同一个类中，允许存在一个以上的同名方法，只要它们的==参数个数== ==或者== ==参数类型==不同即可。<ul><li>“两同一不同”：同一个类、相同的方法名；参数列表不同：参数个数不同、参数类型不同</li></ul></li></ul></li><li><p>特点：</p><ul><li>与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。</li></ul></li><li><p>示例</p><ul><li>Arrays类中重载的sort() / binarySearch()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoadTest test = <span class="keyword">new</span> OverLoadTest();</span><br><span class="line">        test.getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如下4个方法构成了重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public int getSum(int i,int j) &#123;</span></span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public void getSum(int m,int n) &#123;</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：支持自动类型提升，例如，如果形参为double型，但是输入的形参为int型，则自动将int型转换为double型。</li></ul></li><li><p>判断是否是重载</p><ul><li>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系，==只看形参数目和类型==</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210201630343.png" alt="image-20201210201630343" style="zoom: 33%;" /><ol><li>通过对象调用方法时，如何确定某一个指定的方法：<ul><li>方法名 —&gt; 参数列表</li></ul></li></ol><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>编写程序，定义三个重载方法并调用。方法名为mOL。</p><ul><li>三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果、相乘并输出结果、输出字符串信息。</li><li>在主类的main方法中分别用参数区别调用三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadEx1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoadEx1 m = <span class="keyword">new</span> OverLoadEx1();</span><br><span class="line">        m.mOL(<span class="number">2</span>);</span><br><span class="line">        m.mOL(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        m.mOL(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mOL</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i * i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mOL</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(i * j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mOL</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，分别调用三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadEx2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoadEx2 test = <span class="keyword">new</span> OverLoadEx2();</span><br><span class="line">        test.max(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        test.max(<span class="number">1.5</span>, <span class="number">3.5</span>);</span><br><span class="line">        test.max(<span class="number">1.5</span>, <span class="number">3.5</span>, <span class="number">7.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个方法求得最大值为：&quot;</span> + ((i &gt; j)? i : j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> i,<span class="keyword">double</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个方法求得最大值为：&quot;</span> + ((i &gt; j)? i : j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> i,<span class="keyword">double</span> j,<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个方法求得最大值为：&quot;</span> + ((((i &gt; j)? i : j) &gt; k)? ((i &gt; j)? i : j) : k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h3><ol><li><p>JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</p><ul><li><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p><p><code>public static void test(int a,String[] books);</code></p></li><li><p>JDK 5.0：采用可变个数形参来定义方法，传入多个同一类型变量</p><p><code>public static void test(int a,String...books);</code></p></li></ul></li><li><p>具体使用：</p><ul><li>可变个数形参的格式：数据类型 … 变量名</li><li>当调用可变个数形参的方法时，传入的参数个数可以是：0个、1个、2个……</li><li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。</li><li>==可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不够成重载（即二者不能共存）。==</li><li>可变个数形参在方法的形参列表中，==必须声明在末尾==。</li><li>可变个数形参在方法的形参列表中，==最多只能声明一个可变形参==。</li></ul></li><li><p>示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarAgu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VarAgu test = <span class="keyword">new</span> VarAgu();</span><br><span class="line">        test.show(<span class="number">12</span>);</span><br><span class="line">        test.show(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        test.show(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        test.show();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        test.show(new String[] &#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量,JDK 5.0向前兼容,所以(String ... strs)同样可以用此方法传入形参</span></span><br><span class="line">        test.show(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show(int i)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++) &#123;</span><br><span class="line">            System.out.println(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public void show(String[] strs) &#123;//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;show(String[] strs)&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="==方法参数的值传递机制=="></a>==方法参数的值传递机制==</h3><h4 id="变量的值传递机制"><a href="#变量的值传递机制" class="headerlink" title="变量的值传递机制"></a>变量的值传递机制</h4><ol><li><p>关于变量的赋值：</p><p>如果是基本数据类型，此时赋值的是变量所保存的数据值；</p><p>如果变量是引用数据类型，此时，赋值的是变量所保存的数据的地址值。</p></li><li><p>示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransfer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;******基本数据类型的值传递情况******&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = m;</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;******引用数据类型的值传递情况******&quot;</span>);</span><br><span class="line">        Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">        o1.orderID = <span class="number">1001</span>;</span><br><span class="line">        Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;o1.orderID = &quot;</span> + o1.orderID + <span class="string">&quot;, o2.orderID = &quot;</span> + o2.orderID);</span><br><span class="line">        o2.orderID = <span class="number">1002</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;o1.orderID = &quot;</span> + o1.orderID + <span class="string">&quot;, o2.orderID = &quot;</span> + o2.orderID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> orderID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806215036.png" alt="img"  /><h4 id="方法的形参传递机制：值传递"><a href="#方法的形参传递机制：值传递" class="headerlink" title="方法的形参传递机制：值传递"></a>方法的形参传递机制：值传递</h4><ol><li><p>形参：方法定义时，声明的小括号内的参数。</p><p>实参：调用方法时实际传递给形参的数据。</p></li><li><p>值传递机制：</p><p>如果参数是<strong>基本数据类型</strong>，此时实参赋给形参的是实参真实存储的<strong>数据值</strong>;</p><p>如果参数是<strong>引用数据类型</strong>，此时实参赋给形参的是实参存储数据的<strong>地址值</strong>。</p></li><li><p>示例1</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransfer01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">        <span class="comment">//交换两个变量值的操作</span></span><br><span class="line"><span class="comment">//        int temp = m;</span></span><br><span class="line"><span class="comment">//        m = n;</span></span><br><span class="line"><span class="comment">//        n = temp;</span></span><br><span class="line">        ValueTransfer01 test = <span class="keyword">new</span> ValueTransfer01();</span><br><span class="line">        test.swap(m, n);<span class="comment">//未能交换，原因看内存解析。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806221508.png" alt="img"></p><ul><li>内存解析（交换失败原因）</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806220731.png" alt="img" style="zoom:67%;" /><ol start="4"><li>示例2</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransfer02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        data.m = <span class="number">10</span>;</span><br><span class="line">        data.n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + data.m + <span class="string">&quot;,n = &quot;</span> + data.n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换m和n的值</span></span><br><span class="line"><span class="comment">//        int temp = data.m;</span></span><br><span class="line"><span class="comment">//        data.m = data.n;</span></span><br><span class="line"><span class="comment">//        data.n = temp;</span></span><br><span class="line">        ValueTransfer02 test = <span class="keyword">new</span> ValueTransfer02();</span><br><span class="line">        test.swap(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + data.m + <span class="string">&quot;,n = &quot;</span> + data.n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Data data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = data.m;</span><br><span class="line">        data.m = data.n;</span><br><span class="line">        data.n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806224618.png" alt="img"></p><ul><li>内存解析</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200806223846.png" alt="img" style="zoom: 50%;" /><h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><h5 id="例题一：方法的参数传递"><a href="#例题一：方法的参数传递" class="headerlink" title="例题一：方法的参数传递"></a>例题一：方法的参数传递</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferEx01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValueTransferEx01 test = <span class="keyword">new</span> ValueTransferEx01();</span><br><span class="line">        test.first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        Value v = <span class="keyword">new</span> Value();</span><br><span class="line">        v.i = <span class="number">25</span>;</span><br><span class="line">        second(v,i);</span><br><span class="line">        System.out.println(v.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Value v,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        v.i = <span class="number">20</span>;</span><br><span class="line">        Value val = <span class="keyword">new</span> Value();</span><br><span class="line">        v = val;</span><br><span class="line">        System.out.println(v.i + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line"><span class="number">15</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>内存解析</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200807091641.png" alt="img" style="zoom: 50%;" /><h3 id="递归（recursion）方法"><a href="#递归（recursion）方法" class="headerlink" title="递归（recursion）方法"></a>递归（recursion）方法</h3><ol><li>递归方法：一个方法体内调用自身。</li><li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li><li>示例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionIns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算1-100内所有数的和</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++) &#123;</span><br><span class="line">            sum1 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式一：&quot;</span> + sum1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二（递归）：</span></span><br><span class="line">        RecursionIns test = <span class="keyword">new</span> RecursionIns();</span><br><span class="line">        <span class="keyword">int</span> sum2 = test.getSum(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式二：&quot;</span> + sum2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算阶乘</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> fac = test.getFac(n);</span><br><span class="line">        System.out.println(n + <span class="string">&quot;的阶乘为：&quot;</span> + fac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算1-100内所有数的和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算1-n之间的乘积：n!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * getFac(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h4><ol><li>已知有一个数列：f(0) = 1，f(1) = 4，f(n+2) = 2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionEx01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RecursionEx01 test = <span class="keyword">new</span> RecursionEx01();</span><br><span class="line">        System.out.println(<span class="string">&quot;f(10) = &quot;</span> + test.f(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>斐波那契数列（Fibonacci）:</p><ul><li><p>输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值1 1 2 3 5 8 13 21 34 55。</p><p>规律：一个数等于前两个数之和。</p><p>要求：计算斐波那契数列的第n个值，并将整个数列打印出来。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionEx02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RecursionEx02 test = <span class="keyword">new</span> RecursionEx02();</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印斐波那契数列前几位？（输入任意大于0的整数）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            System.out.print(test.f(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OOP特征一：封装与隐藏"><a href="#OOP特征一：封装与隐藏" class="headerlink" title="OOP特征一：封装与隐藏"></a>OOP特征一：封装与隐藏</h2><ul><li>OOP，即Object oriented programming，面向对象编程。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ol><li>为什么需要封装？封装的作用和含义？<ul><li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部结构吗？有必要碰电动机吗?</li><li>我要开车……</li></ul></li><li>我们程序设计追求==“高内聚，低耦合”==。<ul><li>高内聚：类的内部操作细节自己完成，不允许外部干涉；</li><li>低耦合：仅对外暴露少量的方法用于使用。</li></ul></li><li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</li></ol><h3 id="信息的封装和隐藏"><a href="#信息的封装和隐藏" class="headerlink" title="信息的封装和隐藏"></a>信息的封装和隐藏</h3><ul><li><p>当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值的操作要受属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们需要给属性赋值加入额外的条件。这个条件就不能再属性声明时体现，我们只能通过方法进行限制条件的添加。（比如，示例中的setLegs()方法）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private）。</p><p>–&gt; 此时，针对属性就体现了封装性。</p></li></ul><ol><li><p>封装性的体现：我们讲类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。</p></li><li><p>拓展：封装性的体现</p><p>①如上 ②不对外暴露的私有的方法 ③单例模式 …</p></li><li><p>示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.name = <span class="string">&quot;大黄&quot;</span>;</span><br><span class="line">        <span class="comment">//a.age = 1;//age属性私有后无法赋值，通过setAge()方法来赋值</span></span><br><span class="line">        a.setAge(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//a.legs = 4;//The field Animal.legs is not visible（不可见）</span></span><br><span class="line">        a.setLegs(<span class="number">4</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        a.setLegs(<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        a.setLegs(-<span class="number">2</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> legs;<span class="comment">//私有权限修饰符，使得外界不能直接调用legs这个参数，只能通过规定的方式（setLegs()）来设置legs属性的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//筛选合理赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= <span class="number">0</span> &amp;&amp; l % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            legs = l;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            legs = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//抛出一个异常（暂时没有讲）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//legs被私有化以后用它来获取当前legs属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;，age:&quot;</span> + age + <span class="string">&quot;， legs:&quot;</span> + legs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供属性age的get和set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        age = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h3><ul><li>封装性的体现，需要权限修饰符来配合</li></ul><ol><li>Java规定的种权限（从小到大排列）：private、缺省、protected、public</li><li>Java的权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类成员的访问权限。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/20200808095828.png" alt="img"></p><ol start="3"><li>4种权限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类。</li><li>具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类只能用default（缺省）、public。</li><li>总结封装性：<ul><li>Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构的在被调用时的可见性大小。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210204341066.png" alt="image-20201210204341066" style="zoom:67%;" /><h2 id="类的成员之三：构造器（或构造方法）"><a href="#类的成员之三：构造器（或构造方法）" class="headerlink" title="类的成员之三：构造器（或构造方法）"></a>类的成员之三：构造器（或构造方法）</h2><h3 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h3><ol><li>创建对象</li><li>初始化对象的信息</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建类的对象：new + 构造器</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。</li><li>定义构造器的格式：权限修饰符 类名(形参列表){}。</li><li>一个类中定义多个构造器，彼此构成重载。</li><li>一旦我们显式定义了构造器之后，系统就不再提供默认的空参构造器。</li><li>一个类中，至少会有一个构造器。</li></ol><h3 id="总结：属性赋值的先后顺序"><a href="#总结：属性赋值的先后顺序" class="headerlink" title="总结：属性赋值的先后顺序"></a>总结：属性赋值的先后顺序</h3><ol><li>默认初始化</li><li>显式初始化</li><li>构造器中初始化</li><li>通过”对象.方法”的方式赋值</li></ol><h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="扩展知识一：JavaBean"><a href="#扩展知识一：JavaBean" class="headerlink" title="扩展知识一：JavaBean"></a>扩展知识一：JavaBean</h3><ol><li>JavaBean是一种Java语言写成的可重用组件。</li><li>所谓JavaBean，是指符合如下标准的Java类：<ul><li>类是公共的</li><li>有一个无参的公共的构造器</li><li>有属性，且有对应的get、set方法</li></ul></li><li>用户可以使用JavaBean将功能、处理。值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</li></ol><h3 id="扩展知识二：UML类图"><a href="#扩展知识二：UML类图" class="headerlink" title="扩展知识二：UML类图"></a>扩展知识二：UML类图</h3><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210204840634.png" alt="image-20201210204840634"></p><ol><li><p>+表示public类型，-表示private类型，#表示protected类型。</p></li><li><p>方法的写法：</p><p>方法的类型（+、-） 方法名(参数名:参数类型):返回值类型</p></li></ol><h2 id="关键字：this"><a href="#关键字：this" class="headerlink" title="==关键字：this=="></a>==关键字：this==</h2><h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ol><li>his可以用来修饰：属性、方法、构造器。</li><li>this修饰属性和方法：this可理解为当前对象（方法中）或当前正在创建的对象（构造器中）<ul><li>在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用“this.属性”或”this.方法“的方式，调用当前属性或方法。但是通常情况下，我们都选择省略”this.“。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式地使用“this.变量”的方式，表明此变量是属性，而非形参。、</li></ul></li><li>this调用构造器<ul><li>我们在类的构造器中，可以显式的使用“this(形参列表)”的方式，调用本类中指定的其他构造器。</li><li>构造器中不能通过“this(形参列表)”的方式调用自己。</li><li>如果有n个构造器，最多有n-1个个构造器中使用了“this(形参列表)”</li><li>规定：“this(形参列表)”必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他构造器。</li></ul></li><li>示例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();        </span><br><span class="line">        p1.setAge(<span class="number">18</span>);</span><br><span class="line">        System.out.println(p1.getAge());</span><br><span class="line">        </span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Triabin&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(p2.getAge() + <span class="string">&quot;\t&quot;</span> + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器中使用:理解为当前正在创建的对象（Person）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this(name);//调用其他构造器</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法中使用:理解为当前对象（Person）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字：package、import"><a href="#关键字：package、import" class="headerlink" title="关键字：package、import"></a>关键字：package、import</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><h4 id="package关键字的使用"><a href="#package关键字的使用" class="headerlink" title="package关键字的使用"></a>package关键字的使用</h4><ol><li>为了更好的实现项目中类的管理，提供包的概念。</li><li>使用package来声明类或接口所属的包，声明在源文件首行。</li><li>包，属于标识符，遵循标识符的命名规则、规范（全小写）、见名知意。</li><li>每“.”一次，就代表一层文件目录。</li><li>同一个包下，不能命名同名的接口、类。</li></ol><h4 id="JDK中主要的包介绍"><a href="#JDK中主要的包介绍" class="headerlink" title="JDK中主要的包介绍"></a>JDK中主要的包介绍</h4><ol><li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System 和 Thread，提供常用功能。</li><li>java.net—-包含执行与网络相关的操作的类和接口。</li><li>java.io—-包含能提供多种输入/输出功能的类。</li><li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li><li>java.text—-包含了Java进行JDBC数据库编程的相关类/接口。</li><li>java.sql—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</li></ol><h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><ul><li>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</li></ul><ol><li>模型层：model，主要处理数据。<ul><li>数据对象封装 model.bean/domain</li><li>数据库操作类 model.dao</li><li>数据库 model.db</li></ul></li><li>控制层：controller，处理业务逻辑。<ul><li>应用界面相关 controller.activity</li><li>存放fragment controller.fragment</li><li>显示列表的适配器 controller.adapter</li><li>服务相关的 controller.service</li><li>抽取的基类 controller.base</li></ul></li><li>视图层：view，显示数据。<ul><li>相关工具类 view.utils</li><li>自定义view view.ui</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201210205505890.png" alt="image-20201210205505890"  /><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><h4 id="import关键字的使用"><a href="#import关键字的使用" class="headerlink" title="import关键字的使用"></a>import关键字的使用</h4><ol><li><p>在源文件显式的使用import结构导入指定包下的类、接口。</p></li><li><p>声明在包的声明和类的声明之间。</p></li><li><p>如果需要导入多个包，则并列写出即可。</p></li><li><p>可以使用“xxx.*”的方式导入xxx包下所有结构。</p></li><li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构。</p></li><li><p>如果使用的类或接口是本包下定义的，则可以省略import结构。</p></li><li><p>如果再源文件中使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。</p></li><li><p>如果使用“xxx.*”的方式表明可以调用xxx包下所有结构。但如果使用的是xxx子包下的结构，仍需要显示导入。</p></li><li><p>import static：导入指定类或接口中的静态结构。</p><p>静态结构：属性或方法</p></li></ol><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象的三大特征说明"><a href="#面向对象的三大特征说明" class="headerlink" title="面向对象的三大特征说明"></a>面向对象的三大特征说明</h4><ul><li><p>面向对象有三大特点：封装、继承、多态。(如果要回答四个，可加上抽象性这一特点)</p><ul><li><p>继承性</p><p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p></li><li><p>封装性</p><p>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p></li><li><p>多态性</p><p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p></li><li><p>抽象性</p><p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p></li></ul></li></ul><h4 id="作用域public、private、protected及默认不写时的区别？"><a href="#作用域public、private、protected及默认不写时的区别？" class="headerlink" title="作用域public、private、protected及默认不写时的区别？"></a>作用域public、private、protected及默认不写时的区别？</h4><ol><li>public：修饰的结构在同一个工程(Project)中的结构都可调用；</li><li>protected：同一个工程中不同包的子类、同一个包以内都可调用；</li><li>不写(缺省)：同一个包中的结构都可调用；</li><li>private：只在其所在类内部可以调用。</li></ol><h4 id="找错"><a href="#找错" class="headerlink" title="找错"></a>找错</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">int</span> l = s.length();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。</p><h4 id="Java的内存管理之垃圾回收（了解）"><a href="#Java的内存管理之垃圾回收（了解）" class="headerlink" title="Java的内存管理之垃圾回收（了解）"></a>Java的内存管理之垃圾回收（了解）</h4><ol><li>分配：由JVM自动为其分配相应的内存空间</li><li>释放：由JVM提供垃圾回收机制自动的释放内存空间</li><li>垃圾回收机制（GC：Garbage Collection）：将垃圾对象所占用的堆内存进行回收。Java的垃圾回收机制是JVM提供的能力，由单独的系统级垃圾回收线程在空闲时间以不定时的方式动态回收。</li><li><strong>垃圾对象</strong>：不再被任何引用指向的对象。</li></ol><h4 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h4><ol><li><p>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</p><p>答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java面对对象学习的三条主线&quot;&gt;&lt;a href=&quot;#Java面对对象学习的三条主线&quot; class=&quot;headerlink&quot; title=&quot;Java面对对象学习的三条主线&quot;&gt;&lt;/a&gt;Java面对对象学习的三条主线&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java类及类的成员：属</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十七章 Java9&amp;10&amp;11新特性</title>
    <link href="https://asteroidcs.github.io/undefined/1e12.html"/>
    <id>https://asteroidcs.github.io/undefined/1e12.html</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:18:55.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-9-的新特性"><a href="#Java-9-的新特性" class="headerlink" title="Java 9 的新特性"></a>Java 9 的新特性</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206091903388.png" alt="image-20201206091903388" style="zoom: 50%;" /><h3 id="JDK-和-JRE-目录结构的改变"><a href="#JDK-和-JRE-目录结构的改变" class="headerlink" title="JDK 和 JRE 目录结构的改变"></a>JDK 和 JRE 目录结构的改变</h3><ol><li>JDK 8 的目录结构</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206092159297.png" alt="image-20201206092159297" style="zoom: 50%;" /><ol start="2"><li>JDK 9 的目录结构</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206092310282.png" alt="image-20201206092310282" style="zoom:50%;" /><h3 id="模块化系统-Jigsaw-——-gt-Modularity"><a href="#模块化系统-Jigsaw-——-gt-Modularity" class="headerlink" title="模块化系统: Jigsaw ——&gt; Modularity"></a>模块化系统: Jigsaw ——&gt; Modularity</h3><ol><li><p>用模块来管理各个package，通过声明某个package 暴露，==模块(module)的概念==，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。</p></li><li><p>实现目标</p><ul><li>模块化的主要目的在于减少内存的开销</li><li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护</li><li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li><li>改进其安全性，可维护性，提高性能</li></ul></li><li><p>模块将由通常的类和新的模块声明文件(module-info.java)组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。</p></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206094326092.png" alt="image-20201206094326092" style="zoom: 50%;" /><ol start="4"><li><p>要想在java9demo模块中调用java9test模块下包中的结构：</p><ul><li>需要在java9test的module-info.java中声明:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206095559123.png" alt="image-20201206095559123" style="zoom:50%;" /><ul><li>对应在java 9demo 模块的src 下创建module-info.java文件:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206095726793.png" alt="image-20201206095726793" style="zoom:50%;" /><h3 id="Java的REPL工具：jShell命令"><a href="#Java的REPL工具：jShell命令" class="headerlink" title="Java的REPL工具：jShell命令"></a>Java的REPL工具：jShell命令</h3><ul><li>调出jShell</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100242680.png" alt="image-20201206100242680"></p><ul><li>获取帮助</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100324402.png" alt="image-20201206100324402" style="zoom:67%;" /><ul><li>基本使用</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206100418854.png" alt="image-20201206100418854"></p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101004699.png" alt="image-20201206101004699"  /><ul><li>导入指定的包</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101058508.png" alt="image-20201206101058508"></p><ul><li>默认已经导入如下的所有包：(包含java.lang包)</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101153232.png" alt="image-20201206101153232"></p><p>==Tips==：在 JShell 环境下，语句末尾的“;” 是可选的。但推荐还是最好加上。提高代码可读 性。</p><ul><li>只需按下 Tab 键，就能自动补全代码</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101454526.png" alt="image-20201206101454526"  /><ul><li>列出当前 session 里所有有效的代码片段</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101605180.png" alt="image-20201206101605180"></p><ul><li>查看当前 session 下所有创建过的变量</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101650915.png" alt="image-20201206101650915"></p><ul><li>查看当前 session 下所有创建过的方法</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206101741784.png" alt="image-20201206101741784"></p><p>Tips：我们还可以重新定义相同方法名和参数列表的方法，即为对现有方法的修改(或 覆盖)。</p><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102019032.png" alt="image-20201206102019032"></p><ul><li>使用/open命令调用:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102146113.png" alt="image-20201206102146113" style="zoom:50%;" /><ul><li>没有受检异常(编译时异常)</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102241899.png" alt="image-20201206102241899" style="zoom: 50%;" /><ul><li>退出jShell</li></ul><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206102339008.png" alt="image-20201206102339008"></p><h3 id="语法改进"><a href="#语法改进" class="headerlink" title="语法改进"></a>语法改进</h3><h4 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h4><ol><li>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 10:28 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如下三个方法放入权限修饰符都是public</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Java 8中此处报错，在java 9中就不会出现问题</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Java 9中，接口更加的灵活和强大，==连方法的访问权限修饰符都可 以声明为private的了==，此时方法将不会成为你对外暴露的API的一部分</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 10:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImp</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口中的静态方法只能由接口自己调用</span></span><br><span class="line">        MyInterface.methodStatic();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以调用默认方法</span></span><br><span class="line">        MyInterfaceImp imp = <span class="keyword">new</span> MyInterfaceImp();</span><br><span class="line">        imp.methodDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//无法调用私有方法，只能接口自己用</span></span><br><span class="line">        <span class="comment">//imp.methodPrivate(); </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="钻石操作符使用升级"><a href="#钻石操作符使用升级" class="headerlink" title="钻石操作符使用升级"></a>钻石操作符使用升级</h4><ul><li><p>能够与匿名实现类共同使用钻石操作符(diamond operator)</p></li><li><p>在Java 8中如下的操作是会报错的:</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206110852894.png" alt="image-20201206110852894" style="zoom:50%;" /><ul><li>Java 9中如下操作可以正常执行通过:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206110931300.png" alt="image-20201206110931300" style="zoom:50%;" /><h4 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h4><ul><li>Java 8 中，可以实现资源的==自动关闭==，但是==要求执行后必须关闭的所有资源必须在try子句中初始化==，否则编译不通过。如下例所示：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206111331957.png" alt="image-20201206111331957" style="zoom:50%;" /><ul><li>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206111407721.png" alt="image-20201206111407721" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-06 11:06 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java9Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//java 8之前的资源关闭操作</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java 8中的资源关闭操作:自动关闭</span></span><br><span class="line">        <span class="comment">//要求自动关闭的资源的初始化必须放在try的一对小括号中</span></span><br><span class="line">        <span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java 9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一对小括号外</span></span><br><span class="line">        <span class="comment">//此时的资源属性是常量，声明为final，不可修改</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        <span class="keyword">try</span> (reader) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">if</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h3><ul><li>String 再也不用 char[] 来存储，改成了 byte[] 加上编码标记，节约 了一些空间。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114110122.png" alt="image-20201206114110122" style="zoom: 50%;" /><ul><li>那StringBuffer 和 StringBuilder 是否仍无动于衷呢?</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114147541.png" alt="image-20201206114147541" style="zoom:50%;" /><h3 id="集合工厂方法：快速创建只读集合"><a href="#集合工厂方法：快速创建只读集合" class="headerlink" title="集合工厂方法：快速创建只读集合"></a>集合工厂方法：快速创建只读集合</h3><ol><li>以前要创建一个==只读、不可改变==的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114603325.png" alt="image-20201206114603325" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206114803975.png" alt="image-20201206114803975" style="zoom:50%;" /><ol start="2"><li>Java 9因此引入了方便的方法，这使得类似的事情更容易表达。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206115759239.png" alt="image-20201206115759239"></p><ol start="3"><li>调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的:在 创建后，继续添加元素到这些集合会导致“UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206115931236.png" alt="image-20201206115931236" style="zoom:50%;" /><h3 id="InputStream-加强"><a href="#InputStream-加强" class="headerlink" title="InputStream 加强"></a>InputStream 加强</h3><ul><li>InputStream 终于有了一个非常有用的方法：==transferTo==，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206132150043.png" alt="image-20201206132150043" style="zoom:50%;" /><h3 id="增强的-Stream-API"><a href="#增强的-Stream-API" class="headerlink" title="增强的 Stream API"></a>增强的 Stream API</h3><ol><li>Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。</li><li>在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法: <ul><li>takeWhile</li><li> dropWhile,</li><li>ofNullable</li><li>iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</li></ul></li><li>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。</li></ol><h4 id="takeWhile-的使用"><a href="#takeWhile-的使用" class="headerlink" title="takeWhile()的使用"></a>takeWhile()的使用</h4><ul><li>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，==takeWhile 返回从开头开始的尽量多的元素==。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// takeWhile 返回从开头开始的按照指定规则尽量多的元素</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">        list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);  <span class="comment">// 45  43</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);  <span class="comment">// 1  2  3  4</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="dropWhile-的使用"><a href="#dropWhile-的使用" class="headerlink" title="dropWhile()的使用"></a>dropWhile()的使用</h4><ul><li>dropWhile 的行为与 takeWhile 相反，返回剩余的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">        list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ofNullable-的使用"><a href="#ofNullable-的使用" class="headerlink" title="ofNullable()的使用"></a>ofNullable()的使用</h4><ul><li>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报NullPointerException，of()参数不能存储单个null值</span></span><br><span class="line">        <span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line">        <span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不报异常，允许通过</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(stringStream.count()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不报异常，允许通过</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(list.stream().count()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ofNullable():允许值为null</span></span><br><span class="line">        Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(stream1.count());<span class="comment">// 0</span></span><br><span class="line">        </span><br><span class="line">        Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(stream.count()); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="iterate-重载的使用"><a href="#iterate-重载的使用" class="headerlink" title="iterate()重载的使用"></a>iterate()重载的使用</h4><ul><li>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原来的控制终止方式:</span></span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 现在的终止方式:</span></span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Optional获取Stream的方法"><a href="#Optional获取Stream的方法" class="headerlink" title="Optional获取Stream的方法"></a>Optional获取Stream的方法</h3><ul><li>Optional类中stream()的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class="line">        Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">        stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript引擎升级：Nashorn"><a href="#Javascript引擎升级：Nashorn" class="headerlink" title="Javascript引擎升级：Nashorn"></a>Javascript引擎升级：Nashorn</h3><ul><li>Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。</li><li>JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。</li></ul><h2 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h2><h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a><strong>局部变量类型推断</strong></h3><ul><li><p>好处：减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！</p></li><li><p>举例如下：</p><ul><li><p><strong>场景一：类实例化时</strong>：作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第</p><p>一次用于声明变量类型，第二次用于构造器。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>场景二：返回值类型含复杂泛型结构：变量的声明类型书写复杂且较长，尤其是加上泛型的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure><ul><li><p><strong>场景三：</strong></p><p>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.atguigu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure></li><li><p><strong>适用于以下情况：</strong></p><ul><li>局部变量的初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>增强for循环中的索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传统for循环中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在局部变量中使用时，如下情况不适用：</strong></p><ul><li>初始值为null</li><li>Lambda表达式</li><li>方法引用</li><li>为数组静态初始化</li></ul></li><li><p><strong>不适用以下的结构中：</strong></p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206180853363.png" alt="image-20201206180853363" style="zoom:50%;" /><ul><li><p>==<strong>工作原理</strong>==</p><p>在处理 var时，==编译器先是查看表达式右边部分==，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。 </p></li><li><p>==<strong>注 意</strong>==</p><ul><li><strong>var</strong>不是一个关键字</li><li><strong>这不是</strong>JavaScript，var并不会改变Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206181503242.png" alt="image-20201206181503242" style="zoom: 33%;" /></li></ul><h3 id="集合新增创建不可变集合的方法"><a href="#集合新增创建不可变集合的方法" class="headerlink" title="集合新增创建不可变集合的方法"></a><strong>集合新增创建不可变集合的方法</strong></h3><ul><li>自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206181706108.png" alt="image-20201206181706108" style="zoom: 50%;" /><ul><li><p>示例1和2代码基本一致，为什么一个为true,一个为false?</p><p>结论：copyOf(Xxx coll)：如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前coll；如果参数coll不是只读集合，则copyOf返回一个新的只读集合，这个集合只读。</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206182127916.png" alt="image-20201206182127916" style="zoom: 33%;" /><h2 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h2><h3 id="新增了一系列字符串处理方法"><a href="#新增了一系列字符串处理方法" class="headerlink" title="新增了一系列字符串处理方法"></a><strong>新增了一系列字符串处理方法</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206183941103.png" alt="image-20201206183941103" style="zoom: 50%;" /><h3 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a><strong>Optional</strong> <strong>加强</strong></h3><ul><li>可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206184524889.png" alt="image-20201206184524889" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;Object&gt; op = Optional.empty();</span><br><span class="line">        System.out.println(op.isPresent());</span><br><span class="line">        System.out.println(op.isEmpty());</span><br><span class="line"></span><br><span class="line">        op = Optional.of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        Object o = op.orElseThrow();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// op = Optional.empty();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//or:value非空，返回对应的Optional；value为空，返回形参封装的Optional</span></span><br><span class="line">        Optional&lt;Object&gt; op2 = op.or(() -&gt; op1);</span><br><span class="line">        System.out.println(op2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量类型推断升级"><a href="#局部变量类型推断升级" class="headerlink" title="局部变量类型推断升级"></a><strong>局部变量类型推断升级</strong></h3><ul><li>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样=的语法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line">        <span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正确的形式:</span></span><br><span class="line">        <span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。</span></span><br><span class="line">        Consumer&lt;String&gt; con2 = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="全新的-HTTP-客户端-API"><a href="#全新的-HTTP-客户端-API" class="headerlink" title="全新的 HTTP 客户端 API"></a>全新的 HTTP 客户端 API</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206191100225.png" alt="image-20201206191100225" style="zoom: 50%;" /><h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a><strong>更简化的编译运行程序</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206191831700.png" alt="image-20201206191831700" style="zoom: 50%;" /><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a><strong>ZGC</strong></h3><ol><li>优势：<ul><li>GC暂停时间不会超过10ms</li><li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li><li>和G1相比, 应用吞吐能力不会下降超过15% </li><li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li><li>初始只支持64位系统</li></ul></li><li>==ZGC的设计目标是==：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</li></ol><h3 id="其它新特性"><a href="#其它新特性" class="headerlink" title="其它新特性"></a><strong>其它新特性</strong></h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201206192312496.png" alt="image-20201206192312496" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-9-的新特性&quot;&gt;&lt;a href=&quot;#Java-9-的新特性&quot; class=&quot;headerlink&quot; title=&quot;Java 9 的新特性&quot;&gt;&lt;/a&gt;Java 9 的新特性&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/asteroidc</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十六章 Java8的其他新特性</title>
    <link href="https://asteroidcs.github.io/undefined/1e12.html"/>
    <id>https://asteroidcs.github.io/undefined/1e12.html</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:19:01.501Z</updated>
    
    <content type="html"><![CDATA[<img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/3424242423.png" alt="3424242423" /><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>速度更快</li><li>代码更少(增加了新的语法:Lambda 表达式)  强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常:Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ol><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3><ol><li>并行流：就是把一个内容分成多个数据块，并用不同的线程分别处理每个数 据块的流。</li><li>相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流 之间进行切换</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="为什么使用-Lambda-表达式"><a href="#为什么使用-Lambda-表达式" class="headerlink" title="为什么使用 Lambda 表达式"></a>为什么使用 Lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以 传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</span><br></pre></td></tr></table></figure><ol><li>从匿名类到 Lambda 的转换举例1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 11:02 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我爱吃红烧肉！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        runnable.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; System.out.println(<span class="string">&quot;我爱喝排骨汤！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        runnable1.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从匿名类到 Lambda 的转换举例2</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; integerComparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> compare = integerComparator.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; integerComparator1 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">        <span class="comment">//Comparator&lt;Integer&gt; integerComparator1 = Integer :: compare;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> compare1 = integerComparator.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda-表达式：语法"><a href="#Lambda-表达式：语法" class="headerlink" title="Lambda 表达式：语法"></a>Lambda 表达式：语法</h3><ol><li>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<ul><li>左侧:指定了 Lambda 表达式需要的参数列表（其实就是接口中的抽象方法的形参列表）</li><li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。</li></ul></li></ol><h3 id="Lambda-表达式的使用（分6种情况）"><a href="#Lambda-表达式的使用（分6种情况）" class="headerlink" title="Lambda 表达式的使用（分6种情况）"></a>Lambda 表达式的使用（分6种情况）</h3><ol><li>语法格式一:无参，无返回值</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120459028.png" alt="image-20201202120459028" style="zoom:50%;" /><ol start="2"><li>语法格式二：:Lambda 需要一个参数，但是没有返回值。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120532056.png" alt="image-20201202120532056" style="zoom: 67%;" /><ol start="3"><li>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120615006.png" alt="image-20201202120615006" style="zoom: 67%;" /><ol start="4"><li>语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120652505.png" alt="image-20201202120652505" style="zoom:67%;" /><ol start="5"><li>语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120803484.png" alt="image-20201202120803484" style="zoom:50%;" /><ol start="6"><li>语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202120830859.png" alt="image-20201202120830859" style="zoom: 67%;" /><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>左边：Lambda形参列表的参数类型可以省略（类型推断），若Lambda形参列表只有一个参数，其中一对（）也可以省略</li><li>右边：Lambda体应该用一对{}包裹；如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return</li></ul><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>​    上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序 的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于 上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202121451988.png" alt="image-20201202121451988" style="zoom:50%;" /><h2 id="函数式-Functional-接口"><a href="#函数式-Functional-接口" class="headerlink" title="函数式(Functional)接口"></a>函数式(Functional)接口</h2><h3 id="什么是函数式-Functional-接口"><a href="#什么是函数式-Functional-接口" class="headerlink" title="什么是函数式(Functional)接口"></a>什么是函数式(Functional)接口</h3><ol><li>只包含==一个抽象方法==的接口，称为==函数式接口==。</li><li>可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda 表达式抛出一个受检异常(即:非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。</li><li>可以在一个接口上使用 ==@FunctionalInterface==注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li><li>在java.util.function包下定义了Java 8 的丰富的函数式接口</li></ol><h3 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title="如何理解函数式接口"></a>如何理解函数式接口</h3><ol><li>java 不但可以支持OOP还 可以支持OOF (面向函数编程)</li><li>在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。</li><li>在Java8中，==Lambda表达式就是一个函数式接口的实例==。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。</li><li>==以前用匿名实现类表示的现在都可以用Lambda表达式来写。==</li></ol><h3 id="Java-内置四大核心函数式接口"><a href="#Java-内置四大核心函数式接口" class="headerlink" title="Java 内置四大核心函数式接口"></a>Java 内置四大核心函数式接口</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202124949640.png" alt="image-20201202124949640" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 11:57 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        happyTime(<span class="number">500</span>, <span class="keyword">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;购物花了&quot;</span> + aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        happyTime(<span class="number">400</span>, money -&gt; System.out.println(<span class="string">&quot;购物花了&quot;</span> + money));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyTime</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class="line">        consumer.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;东京&quot;</span>, <span class="string">&quot;西京&quot;</span>);</span><br><span class="line">        List&lt;String&gt; filterString = filterString(list, <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(filterString);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterString1 = filterString(list, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterString1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.test(s))&#123;</span><br><span class="line">                filterList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202125020900.png" alt="image-20201202125020900" style="zoom:50%;" /><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用-Method-References"><a href="#方法引用-Method-References" class="headerlink" title="方法引用(Method References)"></a>方法引用(Method References)</h3><ol><li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用!</li><li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li><li>==要求==：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致!</li><li>==格式==：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</li><li>如下三种主要使用情况：<ul><li>对象：：实例方法名</li><li>类：：静态方法名</li><li>类：：实例方法名</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205192602281.png" alt="image-20201205192602281" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205192934376.png" alt="image-20201205192934376" style="zoom:50%;" /><ol start="6"><li>==注意==：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时:ClassName::methodName</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况三：类：：实例方法</span></span><br><span class="line">    <span class="comment">//Comparator中的int compare(T t1, T t2)</span></span><br><span class="line">    <span class="comment">//String中的int t1.compareTo(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(comparator.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; comparator1 = String::compareTo;</span><br><span class="line">        System.out.println(comparator1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><ol><li>格式:：ClassName：：new<ul><li>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205195947990.png" alt="image-20201205195947990" style="zoom:50%;" /><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><ol><li>格式: type[] :: new<ul><li>可以把数组看作是一个特殊的类，则写法与构造器引用一致</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205200005415.png" alt="image-20201205200005415" style="zoom:50%;" /><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><ol><li>Java8中有两大最为重要的改变。第一个是：Lambda 表达式，另外一个则是：Stream API。</li><li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。</li></ol><h3 id="为什么要使用Stream-API"><a href="#为什么要使用Stream-API" class="headerlink" title="为什么要使用Stream API"></a>为什么要使用Stream API</h3><ul><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。</li><li>Stream 和 Collection 集合的区别：<ul><li>Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。</li><li>前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。</li></ul></li></ul><h3 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h3><ol><li>数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。<ul><li>“集合讲的是数据，Stream讲的是计算！”</li></ul></li><li>注意：<ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ul></li></ol><h3 id="Stream-的操作三个步骤"><a href="#Stream-的操作三个步骤" class="headerlink" title="Stream 的操作三个步骤"></a>Stream 的操作三个步骤</h3><ol><li>步骤：<ul><li>创建 Stream：一个数据源(如:集合、数组)，获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205202942831.png" alt="image-20201205202942831" style="zoom:50%;" /><h4 id="创建-Stream方式"><a href="#创建-Stream方式" class="headerlink" title="创建 Stream方式"></a>创建 Stream方式</h4><ol><li>方式一：通过集合<ul><li>Java8 中的 Collection 接口被扩展，提供了两个获取流 的方法:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205210640.png" alt="image-20201205205210640" style="zoom:50%;" /><ol start="2"><li>方式二：通过数组<ul><li>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流:</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205724317.png" alt="image-20201205205724317" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205205808435.png" alt="image-20201205205808435" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        IntStream stream = Arrays.stream(arr);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>方式三:通过Stream的of()<ul><li>可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210125888.png" alt="image-20201205210125888" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>方式四：创建无限流（用的较少，了解即可）</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210300832.png" alt="image-20201205210300832" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h4><p>​        多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则==中间操作不会执行任何的处理!而在终止操作时一次性全 部处理，称为“惰性求值”==</p><ol><li>筛选与切片</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205210937302.png" alt="image-20201205210937302" style="zoom:50%;" /><ol start="2"><li>映 射</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211238734.png" alt="image-20201205211238734" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toCharArray()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>排序</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211315019.png" alt="image-20201205211315019" style="zoom:50%;" /><h4 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h4><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如:List、Integer，甚至是 void 。</li><li>流进行了终止操作后，不能再次使用。</li></ul><ol><li>匹配与查找</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211532968.png" alt="image-20201205211532968" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211602753.png" alt="image-20201205211602753" style="zoom:50%;" /><ol start="2"><li>归约</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211638535.png" alt="image-20201205211638535" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名</p><ol start="3"><li>收集</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205211750079.png" alt="image-20201205211750079" style="zoom:50%;" /><p>​    Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)</p><ol start="4"><li>Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表：</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205213813629.png" alt="image-20201205213813629" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205213837908.png" alt="image-20201205213837908" style="zoom:50%;" /><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><ul><li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></li><li><p>Optional类的Javadoc描述如下:这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。</p></li><li><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p></li><li><p>创建Optional类对象的方法:</p></li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214213547.png" alt="image-20201205214213547" style="zoom:50%;" /><ul><li>判断Optional容器中是否包含对象：</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214243635.png" alt="image-20201205214243635" style="zoom:50%;" /><ul><li>获取Optional容器的对象:</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201205214312644.png" alt="image-20201205214312644" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); <span class="comment">// 如果女朋友存在就打印女朋友的信息 opt.ifPresent(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend()); <span class="comment">// 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了</span></span><br><span class="line">        Girl girl = opt.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;嫦娥&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;他的女朋友是:&quot;</span> + girl.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>)); <span class="comment">//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空 Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000); System.out.println(emp);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>)); <span class="comment">//如果opt中员工对象不为空，就涨薪10%</span></span><br><span class="line">        Optional&lt;Employee&gt; emp = opt.map(e -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.setSalary(e.getSalary() % <span class="number">1.1</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/3424242423.png&quot; alt=&quot;3424242423&quot; /&gt;

&lt;h3 id=&quot;优点：&quot;&gt;&lt;a href=&quot;#优点：&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第十五章 反射机制</title>
    <link href="https://asteroidcs.github.io/undefined/a7d1.html"/>
    <id>https://asteroidcs.github.io/undefined/a7d1.html</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-12-10T13:18:38.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构"><a href="#重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构" class="headerlink" title="重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构"></a>重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h3><ol><li><p><strong>Reflection(反射)**是被视为</strong>$\color{red}{动态语言}$**的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p></li><li><p>补充：动态语言 vs 静态语言</p><ul><li><p>动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><ul><li>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang</li></ul></li><li><p>静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。</p></li></ul></li><li><p>Java不是动态语言，但Java可以称之为$\color{yellow}{“准动态语言”}$。即Java有一定的动态性，可以利用$\color{red}{反射机制、字节码操作}$获得类似动态语言的特性。 </p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。</p><ul><li>$\color{red}{我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，故形象的称之为：反射}$</li></ul></li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201105916507.png" alt="image-20201201105916507"  /><ol start="5"><li><p>Java反射机制提供的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象 </li><li>在运行时判断任意一个类所具有的成员变量和方法 </li><li>在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 </li><li>在运行时处理注解</li><li>生成动态代理</li></ul></li><li><p>反射相关的主要API</p><ul><li><p>java.lang.Class：代表一个类</p></li><li><p>java.lang.reflect.Method：代表类的方法</p></li><li><p>java.lang.reflect.Field：代表类的成员变量</p><p>java.lang.reflect.Constructor：代表类的构造器</p></li></ul></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Person"><a href="#Person" class="headerlink" title="Person"></a>Person</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-01 12:00 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，我是一个人！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是：&quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射前对于类的操作"><a href="#反射前对于类的操作" class="headerlink" title="反射前对于类的操作"></a>反射前对于类的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射前对于类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建Person类的实例化</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过对象，调用其内部的属性、方法</span></span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    p1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Person类的外部，不可以通过Person类的对象调用其内部私有结构</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射后对于类的操作"><a href="#反射后对于类的操作" class="headerlink" title="反射后对于类的操作"></a>反射后对于类的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类的对象</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person person = constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调属性</span></span><br><span class="line">    Field age = personClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(person, <span class="number">10</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//调方法</span></span><br><span class="line">    Method show = personClass.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(person);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构。如：私有的构造器、方法、属性</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor1 = personClass.getDeclaredConstructor(String.class);</span><br><span class="line">    constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person person1 = constructor1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    Field name = personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(person1, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    Method showNation = personClass.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object nation = showNation.invoke(person1, <span class="string">&quot;中国&quot;</span>);<span class="comment">// 相当于p1.showNation(&quot;中国&quot;）</span></span><br><span class="line">    System.out.println(nation);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？"><a href="#疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？" class="headerlink" title="疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？"></a>疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中用哪个？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建议直接用<span class="keyword">new</span>的方式</span><br><span class="line"><span class="comment">//什么时候用：放射的方式。————&gt; 反射的特征：动态性</span></span><br></pre></td></tr></table></figure><h4 id="疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？"><a href="#疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？" class="headerlink" title="疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？"></a>疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？</h4><h2 id="理解Class类-并-获取Class的实例"><a href="#理解Class类-并-获取Class的实例" class="headerlink" title="理解Class类 并 获取Class的实例"></a>理解Class类 并 获取Class的实例</h2><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><ol><li>类的加载过程<ul><li>程序经过Java.exe命令以后，会生成一个或多个字节码文件(.class结尾)</li><li>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存。此过程就称为类的加载。加载到内存中的类，就称为运行时的类，此时运行时的类就作为C lass的一个实例</li></ul></li><li>换句话说，Class的实例就对应着一个运行时类</li><li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li><li>在Object类中定义了以下的方法，此方法将被所有子类继承<ul><li>public final Class getClass()</li></ul></li><li>以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201125814351.png" alt="image-20201201125814351" style="zoom:50%;" /><ol start="6"><li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息<ul><li>Class本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul></li></ol><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201131201652.png" alt="image-20201201131201652" style="zoom: 50%;" /><h3 id="获取Class类的实例-四种方法"><a href="#获取Class类的实例-四种方法" class="headerlink" title="获取Class类的实例(四种方法)"></a>获取Class类的实例(四种方法)</h3><ol><li>前提:若已知具体的类，通过类的class属性获取，该方法最为安全可靠， 程序性能最高</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = String.class;</span><br></pre></td></tr></table></figure><ol start="2"><li>前提:已知某个类的实例，调用该实例的getClass()方法获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = “www.atguigu.com”.getClass();</span><br></pre></td></tr></table></figure><ol start="3"><li>前提:已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(“java.lang.String”)</span><br></pre></td></tr></table></figure><ol start="4"><li>其他方式(不做要求)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader(); Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class的实例方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">        Class clazz1 = Person.class;</span><br><span class="line">        System.out.println(clazz1);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过运行时类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Class clazz2 = p1.getClass();</span><br><span class="line">        System.out.println(clazz2);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;lesson.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz3);  <span class="comment">// class lesson.Person</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四：使用类的加载器：ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">        Class clazz4 = classLoader.loadClass(<span class="string">&quot;lesson.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz4);  <span class="comment">// class lesson.Person</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象?"></a>哪些类型可以有Class对象?</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201141515986.png" alt="image-20201201141515986" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = <span class="keyword">int</span>[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c10 = a.getClass();</span><br><span class="line">Class c11 = b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);</span></span><br></pre></td></tr></table></figure><h2 id="类的加载-与-ClassLoader的理解"><a href="#类的加载-与-ClassLoader的理解" class="headerlink" title="类的加载 与 ClassLoader的理解"></a>类的加载 与 ClassLoader的理解</h2><h3 id="类的加载过程（了解）"><a href="#类的加载过程（了解）" class="headerlink" title="类的加载过程（了解）"></a>类的加载过程（了解）</h3><p>​    当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201142014269.png" alt="image-20201201142014269" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201142125015.png" alt="image-20201201142125015" style="zoom:50%;" /><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据$\color{yellow}{转换成方法区的运行时数据结构}$，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li></ul><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143129820.png" alt="image-20201201143129820" style="zoom: 67%;" /><h3 id="ClassLoader-了解"><a href="#ClassLoader-了解" class="headerlink" title="ClassLoader(了解)"></a>ClassLoader(了解)</h3><ol><li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143216184.png" alt="image-20201201143216184" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143453630.png" alt="image-20201201143453630" style="zoom:50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201143519125.png" alt="image-20201201143519125" style="zoom:50%;" /><h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="有了Class对象，能做什么"><a href="#有了Class对象，能做什么" class="headerlink" title="有了Class对象，能做什么?"></a>有了Class对象，能做什么?</h3><ol><li><p>创建类的对象：调用Class对象的newInstance()方法。要求：</p><ul><li><p>类必须有一个无参数的构造器。</p></li><li><p>类的构造器的访问权限需要足够，通常设置为public</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        newInstance():调用此方法，创建对应的运行时类的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Person obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在javabean中要求提供一个public的空参构造器。原因：<ul><li>便于通过反射，创建运行时类的对象</li><li>便于子类继承次运行时类时，默认调用super()时，保证父类有此构造器</li></ul></li><li>难道没有无参的构造器就不能创建对象了吗? ————&gt; NO，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下:<ul><li>通过Class类的$\color{red}{getDeclaredConstructor(Class … parameterTypes)}$取得本类的指定形参类 型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体现反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;lesson.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object instance = getInstance(classPath);</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(classPath);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201155339974.png" alt="image-20201201155339974"  /><p>使用反射可以取得:</p><ol><li>实现的全部接口：确定此对象所表示的类或接口实现的接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()</span><br></pre></td></tr></table></figure><ol start="2"><li>所继承的父类：返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br></pre></td></tr></table></figure><ol><li><p>全部的构造器</p><ul><li>返回此 Class 对象所表示的类的所有public构造方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br></pre></td></tr></table></figure><ul><li>返回此 Class 对象表示的类声明的所有构造方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br></pre></td></tr></table></figure><p>Constructor类中:</p><ul><li>取得修饰符: </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得方法名称: </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得参数的类型:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br></pre></td></tr></table></figure></li><li><p>全部的方法</p><ul><li>返回此Class对象所表示的类或接口的全部方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br></pre></td></tr></table></figure><ul><li>返回此Class对象所表示的类或接口的public的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods()</span><br></pre></td></tr></table></figure><p>Method类中:</p><ul><li>取得全部的返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()</span><br></pre></td></tr></table></figure><ul><li>取得全部的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()</span><br></pre></td></tr></table></figure><ul><li>取得修饰符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>取得异常信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()</span><br></pre></td></tr></table></figure></li><li><p>全部的Field</p><ul><li>返回此Class对象所表示的类或接口的public的Field。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br></pre></td></tr></table></figure><ul><li>返回此Class对象所表示的类或接口的全部Field。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br></pre></td></tr></table></figure><p>Field方法中:</p><ul><li>以整数形式返回此Field的修饰符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>得到Field的属性类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType()</span><br></pre></td></tr></table></figure><ul><li>返回Field的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取属性结构：</span></span><br><span class="line">        <span class="comment">//getFields():能够获取当前运行时类及其所有父类当中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性，不包含父类中声明的属性</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="keyword">int</span> modifier = f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifier) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Annotation相关</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">get <span class="title">Annotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span></span><br><span class="line"><span class="function"><span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>泛型相关</p><ul><li>获取父类泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParameterizedType</span><br></pre></td></tr></table></figure><ul><li>获取实际的泛型类型参数数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getActualTypeArguments()</span><br></pre></td></tr></table></figure></li><li><p>类所在的包</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Package <span class="title">getPackage</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ol><li>在实际的操作中，取得类的信息的操作代码，并不会经常开发。 </li><li>一定要熟悉java.lang.reflect包的作用，反射机制。 </li><li>如何取得属性、方法、构造器的名称，修饰符等。</li></ol><h2 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h2><h3 id="调用指定方法"><a href="#调用指定方法" class="headerlink" title="调用指定方法"></a>调用指定方法</h3><p>​    通过反射，调用类中的方法，通过Method类完成。步骤:</p><ol><li>通过Class类的  ==getMethod(String name,Class…parameterTypes)==  方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用  ==Object invoke(Object obj, Object[] args)==  进行调用，并向方法中 传递要设置的obj对象的参数信息。</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201215911851.png" alt="image-20201201215911851" style="zoom: 67%;" /><ol start="3"><li>Object invoke(Object obj, Object … args)，说明：<ul><li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li><li>若原方法若为静态方法，此时形参Object obj可为null</li><li>若原方法形参列表为空，则Object[] args为null</li><li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定属性</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        id.set(person, <span class="number">1001</span>);</span><br><span class="line">        Object o = id.get(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        age.set(person, <span class="number">18</span>);</span><br><span class="line">        Object o1 = age.get(person);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line">        <span class="comment">// 获取指定的某个方法</span></span><br><span class="line">        <span class="comment">//getDeclaredMethod(): 参数1：指明获取的方法的名称  参数2：指明获取的方法形参列表</span></span><br><span class="line">        Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//保证当前方法时可访问的</span></span><br><span class="line">        show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//调用invoke()方法：参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line">        <span class="comment">//invoke()的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line">        Object o = show.invoke(person, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">      </span><br><span class="line">     System.out.println(<span class="string">&quot;*************调用静态方法***************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Method showDesc = clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">        showDesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        showDesc.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用指定属性"><a href="#调用指定属性" class="headerlink" title="调用指定属性"></a>调用指定属性</h3><p>​    在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。</p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201220154222.png" alt="image-20201201220154222" style="zoom: 50%;" /><h3 id="关于setAccessible方法的使用"><a href="#关于setAccessible方法的使用" class="headerlink" title="关于setAccessible方法的使用"></a>关于setAccessible方法的使用</h3><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201201220256922.png" alt="image-20201201220256922" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        Person person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定属性</span></span><br><span class="line">        Field id = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        id.set(person, <span class="number">1001</span>);</span><br><span class="line">        Object o = id.get(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        age.set(person, <span class="number">18</span>);</span><br><span class="line">        Object o1 = age.get(person);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射的应用：动态代理"><a href="#反射的应用：动态代理" class="headerlink" title="反射的应用：动态代理"></a>反射的应用：动态代理</h2><ol><li>代理设计模式的原理:<ul><li>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上</li></ul></li><li>静态代理：特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:20 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClothFactory factory;  <span class="comment">// 用被代理的对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        NikeClothFactory nike = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态代理：是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p></li><li><p>动态代理使用场合：</p><ul><li>调试</li><li>远程方法调用</li></ul></li><li><p>动态代理相比于静态代理的优点：</p><ul><li>抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li></ul></li></ol><h3 id="Java动态代理相关API"><a href="#Java动态代理相关API" class="headerlink" title="Java动态代理相关API"></a>Java动态代理相关API</h3><ol><li><p>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。</p></li><li><p>供用于创建动态代理类和动态代理对象的静态方法</p><ul><li>创建一个动态代理类所对应的Class对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</span><br></pre></td></tr></table></figure><ul><li>直接创建一个动态代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202091232315.png" alt="image-20201202091232315" style="zoom: 50%;" /></li></ol><h3 id="动态代理步骤"><a href="#动态代理步骤" class="headerlink" title="动态代理步骤"></a>动态代理步骤</h3><ol><li>创建一个实现接口. InvocationHandler. 的类，它必须实现invoke方法，以完成代理的具体操作。</li></ol><p><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202094849540.png" alt="image-20201202094849540" style="zoom: 50%;" /><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101431301.png" alt="image-20201202101431301"></p><ol start="2"><li>创建被代理的类以及接口</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101502146.png" alt="image-20201202101502146" style="zoom:50%;" /><ol start="3"><li>通过Proxy的静态方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101626255.png" alt="image-20201202101626255" style="zoom: 50%;" /><ol start="4"><li>通过 Subject代理调用RealSubject实现类的方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202101648873.png" alt="image-20201202101648873" style="zoom:50%;" /><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 动态代理的举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:30 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I believe I can fly!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;  <span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 赋值时，需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);  <span class="comment">// 反射</span></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中invoke(）的返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance：代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法</span></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;麻辣香锅&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理与AOP-Aspect-Orient-Programming"><a href="#动态代理与AOP-Aspect-Orient-Programming" class="headerlink" title="动态代理与AOP(Aspect Orient Programming)"></a>动态代理与AOP(Aspect Orient Programming)</h3><ol><li>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102356348.png" alt="image-20201202102356348" style="zoom:50%;" /><ol start="2"><li>改进后的说明:代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和 一个特定的方法A耦合了!最理想的效果是:代码块1、2、3既可以执行方法A，又无须在程序 中以硬编码的方式直接调用深色代码的方法</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102458808.png" alt="image-20201202102458808" style="zoom: 50%;" /><ol start="3"><li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理</li><li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异: ==AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理==</li></ol><img src="https://gitee.com/asteroidcs/pic-go-cloud/raw/master/Custom/image-20201202102635867.png" alt="image-20201202102635867" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Justry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 动态代理的举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-02 9:30 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I believe I can fly!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================通用方法一===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================通用方法二===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;  <span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 赋值时，需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        HumanUtil util = <span class="keyword">new</span> HumanUtil();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method：即为代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);  <span class="comment">// 反射</span></span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中invoke(）的返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance：代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象掉哟个方法时，会自动调用被代理类中的同名方法</span></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;麻辣香锅&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构&quot;&gt;&lt;a href=&quot;#重点掌握：获取Class实例、创建运行时类的对象、调用运行时类的指定结构&quot; class=&quot;headerlink&quot; title=&quot;重点掌握：获取Class实例、创建运行时</summary>
      
    
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://asteroidcs.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://asteroidcs.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
